#[doc = "A parser for JSON file."]
#[doc = ""]
#[doc = "And this is a example for JSON parser."]
#[doc = ""]
#[doc = "Created by [Tomas Tauber](https://github.com/tomtau)."]
#[doc = "Modified by [Boyi Huang](https://github.com/TheVeryDarkness)."]
#[allow(
    dead_code,
    missing_docs,
    non_camel_case_types,
    clippy::upper_case_acronyms
)]
#[derive(Clone, Copy, Debug, Eq, Hash, Ord, PartialEq, PartialOrd)]
pub enum Rule {
    EOI,
    r#json,
    #[doc = "Matches object, e.g.: `{ \"foo\": \"bar\" }`"]
    #[doc = "Foobar"]
    r#object,
    r#pair,
    r#array,
    #[doc = "///////////////////"]
    #[doc = "Matches value, e.g.: `\"foo\"`, `42`, `true`, `null`, `[]`, `{}`."]
    #[doc = "///////////////////"]
    r#value,
    r#string,
    r#inner,
    r#escape,
    r#unicode,
    r#number,
    r#int,
    r#exp,
    r#bool,
    r#null,
    r#space,
    r#p(rules::r#p::Rule),
}
impl ::pest3_core::typed::SuperRule<rules::r#p::Rule> for Rule {
    fn cvt_from(rule: rules::r#p::Rule) -> Self {
        Self::r#p(rule)
    }
}
impl ::pest3_core::typed::RuleType for Rule {
    const EOI: Self = Rule::EOI;
}
#[doc = "Definitions of statically typed nodes generated by pest-generator."]
pub mod rules {
    pub type __OptionalTrivia<'i> =
        super::generics::Rep<r#space<'i>, ::pest3_core::typed::template::Empty>;
    pub type __MandatoryTrivia<'i> = super::generics::Sequence3<
        super::generics::Rep<r#space<'i>, ::pest3_core::typed::template::Empty>,
        ::pest3_core::typed::template::Empty,
        super::generics::Str<super::wrapper::W22>,
        ::pest3_core::typed::template::Empty,
        super::generics::Rep<r#space<'i>, ::pest3_core::typed::template::Empty>,
        ::pest3_core::typed::template::Empty,
    >;
    pub mod p {
        #[allow(
            dead_code,
            missing_docs,
            non_camel_case_types,
            clippy::upper_case_acronyms
        )]
        #[derive(Clone, Copy, Debug, Eq, Hash, Ord, PartialEq, PartialOrd)]
        pub enum Rule {
            EOI,
            r#ascii_hex_digit,
            r#ascii_digit,
            r#ascii_nonzero_digit,
            r#whitespaces,
            r#int,
        }
        impl ::pest3_core::typed::RuleType for Rule {
            const EOI: Self = Rule::EOI;
        }
        #[doc = "Definitions of statically typed nodes generated by pest-generator."]
        pub mod rules {
            pub type __OptionalTrivia<'i> = ::pest3_core::typed::template::Empty;
            pub type __MandatoryTrivia<'i> = ::pest3_core::typed::template::Empty;
            #[doc = "Generated for rule `ascii_hex_digit`. Grammar: `(ascii_digit | (\"A\" | (\"B\" | (\"C\" | (\"D\" | (\"E\" | \"F\"))))))`."]
            #[derive(Clone, Debug, Eq, PartialEq)]
            #[allow(non_camel_case_types)]
            pub struct r#ascii_hex_digit<'i> {
                #[doc = r" Matched structure."]
                pub content: ::pest3_core::std::Box<
                    super::super::super::generics::Choice7<
                        r#ascii_digit<'i>,
                        super::super::super::generics::Str<super::super::super::wrapper::W0>,
                        super::super::super::generics::Str<super::super::super::wrapper::W1>,
                        super::super::super::generics::Str<super::super::super::wrapper::W2>,
                        super::super::super::generics::Str<super::super::super::wrapper::W3>,
                        super::super::super::generics::Str<super::super::super::wrapper::W4>,
                        super::super::super::generics::Str<super::super::super::wrapper::W5>,
                    >,
                >,
                #[doc = r" Matched span."]
                pub span: ::pest3_core::Span<'i>,
            }
            #[allow(non_camel_case_types)]
            impl<'i> ::pest3_core::typed::wrapper::Rule for r#ascii_hex_digit<'i> {
                type Rule = super::Rule;
                const RULE: super::Rule = super::Rule::r#ascii_hex_digit;
            }
            #[allow(non_camel_case_types)]
            impl<'i> r#ascii_hex_digit<'i> {
                #[doc = "A helper function to access [`ascii_digit`]."]
                #[allow(non_snake_case)]
                pub fn r#ascii_digit<'s>(
                    &'s self,
                ) -> ::pest3_core::std::Option<&'s r#ascii_digit<'i>> {
                    let res = &*self.content;
                    {
                        let res = res.choice_0().map(|res| res);
                        res
                    }
                }
            }
            #[allow(unused_imports)]
            use pest3_core::typed::SubRule as _;
            ::pest3_core::full_rule_struct!(
                r#ascii_hex_digit,
                (),
                super::Rule,
                super::Rule::r#ascii_hex_digit,
                super::super::super::generics::Choice7::<
                    r#ascii_digit::<'i>,
                    super::super::super::generics::Str::<super::super::super::wrapper::W0>,
                    super::super::super::generics::Str::<super::super::super::wrapper::W1>,
                    super::super::super::generics::Str::<super::super::super::wrapper::W2>,
                    super::super::super::generics::Str::<super::super::super::wrapper::W3>,
                    super::super::super::generics::Str::<super::super::super::wrapper::W4>,
                    super::super::super::generics::Str::<super::super::super::wrapper::W5>,
                >,
                ::pest3_core::std::Box<
                    super::super::super::generics::Choice7::<
                        r#ascii_digit::<'i>,
                        super::super::super::generics::Str::<super::super::super::wrapper::W0>,
                        super::super::super::generics::Str::<super::super::super::wrapper::W1>,
                        super::super::super::generics::Str::<super::super::super::wrapper::W2>,
                        super::super::super::generics::Str::<super::super::super::wrapper::W3>,
                        super::super::super::generics::Str::<super::super::super::wrapper::W4>,
                        super::super::super::generics::Str::<super::super::super::wrapper::W5>,
                    >,
                >,
            );
            #[allow(unused_imports)]
            use pest3_core::typed::SubRule as _;
            ::pest3_core::full_rule_struct!(
                r#ascii_hex_digit,
                (),
                super::super::super::Rule,
                super::Rule::r#ascii_hex_digit.cvt_into(),
                super::super::super::generics::Choice7::<
                    r#ascii_digit::<'i>,
                    super::super::super::generics::Str::<super::super::super::wrapper::W0>,
                    super::super::super::generics::Str::<super::super::super::wrapper::W1>,
                    super::super::super::generics::Str::<super::super::super::wrapper::W2>,
                    super::super::super::generics::Str::<super::super::super::wrapper::W3>,
                    super::super::super::generics::Str::<super::super::super::wrapper::W4>,
                    super::super::super::generics::Str::<super::super::super::wrapper::W5>,
                >,
                ::pest3_core::std::Box<
                    super::super::super::generics::Choice7::<
                        r#ascii_digit::<'i>,
                        super::super::super::generics::Str::<super::super::super::wrapper::W0>,
                        super::super::super::generics::Str::<super::super::super::wrapper::W1>,
                        super::super::super::generics::Str::<super::super::super::wrapper::W2>,
                        super::super::super::generics::Str::<super::super::super::wrapper::W3>,
                        super::super::super::generics::Str::<super::super::super::wrapper::W4>,
                        super::super::super::generics::Str::<super::super::super::wrapper::W5>,
                    >,
                >,
            );
            #[allow(non_camel_case_types)]
            impl<'i> ::pest3_core::typed::PairContainer<super::Rule> for r#ascii_hex_digit<'i> {
                fn for_each_child_pair(
                    &self,
                    f: &mut impl ::pest3_core::std::FnMut(::pest3_core::token::Pair<super::Rule>),
                ) {
                    self.content.for_self_or_for_each_child_pair(f)
                }
                fn for_self_or_for_each_child_pair(
                    &self,
                    f: &mut impl ::pest3_core::std::FnMut(::pest3_core::token::Pair<super::Rule>),
                ) {
                    use pest3_core::typed::PairTree;
                    f(self.as_pair_tree())
                }
            }
            #[allow(non_camel_case_types)]
            impl<'i> ::pest3_core::typed::PairTree<super::Rule> for r#ascii_hex_digit<'i> {
                fn get_rule() -> super::Rule {
                    #[allow(unused_imports)]
                    use pest3_core::typed::SubRule as _;
                    super::Rule::r#ascii_hex_digit
                }
                fn get_span(&self) -> (::pest3_core::std::usize, ::pest3_core::std::usize) {
                    (self.span.start(), self.span.end())
                }
            }
            #[allow(non_camel_case_types)]
            impl<'i> ::pest3_core::typed::PairContainer<super::super::super::Rule> for r#ascii_hex_digit<'i> {
                fn for_each_child_pair(
                    &self,
                    f: &mut impl ::pest3_core::std::FnMut(
                        ::pest3_core::token::Pair<super::super::super::Rule>,
                    ),
                ) {
                    self.content.for_self_or_for_each_child_pair(f)
                }
                fn for_self_or_for_each_child_pair(
                    &self,
                    f: &mut impl ::pest3_core::std::FnMut(
                        ::pest3_core::token::Pair<super::super::super::Rule>,
                    ),
                ) {
                    use pest3_core::typed::PairTree;
                    f(self.as_pair_tree())
                }
            }
            #[allow(non_camel_case_types)]
            impl<'i> ::pest3_core::typed::PairTree<super::super::super::Rule> for r#ascii_hex_digit<'i> {
                fn get_rule() -> super::super::super::Rule {
                    #[allow(unused_imports)]
                    use pest3_core::typed::SubRule as _;
                    super::Rule::r#ascii_hex_digit.cvt_into()
                }
                fn get_span(&self) -> (::pest3_core::std::usize, ::pest3_core::std::usize) {
                    (self.span.start(), self.span.end())
                }
            }
            #[doc = "Generated for rule `ascii_digit`. Grammar: `(\"0\" | (\"1\" | (\"2\" | (\"3\" | (\"4\" | (\"5\" | (\"6\" | (\"7\" | (\"8\" | \"9\")))))))))`."]
            #[derive(Clone, Debug, Eq, PartialEq)]
            #[allow(non_camel_case_types)]
            pub struct r#ascii_digit<'i> {
                #[doc = r" Matched structure."]
                pub content: ::pest3_core::std::Box<
                    super::super::super::generics::Choice10<
                        super::super::super::generics::Str<super::super::super::wrapper::W6>,
                        super::super::super::generics::Str<super::super::super::wrapper::W7>,
                        super::super::super::generics::Str<super::super::super::wrapper::W8>,
                        super::super::super::generics::Str<super::super::super::wrapper::W9>,
                        super::super::super::generics::Str<super::super::super::wrapper::W10>,
                        super::super::super::generics::Str<super::super::super::wrapper::W11>,
                        super::super::super::generics::Str<super::super::super::wrapper::W12>,
                        super::super::super::generics::Str<super::super::super::wrapper::W13>,
                        super::super::super::generics::Str<super::super::super::wrapper::W14>,
                        super::super::super::generics::Str<super::super::super::wrapper::W15>,
                    >,
                >,
                #[doc = r" Matched span."]
                pub span: ::pest3_core::Span<'i>,
            }
            #[allow(non_camel_case_types)]
            impl<'i> ::pest3_core::typed::wrapper::Rule for r#ascii_digit<'i> {
                type Rule = super::Rule;
                const RULE: super::Rule = super::Rule::r#ascii_digit;
            }
            #[allow(non_camel_case_types)]
            impl<'i> r#ascii_digit<'i> {}
            #[allow(unused_imports)]
            use pest3_core::typed::SubRule as _;
            ::pest3_core::full_rule_struct!(
                r#ascii_digit,
                (),
                super::Rule,
                super::Rule::r#ascii_digit,
                super::super::super::generics::Choice10::<
                    super::super::super::generics::Str::<super::super::super::wrapper::W6>,
                    super::super::super::generics::Str::<super::super::super::wrapper::W7>,
                    super::super::super::generics::Str::<super::super::super::wrapper::W8>,
                    super::super::super::generics::Str::<super::super::super::wrapper::W9>,
                    super::super::super::generics::Str::<super::super::super::wrapper::W10>,
                    super::super::super::generics::Str::<super::super::super::wrapper::W11>,
                    super::super::super::generics::Str::<super::super::super::wrapper::W12>,
                    super::super::super::generics::Str::<super::super::super::wrapper::W13>,
                    super::super::super::generics::Str::<super::super::super::wrapper::W14>,
                    super::super::super::generics::Str::<super::super::super::wrapper::W15>,
                >,
                ::pest3_core::std::Box<
                    super::super::super::generics::Choice10::<
                        super::super::super::generics::Str::<super::super::super::wrapper::W6>,
                        super::super::super::generics::Str::<super::super::super::wrapper::W7>,
                        super::super::super::generics::Str::<super::super::super::wrapper::W8>,
                        super::super::super::generics::Str::<super::super::super::wrapper::W9>,
                        super::super::super::generics::Str::<super::super::super::wrapper::W10>,
                        super::super::super::generics::Str::<super::super::super::wrapper::W11>,
                        super::super::super::generics::Str::<super::super::super::wrapper::W12>,
                        super::super::super::generics::Str::<super::super::super::wrapper::W13>,
                        super::super::super::generics::Str::<super::super::super::wrapper::W14>,
                        super::super::super::generics::Str::<super::super::super::wrapper::W15>,
                    >,
                >,
            );
            #[allow(unused_imports)]
            use pest3_core::typed::SubRule as _;
            ::pest3_core::full_rule_struct!(
                r#ascii_digit,
                (),
                super::super::super::Rule,
                super::Rule::r#ascii_digit.cvt_into(),
                super::super::super::generics::Choice10::<
                    super::super::super::generics::Str::<super::super::super::wrapper::W6>,
                    super::super::super::generics::Str::<super::super::super::wrapper::W7>,
                    super::super::super::generics::Str::<super::super::super::wrapper::W8>,
                    super::super::super::generics::Str::<super::super::super::wrapper::W9>,
                    super::super::super::generics::Str::<super::super::super::wrapper::W10>,
                    super::super::super::generics::Str::<super::super::super::wrapper::W11>,
                    super::super::super::generics::Str::<super::super::super::wrapper::W12>,
                    super::super::super::generics::Str::<super::super::super::wrapper::W13>,
                    super::super::super::generics::Str::<super::super::super::wrapper::W14>,
                    super::super::super::generics::Str::<super::super::super::wrapper::W15>,
                >,
                ::pest3_core::std::Box<
                    super::super::super::generics::Choice10::<
                        super::super::super::generics::Str::<super::super::super::wrapper::W6>,
                        super::super::super::generics::Str::<super::super::super::wrapper::W7>,
                        super::super::super::generics::Str::<super::super::super::wrapper::W8>,
                        super::super::super::generics::Str::<super::super::super::wrapper::W9>,
                        super::super::super::generics::Str::<super::super::super::wrapper::W10>,
                        super::super::super::generics::Str::<super::super::super::wrapper::W11>,
                        super::super::super::generics::Str::<super::super::super::wrapper::W12>,
                        super::super::super::generics::Str::<super::super::super::wrapper::W13>,
                        super::super::super::generics::Str::<super::super::super::wrapper::W14>,
                        super::super::super::generics::Str::<super::super::super::wrapper::W15>,
                    >,
                >,
            );
            #[allow(non_camel_case_types)]
            impl<'i> ::pest3_core::typed::PairContainer<super::Rule> for r#ascii_digit<'i> {
                fn for_each_child_pair(
                    &self,
                    f: &mut impl ::pest3_core::std::FnMut(::pest3_core::token::Pair<super::Rule>),
                ) {
                    self.content.for_self_or_for_each_child_pair(f)
                }
                fn for_self_or_for_each_child_pair(
                    &self,
                    f: &mut impl ::pest3_core::std::FnMut(::pest3_core::token::Pair<super::Rule>),
                ) {
                    use pest3_core::typed::PairTree;
                    f(self.as_pair_tree())
                }
            }
            #[allow(non_camel_case_types)]
            impl<'i> ::pest3_core::typed::PairTree<super::Rule> for r#ascii_digit<'i> {
                fn get_rule() -> super::Rule {
                    #[allow(unused_imports)]
                    use pest3_core::typed::SubRule as _;
                    super::Rule::r#ascii_digit
                }
                fn get_span(&self) -> (::pest3_core::std::usize, ::pest3_core::std::usize) {
                    (self.span.start(), self.span.end())
                }
            }
            #[allow(non_camel_case_types)]
            impl<'i> ::pest3_core::typed::PairContainer<super::super::super::Rule> for r#ascii_digit<'i> {
                fn for_each_child_pair(
                    &self,
                    f: &mut impl ::pest3_core::std::FnMut(
                        ::pest3_core::token::Pair<super::super::super::Rule>,
                    ),
                ) {
                    self.content.for_self_or_for_each_child_pair(f)
                }
                fn for_self_or_for_each_child_pair(
                    &self,
                    f: &mut impl ::pest3_core::std::FnMut(
                        ::pest3_core::token::Pair<super::super::super::Rule>,
                    ),
                ) {
                    use pest3_core::typed::PairTree;
                    f(self.as_pair_tree())
                }
            }
            #[allow(non_camel_case_types)]
            impl<'i> ::pest3_core::typed::PairTree<super::super::super::Rule> for r#ascii_digit<'i> {
                fn get_rule() -> super::super::super::Rule {
                    #[allow(unused_imports)]
                    use pest3_core::typed::SubRule as _;
                    super::Rule::r#ascii_digit.cvt_into()
                }
                fn get_span(&self) -> (::pest3_core::std::usize, ::pest3_core::std::usize) {
                    (self.span.start(), self.span.end())
                }
            }
            #[doc = "Generated for rule `ascii_nonzero_digit`. Grammar: `(\"1\" | (\"2\" | (\"3\" | (\"4\" | (\"5\" | (\"6\" | (\"7\" | (\"8\" | \"9\"))))))))`."]
            #[derive(Clone, Debug, Eq, PartialEq)]
            #[allow(non_camel_case_types)]
            pub struct r#ascii_nonzero_digit<'i> {
                #[doc = r" Matched structure."]
                pub content: ::pest3_core::std::Box<
                    super::super::super::generics::Choice9<
                        super::super::super::generics::Str<super::super::super::wrapper::W7>,
                        super::super::super::generics::Str<super::super::super::wrapper::W8>,
                        super::super::super::generics::Str<super::super::super::wrapper::W9>,
                        super::super::super::generics::Str<super::super::super::wrapper::W10>,
                        super::super::super::generics::Str<super::super::super::wrapper::W11>,
                        super::super::super::generics::Str<super::super::super::wrapper::W12>,
                        super::super::super::generics::Str<super::super::super::wrapper::W13>,
                        super::super::super::generics::Str<super::super::super::wrapper::W14>,
                        super::super::super::generics::Str<super::super::super::wrapper::W15>,
                    >,
                >,
                #[doc = r" Matched span."]
                pub span: ::pest3_core::Span<'i>,
            }
            #[allow(non_camel_case_types)]
            impl<'i> ::pest3_core::typed::wrapper::Rule for r#ascii_nonzero_digit<'i> {
                type Rule = super::Rule;
                const RULE: super::Rule = super::Rule::r#ascii_nonzero_digit;
            }
            #[allow(non_camel_case_types)]
            impl<'i> r#ascii_nonzero_digit<'i> {}
            #[allow(unused_imports)]
            use pest3_core::typed::SubRule as _;
            ::pest3_core::full_rule_struct!(
                r#ascii_nonzero_digit,
                (),
                super::Rule,
                super::Rule::r#ascii_nonzero_digit,
                super::super::super::generics::Choice9::<
                    super::super::super::generics::Str::<super::super::super::wrapper::W7>,
                    super::super::super::generics::Str::<super::super::super::wrapper::W8>,
                    super::super::super::generics::Str::<super::super::super::wrapper::W9>,
                    super::super::super::generics::Str::<super::super::super::wrapper::W10>,
                    super::super::super::generics::Str::<super::super::super::wrapper::W11>,
                    super::super::super::generics::Str::<super::super::super::wrapper::W12>,
                    super::super::super::generics::Str::<super::super::super::wrapper::W13>,
                    super::super::super::generics::Str::<super::super::super::wrapper::W14>,
                    super::super::super::generics::Str::<super::super::super::wrapper::W15>,
                >,
                ::pest3_core::std::Box<
                    super::super::super::generics::Choice9::<
                        super::super::super::generics::Str::<super::super::super::wrapper::W7>,
                        super::super::super::generics::Str::<super::super::super::wrapper::W8>,
                        super::super::super::generics::Str::<super::super::super::wrapper::W9>,
                        super::super::super::generics::Str::<super::super::super::wrapper::W10>,
                        super::super::super::generics::Str::<super::super::super::wrapper::W11>,
                        super::super::super::generics::Str::<super::super::super::wrapper::W12>,
                        super::super::super::generics::Str::<super::super::super::wrapper::W13>,
                        super::super::super::generics::Str::<super::super::super::wrapper::W14>,
                        super::super::super::generics::Str::<super::super::super::wrapper::W15>,
                    >,
                >,
            );
            #[allow(unused_imports)]
            use pest3_core::typed::SubRule as _;
            ::pest3_core::full_rule_struct!(
                r#ascii_nonzero_digit,
                (),
                super::super::super::Rule,
                super::Rule::r#ascii_nonzero_digit.cvt_into(),
                super::super::super::generics::Choice9::<
                    super::super::super::generics::Str::<super::super::super::wrapper::W7>,
                    super::super::super::generics::Str::<super::super::super::wrapper::W8>,
                    super::super::super::generics::Str::<super::super::super::wrapper::W9>,
                    super::super::super::generics::Str::<super::super::super::wrapper::W10>,
                    super::super::super::generics::Str::<super::super::super::wrapper::W11>,
                    super::super::super::generics::Str::<super::super::super::wrapper::W12>,
                    super::super::super::generics::Str::<super::super::super::wrapper::W13>,
                    super::super::super::generics::Str::<super::super::super::wrapper::W14>,
                    super::super::super::generics::Str::<super::super::super::wrapper::W15>,
                >,
                ::pest3_core::std::Box<
                    super::super::super::generics::Choice9::<
                        super::super::super::generics::Str::<super::super::super::wrapper::W7>,
                        super::super::super::generics::Str::<super::super::super::wrapper::W8>,
                        super::super::super::generics::Str::<super::super::super::wrapper::W9>,
                        super::super::super::generics::Str::<super::super::super::wrapper::W10>,
                        super::super::super::generics::Str::<super::super::super::wrapper::W11>,
                        super::super::super::generics::Str::<super::super::super::wrapper::W12>,
                        super::super::super::generics::Str::<super::super::super::wrapper::W13>,
                        super::super::super::generics::Str::<super::super::super::wrapper::W14>,
                        super::super::super::generics::Str::<super::super::super::wrapper::W15>,
                    >,
                >,
            );
            #[allow(non_camel_case_types)]
            impl<'i> ::pest3_core::typed::PairContainer<super::Rule> for r#ascii_nonzero_digit<'i> {
                fn for_each_child_pair(
                    &self,
                    f: &mut impl ::pest3_core::std::FnMut(::pest3_core::token::Pair<super::Rule>),
                ) {
                    self.content.for_self_or_for_each_child_pair(f)
                }
                fn for_self_or_for_each_child_pair(
                    &self,
                    f: &mut impl ::pest3_core::std::FnMut(::pest3_core::token::Pair<super::Rule>),
                ) {
                    use pest3_core::typed::PairTree;
                    f(self.as_pair_tree())
                }
            }
            #[allow(non_camel_case_types)]
            impl<'i> ::pest3_core::typed::PairTree<super::Rule> for r#ascii_nonzero_digit<'i> {
                fn get_rule() -> super::Rule {
                    #[allow(unused_imports)]
                    use pest3_core::typed::SubRule as _;
                    super::Rule::r#ascii_nonzero_digit
                }
                fn get_span(&self) -> (::pest3_core::std::usize, ::pest3_core::std::usize) {
                    (self.span.start(), self.span.end())
                }
            }
            #[allow(non_camel_case_types)]
            impl<'i> ::pest3_core::typed::PairContainer<super::super::super::Rule>
                for r#ascii_nonzero_digit<'i>
            {
                fn for_each_child_pair(
                    &self,
                    f: &mut impl ::pest3_core::std::FnMut(
                        ::pest3_core::token::Pair<super::super::super::Rule>,
                    ),
                ) {
                    self.content.for_self_or_for_each_child_pair(f)
                }
                fn for_self_or_for_each_child_pair(
                    &self,
                    f: &mut impl ::pest3_core::std::FnMut(
                        ::pest3_core::token::Pair<super::super::super::Rule>,
                    ),
                ) {
                    use pest3_core::typed::PairTree;
                    f(self.as_pair_tree())
                }
            }
            #[allow(non_camel_case_types)]
            impl<'i> ::pest3_core::typed::PairTree<super::super::super::Rule> for r#ascii_nonzero_digit<'i> {
                fn get_rule() -> super::super::super::Rule {
                    #[allow(unused_imports)]
                    use pest3_core::typed::SubRule as _;
                    super::Rule::r#ascii_nonzero_digit.cvt_into()
                }
                fn get_span(&self) -> (::pest3_core::std::usize, ::pest3_core::std::usize) {
                    (self.span.start(), self.span.end())
                }
            }
            #[doc = "Generated for rule `whitespaces`. Grammar: `(\" \" | (\"\\t\" | pest::newline))`."]
            #[derive(Clone, Debug, Eq, PartialEq)]
            #[allow(non_camel_case_types)]
            pub struct r#whitespaces<'i> {
                #[doc = r" Matched structure."]
                pub content: ::pest3_core::std::Box<
                    super::super::super::generics::Choice3<
                        super::super::super::generics::Str<super::super::super::wrapper::W16>,
                        super::super::super::generics::Str<super::super::super::wrapper::W17>,
                        super::super::super::generics::r#newline,
                    >,
                >,
                #[doc = r" Matched span."]
                pub span: ::pest3_core::Span<'i>,
            }
            #[allow(non_camel_case_types)]
            impl<'i> ::pest3_core::typed::wrapper::Rule for r#whitespaces<'i> {
                type Rule = super::Rule;
                const RULE: super::Rule = super::Rule::r#whitespaces;
            }
            #[allow(non_camel_case_types)]
            impl<'i> r#whitespaces<'i> {
                #[doc = "A helper function to access [`newline`]."]
                #[allow(non_snake_case)]
                pub fn r#newline<'s>(
                    &'s self,
                ) -> ::pest3_core::std::Option<&'s super::super::super::generics::r#newline>
                {
                    let res = &*self.content;
                    {
                        let res = res.choice_2().map(|res| res);
                        res
                    }
                }
            }
            #[allow(unused_imports)]
            use pest3_core::typed::SubRule as _;
            ::pest3_core::full_rule_struct!(
                r#whitespaces,
                (),
                super::Rule,
                super::Rule::r#whitespaces,
                super::super::super::generics::Choice3::<
                    super::super::super::generics::Str::<super::super::super::wrapper::W16>,
                    super::super::super::generics::Str::<super::super::super::wrapper::W17>,
                    super::super::super::generics::r#newline,
                >,
                ::pest3_core::std::Box<
                    super::super::super::generics::Choice3::<
                        super::super::super::generics::Str::<super::super::super::wrapper::W16>,
                        super::super::super::generics::Str::<super::super::super::wrapper::W17>,
                        super::super::super::generics::r#newline,
                    >,
                >,
            );
            #[allow(unused_imports)]
            use pest3_core::typed::SubRule as _;
            ::pest3_core::full_rule_struct!(
                r#whitespaces,
                (),
                super::super::super::Rule,
                super::Rule::r#whitespaces.cvt_into(),
                super::super::super::generics::Choice3::<
                    super::super::super::generics::Str::<super::super::super::wrapper::W16>,
                    super::super::super::generics::Str::<super::super::super::wrapper::W17>,
                    super::super::super::generics::r#newline,
                >,
                ::pest3_core::std::Box<
                    super::super::super::generics::Choice3::<
                        super::super::super::generics::Str::<super::super::super::wrapper::W16>,
                        super::super::super::generics::Str::<super::super::super::wrapper::W17>,
                        super::super::super::generics::r#newline,
                    >,
                >,
            );
            #[allow(non_camel_case_types)]
            impl<'i> ::pest3_core::typed::PairContainer<super::Rule> for r#whitespaces<'i> {
                fn for_each_child_pair(
                    &self,
                    _f: &mut impl ::pest3_core::std::FnMut(::pest3_core::token::Pair<super::Rule>),
                ) {
                }
                fn for_self_or_for_each_child_pair(
                    &self,
                    _f: &mut impl ::pest3_core::std::FnMut(::pest3_core::token::Pair<super::Rule>),
                ) {
                }
            }
            #[allow(non_camel_case_types)]
            impl<'i> ::pest3_core::typed::PairContainer<super::super::super::Rule> for r#whitespaces<'i> {
                fn for_each_child_pair(
                    &self,
                    _f: &mut impl ::pest3_core::std::FnMut(
                        ::pest3_core::token::Pair<super::super::super::Rule>,
                    ),
                ) {
                }
                fn for_self_or_for_each_child_pair(
                    &self,
                    _f: &mut impl ::pest3_core::std::FnMut(
                        ::pest3_core::token::Pair<super::super::super::Rule>,
                    ),
                ) {
                }
            }
            #[doc = "Generated for rule `int`. Grammar: `((ascii_nonzero_digit - ascii_digit+) | ascii_digit)`."]
            #[derive(Clone, Debug, Eq, PartialEq)]
            #[allow(non_camel_case_types)]
            pub struct r#int<'i> {
                #[doc = r" Matched structure."]
                pub content: ::pest3_core::std::Box<
                    super::super::super::generics::Choice2<
                        super::super::super::generics::Sequence2<
                            r#ascii_nonzero_digit<'i>,
                            ::pest3_core::typed::template::Empty,
                            super::super::super::generics::RepOnce<
                                r#ascii_digit<'i>,
                                ::pest3_core::typed::template::Empty,
                            >,
                            ::pest3_core::typed::template::Empty,
                        >,
                        r#ascii_digit<'i>,
                    >,
                >,
                #[doc = r" Matched span."]
                pub span: ::pest3_core::Span<'i>,
            }
            #[allow(non_camel_case_types)]
            impl<'i> ::pest3_core::typed::wrapper::Rule for r#int<'i> {
                type Rule = super::Rule;
                const RULE: super::Rule = super::Rule::r#int;
            }
            #[allow(non_camel_case_types)]
            impl<'i> r#int<'i> {
                #[doc = "A helper function to access [`ascii_digit`]."]
                #[allow(non_snake_case)]
                pub fn r#ascii_digit<'s>(
                    &'s self,
                ) -> (
                    ::pest3_core::std::Option<::pest3_core::std::Vec<&'s r#ascii_digit<'i>>>,
                    ::pest3_core::std::Option<&'s r#ascii_digit<'i>>,
                ) {
                    let res = &*self.content;
                    {
                        let res = (
                            {
                                let res = res.choice_0().map(|res| {
                                    let res = &res.field_1;
                                    {
                                        let res = res
                                            .content
                                            .iter()
                                            .map(|res| res)
                                            .collect::<::pest3_core::std::Vec<_>>();
                                        res
                                    }
                                });
                                res
                            },
                            {
                                let res = res.choice_1().map(|res| res);
                                res
                            },
                        );
                        res
                    }
                }
                #[doc = "A helper function to access [`ascii_nonzero_digit`]."]
                #[allow(non_snake_case)]
                pub fn r#ascii_nonzero_digit<'s>(
                    &'s self,
                ) -> ::pest3_core::std::Option<&'s r#ascii_nonzero_digit<'i>> {
                    let res = &*self.content;
                    {
                        let res = res.choice_0().map(|res| {
                            let res = &res.field_0;
                            res
                        });
                        res
                    }
                }
            }
            #[allow(unused_imports)]
            use pest3_core::typed::SubRule as _;
            ::pest3_core::full_rule_struct!(
                r#int,
                (),
                super::Rule,
                super::Rule::r#int,
                super::super::super::generics::Choice2::<
                    super::super::super::generics::Sequence2::<
                        r#ascii_nonzero_digit::<'i>,
                        ::pest3_core::typed::template::Empty,
                        super::super::super::generics::RepOnce::<
                            r#ascii_digit::<'i>,
                            ::pest3_core::typed::template::Empty,
                        >,
                        ::pest3_core::typed::template::Empty,
                    >,
                    r#ascii_digit::<'i>,
                >,
                ::pest3_core::std::Box<
                    super::super::super::generics::Choice2::<
                        super::super::super::generics::Sequence2::<
                            r#ascii_nonzero_digit::<'i>,
                            ::pest3_core::typed::template::Empty,
                            super::super::super::generics::RepOnce::<
                                r#ascii_digit::<'i>,
                                ::pest3_core::typed::template::Empty,
                            >,
                            ::pest3_core::typed::template::Empty,
                        >,
                        r#ascii_digit::<'i>,
                    >,
                >,
            );
            #[allow(unused_imports)]
            use pest3_core::typed::SubRule as _;
            ::pest3_core::full_rule_struct!(
                r#int,
                (),
                super::super::super::Rule,
                super::Rule::r#int.cvt_into(),
                super::super::super::generics::Choice2::<
                    super::super::super::generics::Sequence2::<
                        r#ascii_nonzero_digit::<'i>,
                        ::pest3_core::typed::template::Empty,
                        super::super::super::generics::RepOnce::<
                            r#ascii_digit::<'i>,
                            ::pest3_core::typed::template::Empty,
                        >,
                        ::pest3_core::typed::template::Empty,
                    >,
                    r#ascii_digit::<'i>,
                >,
                ::pest3_core::std::Box<
                    super::super::super::generics::Choice2::<
                        super::super::super::generics::Sequence2::<
                            r#ascii_nonzero_digit::<'i>,
                            ::pest3_core::typed::template::Empty,
                            super::super::super::generics::RepOnce::<
                                r#ascii_digit::<'i>,
                                ::pest3_core::typed::template::Empty,
                            >,
                            ::pest3_core::typed::template::Empty,
                        >,
                        r#ascii_digit::<'i>,
                    >,
                >,
            );
            #[allow(non_camel_case_types)]
            impl<'i> ::pest3_core::typed::PairContainer<super::Rule> for r#int<'i> {
                fn for_each_child_pair(
                    &self,
                    f: &mut impl ::pest3_core::std::FnMut(::pest3_core::token::Pair<super::Rule>),
                ) {
                    self.content.for_self_or_for_each_child_pair(f)
                }
                fn for_self_or_for_each_child_pair(
                    &self,
                    f: &mut impl ::pest3_core::std::FnMut(::pest3_core::token::Pair<super::Rule>),
                ) {
                    use pest3_core::typed::PairTree;
                    f(self.as_pair_tree())
                }
            }
            #[allow(non_camel_case_types)]
            impl<'i> ::pest3_core::typed::PairTree<super::Rule> for r#int<'i> {
                fn get_rule() -> super::Rule {
                    #[allow(unused_imports)]
                    use pest3_core::typed::SubRule as _;
                    super::Rule::r#int
                }
                fn get_span(&self) -> (::pest3_core::std::usize, ::pest3_core::std::usize) {
                    (self.span.start(), self.span.end())
                }
            }
            #[allow(non_camel_case_types)]
            impl<'i> ::pest3_core::typed::PairContainer<super::super::super::Rule> for r#int<'i> {
                fn for_each_child_pair(
                    &self,
                    f: &mut impl ::pest3_core::std::FnMut(
                        ::pest3_core::token::Pair<super::super::super::Rule>,
                    ),
                ) {
                    self.content.for_self_or_for_each_child_pair(f)
                }
                fn for_self_or_for_each_child_pair(
                    &self,
                    f: &mut impl ::pest3_core::std::FnMut(
                        ::pest3_core::token::Pair<super::super::super::Rule>,
                    ),
                ) {
                    use pest3_core::typed::PairTree;
                    f(self.as_pair_tree())
                }
            }
            #[allow(non_camel_case_types)]
            impl<'i> ::pest3_core::typed::PairTree<super::super::super::Rule> for r#int<'i> {
                fn get_rule() -> super::super::super::Rule {
                    #[allow(unused_imports)]
                    use pest3_core::typed::SubRule as _;
                    super::Rule::r#int.cvt_into()
                }
                fn get_span(&self) -> (::pest3_core::std::usize, ::pest3_core::std::usize) {
                    (self.span.start(), self.span.end())
                }
            }
        }
    }
    impl ::pest3_core::typed::SubRule for p::Rule {
        type Super = super::Rule;
        fn cvt_into(self) -> Self::Super {
            super::Rule::p(self)
        }
    }
    #[doc = "Generated for rule `json`. Grammar: `(pest::SOI ~ (value ~ pest::EOI))`."]
    #[derive(Clone, Debug, Eq, PartialEq)]
    #[allow(non_camel_case_types)]
    pub struct r#json<'i> {
        #[doc = r" Matched structure."]
        pub content: ::pest3_core::std::Box<
            super::generics::Sequence3<
                super::generics::r#SOI,
                ::pest3_core::typed::template::Empty,
                r#value<'i>,
                __OptionalTrivia<'i>,
                super::generics::r#EOI,
                __OptionalTrivia<'i>,
            >,
        >,
        #[doc = r" Matched span."]
        pub span: ::pest3_core::Span<'i>,
    }
    #[allow(non_camel_case_types)]
    impl<'i> ::pest3_core::typed::wrapper::Rule for r#json<'i> {
        type Rule = super::Rule;
        const RULE: super::Rule = super::Rule::r#json;
    }
    #[allow(non_camel_case_types)]
    impl<'i> r#json<'i> {
        #[doc = "A helper function to access [`EOI`]."]
        #[allow(non_snake_case)]
        pub fn r#EOI<'s>(&'s self) -> &'s super::generics::r#EOI {
            let res = &*self.content;
            {
                let res = &res.field_2;
                res
            }
        }
        #[doc = "A helper function to access [`SOI`]."]
        #[allow(non_snake_case)]
        pub fn r#SOI<'s>(&'s self) -> &'s super::generics::r#SOI {
            let res = &*self.content;
            {
                let res = &res.field_0;
                res
            }
        }
        #[doc = "A helper function to access [`value`]."]
        #[allow(non_snake_case)]
        pub fn r#value<'s>(&'s self) -> &'s r#value<'i> {
            let res = &*self.content;
            {
                let res = &res.field_1;
                res
            }
        }
    }
    #[allow(unused_imports)]
    use pest3_core::typed::SubRule as _;
    ::pest3_core::full_rule_struct!(
        r#json,
        (),
        super::Rule,
        super::Rule::r#json,
        super::generics::Sequence3::<
            super::generics::r#SOI,
            ::pest3_core::typed::template::Empty,
            r#value::<'i>,
            __OptionalTrivia::<'i>,
            super::generics::r#EOI,
            __OptionalTrivia::<'i>,
        >,
        ::pest3_core::std::Box<
            super::generics::Sequence3::<
                super::generics::r#SOI,
                ::pest3_core::typed::template::Empty,
                r#value::<'i>,
                __OptionalTrivia::<'i>,
                super::generics::r#EOI,
                __OptionalTrivia::<'i>,
            >,
        >,
    );
    #[allow(non_camel_case_types)]
    impl<'i> ::pest3_core::typed::PairContainer<super::Rule> for r#json<'i> {
        fn for_each_child_pair(
            &self,
            f: &mut impl ::pest3_core::std::FnMut(::pest3_core::token::Pair<super::Rule>),
        ) {
            self.content.for_self_or_for_each_child_pair(f)
        }
        fn for_self_or_for_each_child_pair(
            &self,
            f: &mut impl ::pest3_core::std::FnMut(::pest3_core::token::Pair<super::Rule>),
        ) {
            use pest3_core::typed::PairTree;
            f(self.as_pair_tree())
        }
    }
    #[allow(non_camel_case_types)]
    impl<'i> ::pest3_core::typed::PairTree<super::Rule> for r#json<'i> {
        fn get_rule() -> super::Rule {
            #[allow(unused_imports)]
            use pest3_core::typed::SubRule as _;
            super::Rule::r#json
        }
        fn get_span(&self) -> (::pest3_core::std::usize, ::pest3_core::std::usize) {
            (self.span.start(), self.span.end())
        }
    }
    #[doc = "Generated for rule `object`. Grammar: `(\"{\" ~ (pair^* ~ \"}\"))`."]
    #[derive(Clone, Debug, Eq, PartialEq)]
    #[allow(non_camel_case_types)]
    pub struct r#object<'i> {
        #[doc = r" Matched structure."]
        pub content: ::pest3_core::std::Box<
            super::generics::Sequence3<
                super::generics::Str<super::wrapper::W18>,
                ::pest3_core::typed::template::Empty,
                super::generics::Rep<r#pair<'i>, __MandatoryTrivia<'i>>,
                __OptionalTrivia<'i>,
                super::generics::Str<super::wrapper::W19>,
                __OptionalTrivia<'i>,
            >,
        >,
        #[doc = r" Matched span."]
        pub span: ::pest3_core::Span<'i>,
    }
    #[allow(non_camel_case_types)]
    impl<'i> ::pest3_core::typed::wrapper::Rule for r#object<'i> {
        type Rule = super::Rule;
        const RULE: super::Rule = super::Rule::r#object;
    }
    #[allow(non_camel_case_types)]
    impl<'i> r#object<'i> {
        #[doc = "A helper function to access [`pair`]."]
        #[allow(non_snake_case)]
        pub fn r#pair<'s>(&'s self) -> ::pest3_core::std::Vec<&'s r#pair<'i>> {
            let res = &*self.content;
            {
                let res = &res.field_1;
                {
                    let res = res
                        .content
                        .iter()
                        .map(|res| res)
                        .collect::<::pest3_core::std::Vec<_>>();
                    res
                }
            }
        }
    }
    #[allow(unused_imports)]
    use pest3_core::typed::SubRule as _;
    ::pest3_core::full_rule_struct!(
        r#object,
        (),
        super::Rule,
        super::Rule::r#object,
        super::generics::Sequence3::<
            super::generics::Str::<super::wrapper::W18>,
            ::pest3_core::typed::template::Empty,
            super::generics::Rep::<r#pair::<'i>, __MandatoryTrivia::<'i>>,
            __OptionalTrivia::<'i>,
            super::generics::Str::<super::wrapper::W19>,
            __OptionalTrivia::<'i>,
        >,
        ::pest3_core::std::Box<
            super::generics::Sequence3::<
                super::generics::Str::<super::wrapper::W18>,
                ::pest3_core::typed::template::Empty,
                super::generics::Rep::<r#pair::<'i>, __MandatoryTrivia::<'i>>,
                __OptionalTrivia::<'i>,
                super::generics::Str::<super::wrapper::W19>,
                __OptionalTrivia::<'i>,
            >,
        >,
    );
    #[allow(non_camel_case_types)]
    impl<'i> ::pest3_core::typed::PairContainer<super::Rule> for r#object<'i> {
        fn for_each_child_pair(
            &self,
            f: &mut impl ::pest3_core::std::FnMut(::pest3_core::token::Pair<super::Rule>),
        ) {
            self.content.for_self_or_for_each_child_pair(f)
        }
        fn for_self_or_for_each_child_pair(
            &self,
            f: &mut impl ::pest3_core::std::FnMut(::pest3_core::token::Pair<super::Rule>),
        ) {
            use pest3_core::typed::PairTree;
            f(self.as_pair_tree())
        }
    }
    #[allow(non_camel_case_types)]
    impl<'i> ::pest3_core::typed::PairTree<super::Rule> for r#object<'i> {
        fn get_rule() -> super::Rule {
            #[allow(unused_imports)]
            use pest3_core::typed::SubRule as _;
            super::Rule::r#object
        }
        fn get_span(&self) -> (::pest3_core::std::usize, ::pest3_core::std::usize) {
            (self.span.start(), self.span.end())
        }
    }
    #[doc = "Generated for rule `pair`. Grammar: `(string ~ (\":\" ~ value))`."]
    #[derive(Clone, Debug, Eq, PartialEq)]
    #[allow(non_camel_case_types)]
    pub struct r#pair<'i> {
        #[doc = r" Matched structure."]
        pub content: ::pest3_core::std::Box<
            super::generics::Sequence3<
                r#string<'i>,
                ::pest3_core::typed::template::Empty,
                super::generics::Str<super::wrapper::W20>,
                __OptionalTrivia<'i>,
                r#value<'i>,
                __OptionalTrivia<'i>,
            >,
        >,
        #[doc = r" Matched span."]
        pub span: ::pest3_core::Span<'i>,
    }
    #[allow(non_camel_case_types)]
    impl<'i> ::pest3_core::typed::wrapper::Rule for r#pair<'i> {
        type Rule = super::Rule;
        const RULE: super::Rule = super::Rule::r#pair;
    }
    #[allow(non_camel_case_types)]
    impl<'i> r#pair<'i> {
        #[doc = "A helper function to access [`string`]."]
        #[allow(non_snake_case)]
        pub fn r#string<'s>(&'s self) -> &'s r#string<'i> {
            let res = &*self.content;
            {
                let res = &res.field_0;
                res
            }
        }
        #[doc = "A helper function to access [`value`]."]
        #[allow(non_snake_case)]
        pub fn r#value<'s>(&'s self) -> &'s r#value<'i> {
            let res = &*self.content;
            {
                let res = &res.field_2;
                res
            }
        }
    }
    #[allow(unused_imports)]
    use pest3_core::typed::SubRule as _;
    ::pest3_core::full_rule_struct!(
        r#pair,
        (),
        super::Rule,
        super::Rule::r#pair,
        super::generics::Sequence3::<
            r#string::<'i>,
            ::pest3_core::typed::template::Empty,
            super::generics::Str::<super::wrapper::W20>,
            __OptionalTrivia::<'i>,
            r#value::<'i>,
            __OptionalTrivia::<'i>,
        >,
        ::pest3_core::std::Box<
            super::generics::Sequence3::<
                r#string::<'i>,
                ::pest3_core::typed::template::Empty,
                super::generics::Str::<super::wrapper::W20>,
                __OptionalTrivia::<'i>,
                r#value::<'i>,
                __OptionalTrivia::<'i>,
            >,
        >,
    );
    #[allow(non_camel_case_types)]
    impl<'i> ::pest3_core::typed::PairContainer<super::Rule> for r#pair<'i> {
        fn for_each_child_pair(
            &self,
            f: &mut impl ::pest3_core::std::FnMut(::pest3_core::token::Pair<super::Rule>),
        ) {
            self.content.for_self_or_for_each_child_pair(f)
        }
        fn for_self_or_for_each_child_pair(
            &self,
            f: &mut impl ::pest3_core::std::FnMut(::pest3_core::token::Pair<super::Rule>),
        ) {
            use pest3_core::typed::PairTree;
            f(self.as_pair_tree())
        }
    }
    #[allow(non_camel_case_types)]
    impl<'i> ::pest3_core::typed::PairTree<super::Rule> for r#pair<'i> {
        fn get_rule() -> super::Rule {
            #[allow(unused_imports)]
            use pest3_core::typed::SubRule as _;
            super::Rule::r#pair
        }
        fn get_span(&self) -> (::pest3_core::std::usize, ::pest3_core::std::usize) {
            (self.span.start(), self.span.end())
        }
    }
    #[doc = "Generated for rule `array`. Grammar: `((\"[\" ~ (value ~ ((\",\" ~ value)* ~ \"]\"))) | (\"[\" ~ \"]\"))`."]
    #[derive(Clone, Debug, Eq, PartialEq)]
    #[allow(non_camel_case_types)]
    pub struct r#array<'i> {
        #[doc = r" Matched structure."]
        pub content: ::pest3_core::std::Box<
            super::generics::Choice2<
                super::generics::Sequence4<
                    super::generics::Str<super::wrapper::W21>,
                    ::pest3_core::typed::template::Empty,
                    r#value<'i>,
                    __OptionalTrivia<'i>,
                    super::generics::Rep<
                        super::generics::Sequence2<
                            super::generics::Str<super::wrapper::W22>,
                            ::pest3_core::typed::template::Empty,
                            r#value<'i>,
                            __OptionalTrivia<'i>,
                        >,
                        ::pest3_core::typed::template::Empty,
                    >,
                    __OptionalTrivia<'i>,
                    super::generics::Str<super::wrapper::W23>,
                    __OptionalTrivia<'i>,
                >,
                super::generics::Sequence2<
                    super::generics::Str<super::wrapper::W21>,
                    ::pest3_core::typed::template::Empty,
                    super::generics::Str<super::wrapper::W23>,
                    __OptionalTrivia<'i>,
                >,
            >,
        >,
        #[doc = r" Matched span."]
        pub span: ::pest3_core::Span<'i>,
    }
    #[allow(non_camel_case_types)]
    impl<'i> ::pest3_core::typed::wrapper::Rule for r#array<'i> {
        type Rule = super::Rule;
        const RULE: super::Rule = super::Rule::r#array;
    }
    #[allow(non_camel_case_types)]
    impl<'i> r#array<'i> {
        #[doc = "A helper function to access [`value`]."]
        #[allow(non_snake_case)]
        pub fn r#value<'s>(
            &'s self,
        ) -> ::pest3_core::std::Option<(&'s r#value<'i>, ::pest3_core::std::Vec<&'s r#value<'i>>)>
        {
            let res = &*self.content;
            {
                let res = res.choice_0().map(|res| {
                    let res = (
                        {
                            let res = &res.field_1;
                            res
                        },
                        {
                            let res = &res.field_2;
                            {
                                let res = res
                                    .content
                                    .iter()
                                    .map(|res| {
                                        let res = &res.field_1;
                                        res
                                    })
                                    .collect::<::pest3_core::std::Vec<_>>();
                                res
                            }
                        },
                    );
                    res
                });
                res
            }
        }
    }
    #[allow(unused_imports)]
    use pest3_core::typed::SubRule as _;
    ::pest3_core::full_rule_struct!(
        r#array,
        (),
        super::Rule,
        super::Rule::r#array,
        super::generics::Choice2::<
            super::generics::Sequence4::<
                super::generics::Str::<super::wrapper::W21>,
                ::pest3_core::typed::template::Empty,
                r#value::<'i>,
                __OptionalTrivia::<'i>,
                super::generics::Rep::<
                    super::generics::Sequence2::<
                        super::generics::Str::<super::wrapper::W22>,
                        ::pest3_core::typed::template::Empty,
                        r#value::<'i>,
                        __OptionalTrivia::<'i>,
                    >,
                    ::pest3_core::typed::template::Empty,
                >,
                __OptionalTrivia::<'i>,
                super::generics::Str::<super::wrapper::W23>,
                __OptionalTrivia::<'i>,
            >,
            super::generics::Sequence2::<
                super::generics::Str::<super::wrapper::W21>,
                ::pest3_core::typed::template::Empty,
                super::generics::Str::<super::wrapper::W23>,
                __OptionalTrivia::<'i>,
            >,
        >,
        ::pest3_core::std::Box<
            super::generics::Choice2::<
                super::generics::Sequence4::<
                    super::generics::Str::<super::wrapper::W21>,
                    ::pest3_core::typed::template::Empty,
                    r#value::<'i>,
                    __OptionalTrivia::<'i>,
                    super::generics::Rep::<
                        super::generics::Sequence2::<
                            super::generics::Str::<super::wrapper::W22>,
                            ::pest3_core::typed::template::Empty,
                            r#value::<'i>,
                            __OptionalTrivia::<'i>,
                        >,
                        ::pest3_core::typed::template::Empty,
                    >,
                    __OptionalTrivia::<'i>,
                    super::generics::Str::<super::wrapper::W23>,
                    __OptionalTrivia::<'i>,
                >,
                super::generics::Sequence2::<
                    super::generics::Str::<super::wrapper::W21>,
                    ::pest3_core::typed::template::Empty,
                    super::generics::Str::<super::wrapper::W23>,
                    __OptionalTrivia::<'i>,
                >,
            >,
        >,
    );
    #[allow(non_camel_case_types)]
    impl<'i> ::pest3_core::typed::PairContainer<super::Rule> for r#array<'i> {
        fn for_each_child_pair(
            &self,
            f: &mut impl ::pest3_core::std::FnMut(::pest3_core::token::Pair<super::Rule>),
        ) {
            self.content.for_self_or_for_each_child_pair(f)
        }
        fn for_self_or_for_each_child_pair(
            &self,
            f: &mut impl ::pest3_core::std::FnMut(::pest3_core::token::Pair<super::Rule>),
        ) {
            use pest3_core::typed::PairTree;
            f(self.as_pair_tree())
        }
    }
    #[allow(non_camel_case_types)]
    impl<'i> ::pest3_core::typed::PairTree<super::Rule> for r#array<'i> {
        fn get_rule() -> super::Rule {
            #[allow(unused_imports)]
            use pest3_core::typed::SubRule as _;
            super::Rule::r#array
        }
        fn get_span(&self) -> (::pest3_core::std::usize, ::pest3_core::std::usize) {
            (self.span.start(), self.span.end())
        }
    }
    #[doc = "Generated for rule `value`. Grammar: `(string | (number | (object | (array | (bool | null)))))`."]
    #[derive(Clone, Debug, Eq, PartialEq)]
    #[allow(non_camel_case_types)]
    pub struct r#value<'i> {
        #[doc = r" Matched structure."]
        pub content: ::pest3_core::std::Box<
            super::generics::Choice6<
                r#string<'i>,
                r#number<'i>,
                r#object<'i>,
                r#array<'i>,
                r#bool<'i>,
                r#null<'i>,
            >,
        >,
        #[doc = r" Matched span."]
        pub span: ::pest3_core::Span<'i>,
    }
    #[allow(non_camel_case_types)]
    impl<'i> ::pest3_core::typed::wrapper::Rule for r#value<'i> {
        type Rule = super::Rule;
        const RULE: super::Rule = super::Rule::r#value;
    }
    #[allow(non_camel_case_types)]
    impl<'i> r#value<'i> {
        #[doc = "A helper function to access [`array`]."]
        #[allow(non_snake_case)]
        pub fn r#array<'s>(&'s self) -> ::pest3_core::std::Option<&'s r#array<'i>> {
            let res = &*self.content;
            {
                let res = res.choice_3().map(|res| res);
                res
            }
        }
        #[doc = "A helper function to access [`bool`]."]
        #[allow(non_snake_case)]
        pub fn r#bool<'s>(&'s self) -> ::pest3_core::std::Option<&'s r#bool<'i>> {
            let res = &*self.content;
            {
                let res = res.choice_4().map(|res| res);
                res
            }
        }
        #[doc = "A helper function to access [`null`]."]
        #[allow(non_snake_case)]
        pub fn r#null<'s>(&'s self) -> ::pest3_core::std::Option<&'s r#null<'i>> {
            let res = &*self.content;
            {
                let res = res.choice_5().map(|res| res);
                res
            }
        }
        #[doc = "A helper function to access [`number`]."]
        #[allow(non_snake_case)]
        pub fn r#number<'s>(&'s self) -> ::pest3_core::std::Option<&'s r#number<'i>> {
            let res = &*self.content;
            {
                let res = res.choice_1().map(|res| res);
                res
            }
        }
        #[doc = "A helper function to access [`object`]."]
        #[allow(non_snake_case)]
        pub fn r#object<'s>(&'s self) -> ::pest3_core::std::Option<&'s r#object<'i>> {
            let res = &*self.content;
            {
                let res = res.choice_2().map(|res| res);
                res
            }
        }
        #[doc = "A helper function to access [`string`]."]
        #[allow(non_snake_case)]
        pub fn r#string<'s>(&'s self) -> ::pest3_core::std::Option<&'s r#string<'i>> {
            let res = &*self.content;
            {
                let res = res.choice_0().map(|res| res);
                res
            }
        }
    }
    #[allow(unused_imports)]
    use pest3_core::typed::SubRule as _;
    ::pest3_core::full_rule_struct!(
        r#value,
        (),
        super::Rule,
        super::Rule::r#value,
        super::generics::Choice6::<
            r#string::<'i>,
            r#number::<'i>,
            r#object::<'i>,
            r#array::<'i>,
            r#bool::<'i>,
            r#null::<'i>,
        >,
        ::pest3_core::std::Box<
            super::generics::Choice6::<
                r#string::<'i>,
                r#number::<'i>,
                r#object::<'i>,
                r#array::<'i>,
                r#bool::<'i>,
                r#null::<'i>,
            >,
        >,
    );
    #[allow(non_camel_case_types)]
    impl<'i> ::pest3_core::typed::PairContainer<super::Rule> for r#value<'i> {
        fn for_each_child_pair(
            &self,
            f: &mut impl ::pest3_core::std::FnMut(::pest3_core::token::Pair<super::Rule>),
        ) {
            self.content.for_self_or_for_each_child_pair(f)
        }
        fn for_self_or_for_each_child_pair(
            &self,
            f: &mut impl ::pest3_core::std::FnMut(::pest3_core::token::Pair<super::Rule>),
        ) {
            use pest3_core::typed::PairTree;
            f(self.as_pair_tree())
        }
    }
    #[allow(non_camel_case_types)]
    impl<'i> ::pest3_core::typed::PairTree<super::Rule> for r#value<'i> {
        fn get_rule() -> super::Rule {
            #[allow(unused_imports)]
            use pest3_core::typed::SubRule as _;
            super::Rule::r#value
        }
        fn get_span(&self) -> (::pest3_core::std::usize, ::pest3_core::std::usize) {
            (self.span.start(), self.span.end())
        }
    }
    #[doc = "Generated for rule `string`. Grammar: `(\"\\\"\" - (inner - \"\\\"\"))`."]
    #[derive(Clone, Debug, Eq, PartialEq)]
    #[allow(non_camel_case_types)]
    pub struct r#string<'i> {
        #[doc = r" Matched structure."]
        pub content: ::pest3_core::std::Box<
            super::generics::Sequence3<
                super::generics::Str<super::wrapper::W24>,
                ::pest3_core::typed::template::Empty,
                r#inner<'i>,
                ::pest3_core::typed::template::Empty,
                super::generics::Str<super::wrapper::W24>,
                ::pest3_core::typed::template::Empty,
            >,
        >,
        #[doc = r" Matched span."]
        pub span: ::pest3_core::Span<'i>,
    }
    #[allow(non_camel_case_types)]
    impl<'i> ::pest3_core::typed::wrapper::Rule for r#string<'i> {
        type Rule = super::Rule;
        const RULE: super::Rule = super::Rule::r#string;
    }
    #[allow(non_camel_case_types)]
    impl<'i> r#string<'i> {
        #[doc = "A helper function to access [`inner`]."]
        #[allow(non_snake_case)]
        pub fn r#inner<'s>(&'s self) -> &'s r#inner<'i> {
            let res = &*self.content;
            {
                let res = &res.field_1;
                res
            }
        }
    }
    #[allow(unused_imports)]
    use pest3_core::typed::SubRule as _;
    ::pest3_core::full_rule_struct!(
        r#string,
        (),
        super::Rule,
        super::Rule::r#string,
        super::generics::Sequence3::<
            super::generics::Str::<super::wrapper::W24>,
            ::pest3_core::typed::template::Empty,
            r#inner::<'i>,
            ::pest3_core::typed::template::Empty,
            super::generics::Str::<super::wrapper::W24>,
            ::pest3_core::typed::template::Empty,
        >,
        ::pest3_core::std::Box<
            super::generics::Sequence3::<
                super::generics::Str::<super::wrapper::W24>,
                ::pest3_core::typed::template::Empty,
                r#inner::<'i>,
                ::pest3_core::typed::template::Empty,
                super::generics::Str::<super::wrapper::W24>,
                ::pest3_core::typed::template::Empty,
            >,
        >,
    );
    #[allow(non_camel_case_types)]
    impl<'i> ::pest3_core::typed::PairContainer<super::Rule> for r#string<'i> {
        fn for_each_child_pair(
            &self,
            f: &mut impl ::pest3_core::std::FnMut(::pest3_core::token::Pair<super::Rule>),
        ) {
            self.content.for_self_or_for_each_child_pair(f)
        }
        fn for_self_or_for_each_child_pair(
            &self,
            f: &mut impl ::pest3_core::std::FnMut(::pest3_core::token::Pair<super::Rule>),
        ) {
            use pest3_core::typed::PairTree;
            f(self.as_pair_tree())
        }
    }
    #[allow(non_camel_case_types)]
    impl<'i> ::pest3_core::typed::PairTree<super::Rule> for r#string<'i> {
        fn get_rule() -> super::Rule {
            #[allow(unused_imports)]
            use pest3_core::typed::SubRule as _;
            super::Rule::r#string
        }
        fn get_span(&self) -> (::pest3_core::std::usize, ::pest3_core::std::usize) {
            (self.span.start(), self.span.end())
        }
    }
    #[doc = "Generated for rule `inner`. Grammar: `((!(\"\\\"\" | \"\\\\\") - pest::any)* - (escape ~ inner)?)`."]
    #[derive(Clone, Debug, Eq, PartialEq)]
    #[allow(non_camel_case_types)]
    pub struct r#inner<'i> {
        #[doc = r" Matched structure."]
        pub content: ::pest3_core::std::Box<
            super::generics::Sequence2<
                super::generics::Rep<
                    super::generics::Sequence2<
                        super::generics::Negative<
                            super::generics::Choice2<
                                super::generics::Str<super::wrapper::W24>,
                                super::generics::Str<super::wrapper::W25>,
                            >,
                        >,
                        ::pest3_core::typed::template::Empty,
                        super::generics::r#any,
                        ::pest3_core::typed::template::Empty,
                    >,
                    ::pest3_core::typed::template::Empty,
                >,
                ::pest3_core::typed::template::Empty,
                ::pest3_core::std::Option<
                    super::generics::Sequence2<
                        r#escape<'i>,
                        ::pest3_core::typed::template::Empty,
                        r#inner<'i>,
                        __OptionalTrivia<'i>,
                    >,
                >,
                ::pest3_core::typed::template::Empty,
            >,
        >,
        #[doc = r" Matched span."]
        pub span: ::pest3_core::Span<'i>,
    }
    #[allow(non_camel_case_types)]
    impl<'i> ::pest3_core::typed::wrapper::Rule for r#inner<'i> {
        type Rule = super::Rule;
        const RULE: super::Rule = super::Rule::r#inner;
    }
    #[allow(non_camel_case_types)]
    impl<'i> r#inner<'i> {
        #[doc = "A helper function to access [`any`]."]
        #[allow(non_snake_case)]
        pub fn r#any<'s>(&'s self) -> ::pest3_core::std::Vec<&'s super::generics::r#any> {
            let res = &*self.content;
            {
                let res = &res.field_0;
                {
                    let res = res
                        .content
                        .iter()
                        .map(|res| {
                            let res = &res.field_1;
                            res
                        })
                        .collect::<::pest3_core::std::Vec<_>>();
                    res
                }
            }
        }
        #[doc = "A helper function to access [`escape`]."]
        #[allow(non_snake_case)]
        pub fn r#escape<'s>(&'s self) -> ::pest3_core::std::Option<&'s r#escape<'i>> {
            let res = &*self.content;
            {
                let res = &res.field_1;
                {
                    let res = res.as_ref().map(|res| {
                        let res = &res.field_0;
                        res
                    });
                    res
                }
            }
        }
        #[doc = "A helper function to access [`inner`]."]
        #[allow(non_snake_case)]
        pub fn r#inner<'s>(&'s self) -> ::pest3_core::std::Option<&'s r#inner<'i>> {
            let res = &*self.content;
            {
                let res = &res.field_1;
                {
                    let res = res.as_ref().map(|res| {
                        let res = &res.field_1;
                        res
                    });
                    res
                }
            }
        }
    }
    #[allow(unused_imports)]
    use pest3_core::typed::SubRule as _;
    ::pest3_core::full_rule_struct!(
        r#inner,
        (),
        super::Rule,
        super::Rule::r#inner,
        super::generics::Sequence2::<
            super::generics::Rep::<
                super::generics::Sequence2::<
                    super::generics::Negative::<
                        super::generics::Choice2::<
                            super::generics::Str::<super::wrapper::W24>,
                            super::generics::Str::<super::wrapper::W25>,
                        >,
                    >,
                    ::pest3_core::typed::template::Empty,
                    super::generics::r#any,
                    ::pest3_core::typed::template::Empty,
                >,
                ::pest3_core::typed::template::Empty,
            >,
            ::pest3_core::typed::template::Empty,
            ::pest3_core::std::Option::<
                super::generics::Sequence2::<
                    r#escape::<'i>,
                    ::pest3_core::typed::template::Empty,
                    r#inner::<'i>,
                    __OptionalTrivia::<'i>,
                >,
            >,
            ::pest3_core::typed::template::Empty,
        >,
        ::pest3_core::std::Box<
            super::generics::Sequence2::<
                super::generics::Rep::<
                    super::generics::Sequence2::<
                        super::generics::Negative::<
                            super::generics::Choice2::<
                                super::generics::Str::<super::wrapper::W24>,
                                super::generics::Str::<super::wrapper::W25>,
                            >,
                        >,
                        ::pest3_core::typed::template::Empty,
                        super::generics::r#any,
                        ::pest3_core::typed::template::Empty,
                    >,
                    ::pest3_core::typed::template::Empty,
                >,
                ::pest3_core::typed::template::Empty,
                ::pest3_core::std::Option::<
                    super::generics::Sequence2::<
                        r#escape::<'i>,
                        ::pest3_core::typed::template::Empty,
                        r#inner::<'i>,
                        __OptionalTrivia::<'i>,
                    >,
                >,
                ::pest3_core::typed::template::Empty,
            >,
        >,
    );
    #[allow(non_camel_case_types)]
    impl<'i> ::pest3_core::typed::PairContainer<super::Rule> for r#inner<'i> {
        fn for_each_child_pair(
            &self,
            f: &mut impl ::pest3_core::std::FnMut(::pest3_core::token::Pair<super::Rule>),
        ) {
            self.content.for_self_or_for_each_child_pair(f)
        }
        fn for_self_or_for_each_child_pair(
            &self,
            f: &mut impl ::pest3_core::std::FnMut(::pest3_core::token::Pair<super::Rule>),
        ) {
            use pest3_core::typed::PairTree;
            f(self.as_pair_tree())
        }
    }
    #[allow(non_camel_case_types)]
    impl<'i> ::pest3_core::typed::PairTree<super::Rule> for r#inner<'i> {
        fn get_rule() -> super::Rule {
            #[allow(unused_imports)]
            use pest3_core::typed::SubRule as _;
            super::Rule::r#inner
        }
        fn get_span(&self) -> (::pest3_core::std::usize, ::pest3_core::std::usize) {
            (self.span.start(), self.span.end())
        }
    }
    #[doc = "Generated for rule `escape`. Grammar: `(\"\\\\\" - (\"\\\"\" | (\"\\\\\" | (\"/\" | (\"b\" | (\"f\" | (\"n\" | (\"r\" | (\"t\" | unicode)))))))))`."]
    #[derive(Clone, Debug, Eq, PartialEq)]
    #[allow(non_camel_case_types)]
    pub struct r#escape<'i> {
        #[doc = r" Matched structure."]
        pub content: ::pest3_core::std::Box<
            super::generics::Sequence2<
                super::generics::Str<super::wrapper::W25>,
                ::pest3_core::typed::template::Empty,
                super::generics::Choice9<
                    super::generics::Str<super::wrapper::W24>,
                    super::generics::Str<super::wrapper::W25>,
                    super::generics::Str<super::wrapper::W26>,
                    super::generics::Str<super::wrapper::W27>,
                    super::generics::Str<super::wrapper::W28>,
                    super::generics::Str<super::wrapper::W29>,
                    super::generics::Str<super::wrapper::W30>,
                    super::generics::Str<super::wrapper::W31>,
                    r#unicode<'i>,
                >,
                ::pest3_core::typed::template::Empty,
            >,
        >,
        #[doc = r" Matched span."]
        pub span: ::pest3_core::Span<'i>,
    }
    #[allow(non_camel_case_types)]
    impl<'i> ::pest3_core::typed::wrapper::Rule for r#escape<'i> {
        type Rule = super::Rule;
        const RULE: super::Rule = super::Rule::r#escape;
    }
    #[allow(non_camel_case_types)]
    impl<'i> r#escape<'i> {
        #[doc = "A helper function to access [`unicode`]."]
        #[allow(non_snake_case)]
        pub fn r#unicode<'s>(&'s self) -> ::pest3_core::std::Option<&'s r#unicode<'i>> {
            let res = &*self.content;
            {
                let res = &res.field_1;
                {
                    let res = res.choice_8().map(|res| res);
                    res
                }
            }
        }
    }
    #[allow(unused_imports)]
    use pest3_core::typed::SubRule as _;
    ::pest3_core::full_rule_struct!(
        r#escape,
        (),
        super::Rule,
        super::Rule::r#escape,
        super::generics::Sequence2::<
            super::generics::Str::<super::wrapper::W25>,
            ::pest3_core::typed::template::Empty,
            super::generics::Choice9::<
                super::generics::Str::<super::wrapper::W24>,
                super::generics::Str::<super::wrapper::W25>,
                super::generics::Str::<super::wrapper::W26>,
                super::generics::Str::<super::wrapper::W27>,
                super::generics::Str::<super::wrapper::W28>,
                super::generics::Str::<super::wrapper::W29>,
                super::generics::Str::<super::wrapper::W30>,
                super::generics::Str::<super::wrapper::W31>,
                r#unicode::<'i>,
            >,
            ::pest3_core::typed::template::Empty,
        >,
        ::pest3_core::std::Box<
            super::generics::Sequence2::<
                super::generics::Str::<super::wrapper::W25>,
                ::pest3_core::typed::template::Empty,
                super::generics::Choice9::<
                    super::generics::Str::<super::wrapper::W24>,
                    super::generics::Str::<super::wrapper::W25>,
                    super::generics::Str::<super::wrapper::W26>,
                    super::generics::Str::<super::wrapper::W27>,
                    super::generics::Str::<super::wrapper::W28>,
                    super::generics::Str::<super::wrapper::W29>,
                    super::generics::Str::<super::wrapper::W30>,
                    super::generics::Str::<super::wrapper::W31>,
                    r#unicode::<'i>,
                >,
                ::pest3_core::typed::template::Empty,
            >,
        >,
    );
    #[allow(non_camel_case_types)]
    impl<'i> ::pest3_core::typed::PairContainer<super::Rule> for r#escape<'i> {
        fn for_each_child_pair(
            &self,
            f: &mut impl ::pest3_core::std::FnMut(::pest3_core::token::Pair<super::Rule>),
        ) {
            self.content.for_self_or_for_each_child_pair(f)
        }
        fn for_self_or_for_each_child_pair(
            &self,
            f: &mut impl ::pest3_core::std::FnMut(::pest3_core::token::Pair<super::Rule>),
        ) {
            use pest3_core::typed::PairTree;
            f(self.as_pair_tree())
        }
    }
    #[allow(non_camel_case_types)]
    impl<'i> ::pest3_core::typed::PairTree<super::Rule> for r#escape<'i> {
        fn get_rule() -> super::Rule {
            #[allow(unused_imports)]
            use pest3_core::typed::SubRule as _;
            super::Rule::r#escape
        }
        fn get_span(&self) -> (::pest3_core::std::usize, ::pest3_core::std::usize) {
            (self.span.start(), self.span.end())
        }
    }
    #[doc = "Generated for rule `unicode`. Grammar: `(\"u\" - p::ascii_hex_digit[4..4])`."]
    #[derive(Clone, Debug, Eq, PartialEq)]
    #[allow(non_camel_case_types)]
    pub struct r#unicode<'i> {
        #[doc = r" Matched structure."]
        pub content: ::pest3_core::std::Box<
            super::generics::Sequence2<
                super::generics::Str<super::wrapper::W32>,
                ::pest3_core::typed::template::Empty,
                super::generics::RepMinMax<
                    p::rules::r#ascii_hex_digit<'i>,
                    ::pest3_core::typed::template::Empty,
                    4usize,
                    4usize,
                >,
                ::pest3_core::typed::template::Empty,
            >,
        >,
        #[doc = r" Matched span."]
        pub span: ::pest3_core::Span<'i>,
    }
    #[allow(non_camel_case_types)]
    impl<'i> ::pest3_core::typed::wrapper::Rule for r#unicode<'i> {
        type Rule = super::Rule;
        const RULE: super::Rule = super::Rule::r#unicode;
    }
    #[allow(non_camel_case_types)]
    impl<'i> r#unicode<'i> {
        #[doc = "A helper function to access [`ascii_hex_digit`]."]
        #[allow(non_snake_case)]
        pub fn r#ascii_hex_digit<'s>(
            &'s self,
        ) -> ::pest3_core::std::Vec<&'s p::rules::r#ascii_hex_digit<'i>> {
            let res = &*self.content;
            {
                let res = &res.field_1;
                {
                    let res = res
                        .content
                        .iter()
                        .map(|res| res)
                        .collect::<::pest3_core::std::Vec<_>>();
                    res
                }
            }
        }
    }
    #[allow(unused_imports)]
    use pest3_core::typed::SubRule as _;
    ::pest3_core::full_rule_struct!(
        r#unicode,
        (),
        super::Rule,
        super::Rule::r#unicode,
        super::generics::Sequence2::<
            super::generics::Str::<super::wrapper::W32>,
            ::pest3_core::typed::template::Empty,
            super::generics::RepMinMax::<
                p::rules::r#ascii_hex_digit::<'i>,
                ::pest3_core::typed::template::Empty,
                4usize,
                4usize,
            >,
            ::pest3_core::typed::template::Empty,
        >,
        ::pest3_core::std::Box<
            super::generics::Sequence2::<
                super::generics::Str::<super::wrapper::W32>,
                ::pest3_core::typed::template::Empty,
                super::generics::RepMinMax::<
                    p::rules::r#ascii_hex_digit::<'i>,
                    ::pest3_core::typed::template::Empty,
                    4usize,
                    4usize,
                >,
                ::pest3_core::typed::template::Empty,
            >,
        >,
    );
    #[allow(non_camel_case_types)]
    impl<'i> ::pest3_core::typed::PairContainer<super::Rule> for r#unicode<'i> {
        fn for_each_child_pair(
            &self,
            f: &mut impl ::pest3_core::std::FnMut(::pest3_core::token::Pair<super::Rule>),
        ) {
            self.content.for_self_or_for_each_child_pair(f)
        }
        fn for_self_or_for_each_child_pair(
            &self,
            f: &mut impl ::pest3_core::std::FnMut(::pest3_core::token::Pair<super::Rule>),
        ) {
            use pest3_core::typed::PairTree;
            f(self.as_pair_tree())
        }
    }
    #[allow(non_camel_case_types)]
    impl<'i> ::pest3_core::typed::PairTree<super::Rule> for r#unicode<'i> {
        fn get_rule() -> super::Rule {
            #[allow(unused_imports)]
            use pest3_core::typed::SubRule as _;
            super::Rule::r#unicode
        }
        fn get_span(&self) -> (::pest3_core::std::usize, ::pest3_core::std::usize) {
            (self.span.start(), self.span.end())
        }
    }
    #[doc = "Generated for rule `number`. Grammar: `(\"-\"? - (int - ((\".\" ~ (p::ascii_digit+ ~ exp?)) | exp)?))`."]
    #[derive(Clone, Debug, Eq, PartialEq)]
    #[allow(non_camel_case_types)]
    pub struct r#number<'i> {
        #[doc = r" Matched structure."]
        pub content: ::pest3_core::std::Box<
            super::generics::Sequence3<
                ::pest3_core::std::Option<super::generics::Str<super::wrapper::W33>>,
                ::pest3_core::typed::template::Empty,
                r#int<'i>,
                ::pest3_core::typed::template::Empty,
                ::pest3_core::std::Option<
                    super::generics::Choice2<
                        super::generics::Sequence3<
                            super::generics::Str<super::wrapper::W34>,
                            ::pest3_core::typed::template::Empty,
                            super::generics::RepOnce<
                                p::rules::r#ascii_digit<'i>,
                                ::pest3_core::typed::template::Empty,
                            >,
                            __OptionalTrivia<'i>,
                            ::pest3_core::std::Option<r#exp<'i>>,
                            __OptionalTrivia<'i>,
                        >,
                        r#exp<'i>,
                    >,
                >,
                ::pest3_core::typed::template::Empty,
            >,
        >,
        #[doc = r" Matched span."]
        pub span: ::pest3_core::Span<'i>,
    }
    #[allow(non_camel_case_types)]
    impl<'i> ::pest3_core::typed::wrapper::Rule for r#number<'i> {
        type Rule = super::Rule;
        const RULE: super::Rule = super::Rule::r#number;
    }
    #[allow(non_camel_case_types)]
    impl<'i> r#number<'i> {
        #[doc = "A helper function to access [`ascii_digit`]."]
        #[allow(non_snake_case)]
        pub fn r#ascii_digit<'s>(
            &'s self,
        ) -> ::pest3_core::std::Option<::pest3_core::std::Vec<&'s p::rules::r#ascii_digit<'i>>>
        {
            let res = &*self.content;
            {
                let res = &res.field_2;
                {
                    let res = res
                        .as_ref()
                        .map(|res| {
                            let res = res.choice_0().map(|res| {
                                let res = &res.field_1;
                                {
                                    let res = res
                                        .content
                                        .iter()
                                        .map(|res| res)
                                        .collect::<::pest3_core::std::Vec<_>>();
                                    res
                                }
                            });
                            res
                        })
                        .flatten();
                    res
                }
            }
        }
        #[doc = "A helper function to access [`exp`]."]
        #[allow(non_snake_case)]
        pub fn r#exp<'s>(
            &'s self,
        ) -> ::pest3_core::std::Option<(
            ::pest3_core::std::Option<&'s r#exp<'i>>,
            ::pest3_core::std::Option<&'s r#exp<'i>>,
        )> {
            let res = &*self.content;
            {
                let res = &res.field_2;
                {
                    let res = res.as_ref().map(|res| {
                        let res = (
                            {
                                let res = res
                                    .choice_0()
                                    .map(|res| {
                                        let res = &res.field_2;
                                        {
                                            let res = res.as_ref().map(|res| res);
                                            res
                                        }
                                    })
                                    .flatten();
                                res
                            },
                            {
                                let res = res.choice_1().map(|res| res);
                                res
                            },
                        );
                        res
                    });
                    res
                }
            }
        }
        #[doc = "A helper function to access [`int`]."]
        #[allow(non_snake_case)]
        pub fn r#int<'s>(&'s self) -> &'s r#int<'i> {
            let res = &*self.content;
            {
                let res = &res.field_1;
                res
            }
        }
    }
    #[allow(unused_imports)]
    use pest3_core::typed::SubRule as _;
    ::pest3_core::full_rule_struct!(
        r#number,
        (),
        super::Rule,
        super::Rule::r#number,
        super::generics::Sequence3::<
            ::pest3_core::std::Option::<super::generics::Str::<super::wrapper::W33>>,
            ::pest3_core::typed::template::Empty,
            r#int::<'i>,
            ::pest3_core::typed::template::Empty,
            ::pest3_core::std::Option::<
                super::generics::Choice2::<
                    super::generics::Sequence3::<
                        super::generics::Str::<super::wrapper::W34>,
                        ::pest3_core::typed::template::Empty,
                        super::generics::RepOnce::<
                            p::rules::r#ascii_digit::<'i>,
                            ::pest3_core::typed::template::Empty,
                        >,
                        __OptionalTrivia::<'i>,
                        ::pest3_core::std::Option::<r#exp::<'i>>,
                        __OptionalTrivia::<'i>,
                    >,
                    r#exp::<'i>,
                >,
            >,
            ::pest3_core::typed::template::Empty,
        >,
        ::pest3_core::std::Box<
            super::generics::Sequence3::<
                ::pest3_core::std::Option::<super::generics::Str::<super::wrapper::W33>>,
                ::pest3_core::typed::template::Empty,
                r#int::<'i>,
                ::pest3_core::typed::template::Empty,
                ::pest3_core::std::Option::<
                    super::generics::Choice2::<
                        super::generics::Sequence3::<
                            super::generics::Str::<super::wrapper::W34>,
                            ::pest3_core::typed::template::Empty,
                            super::generics::RepOnce::<
                                p::rules::r#ascii_digit::<'i>,
                                ::pest3_core::typed::template::Empty,
                            >,
                            __OptionalTrivia::<'i>,
                            ::pest3_core::std::Option::<r#exp::<'i>>,
                            __OptionalTrivia::<'i>,
                        >,
                        r#exp::<'i>,
                    >,
                >,
                ::pest3_core::typed::template::Empty,
            >,
        >,
    );
    #[allow(non_camel_case_types)]
    impl<'i> ::pest3_core::typed::PairContainer<super::Rule> for r#number<'i> {
        fn for_each_child_pair(
            &self,
            f: &mut impl ::pest3_core::std::FnMut(::pest3_core::token::Pair<super::Rule>),
        ) {
            self.content.for_self_or_for_each_child_pair(f)
        }
        fn for_self_or_for_each_child_pair(
            &self,
            f: &mut impl ::pest3_core::std::FnMut(::pest3_core::token::Pair<super::Rule>),
        ) {
            use pest3_core::typed::PairTree;
            f(self.as_pair_tree())
        }
    }
    #[allow(non_camel_case_types)]
    impl<'i> ::pest3_core::typed::PairTree<super::Rule> for r#number<'i> {
        fn get_rule() -> super::Rule {
            #[allow(unused_imports)]
            use pest3_core::typed::SubRule as _;
            super::Rule::r#number
        }
        fn get_span(&self) -> (::pest3_core::std::usize, ::pest3_core::std::usize) {
            (self.span.start(), self.span.end())
        }
    }
    #[doc = "Generated for rule `int`. Grammar: `(\"0\" | (p::ascii_nonzero_digit - p::ascii_digit*))`."]
    #[derive(Clone, Debug, Eq, PartialEq)]
    #[allow(non_camel_case_types)]
    pub struct r#int<'i> {
        #[doc = r" Matched structure."]
        pub content: ::pest3_core::std::Box<
            super::generics::Choice2<
                super::generics::Str<super::wrapper::W6>,
                super::generics::Sequence2<
                    p::rules::r#ascii_nonzero_digit<'i>,
                    ::pest3_core::typed::template::Empty,
                    super::generics::Rep<
                        p::rules::r#ascii_digit<'i>,
                        ::pest3_core::typed::template::Empty,
                    >,
                    ::pest3_core::typed::template::Empty,
                >,
            >,
        >,
        #[doc = r" Matched span."]
        pub span: ::pest3_core::Span<'i>,
    }
    #[allow(non_camel_case_types)]
    impl<'i> ::pest3_core::typed::wrapper::Rule for r#int<'i> {
        type Rule = super::Rule;
        const RULE: super::Rule = super::Rule::r#int;
    }
    #[allow(non_camel_case_types)]
    impl<'i> r#int<'i> {
        #[doc = "A helper function to access [`ascii_digit`]."]
        #[allow(non_snake_case)]
        pub fn r#ascii_digit<'s>(
            &'s self,
        ) -> ::pest3_core::std::Option<::pest3_core::std::Vec<&'s p::rules::r#ascii_digit<'i>>>
        {
            let res = &*self.content;
            {
                let res = res.choice_1().map(|res| {
                    let res = &res.field_1;
                    {
                        let res = res
                            .content
                            .iter()
                            .map(|res| res)
                            .collect::<::pest3_core::std::Vec<_>>();
                        res
                    }
                });
                res
            }
        }
        #[doc = "A helper function to access [`ascii_nonzero_digit`]."]
        #[allow(non_snake_case)]
        pub fn r#ascii_nonzero_digit<'s>(
            &'s self,
        ) -> ::pest3_core::std::Option<&'s p::rules::r#ascii_nonzero_digit<'i>> {
            let res = &*self.content;
            {
                let res = res.choice_1().map(|res| {
                    let res = &res.field_0;
                    res
                });
                res
            }
        }
    }
    #[allow(unused_imports)]
    use pest3_core::typed::SubRule as _;
    ::pest3_core::full_rule_struct!(
        r#int,
        (),
        super::Rule,
        super::Rule::r#int,
        super::generics::Choice2::<
            super::generics::Str::<super::wrapper::W6>,
            super::generics::Sequence2::<
                p::rules::r#ascii_nonzero_digit::<'i>,
                ::pest3_core::typed::template::Empty,
                super::generics::Rep::<
                    p::rules::r#ascii_digit::<'i>,
                    ::pest3_core::typed::template::Empty,
                >,
                ::pest3_core::typed::template::Empty,
            >,
        >,
        ::pest3_core::std::Box<
            super::generics::Choice2::<
                super::generics::Str::<super::wrapper::W6>,
                super::generics::Sequence2::<
                    p::rules::r#ascii_nonzero_digit::<'i>,
                    ::pest3_core::typed::template::Empty,
                    super::generics::Rep::<
                        p::rules::r#ascii_digit::<'i>,
                        ::pest3_core::typed::template::Empty,
                    >,
                    ::pest3_core::typed::template::Empty,
                >,
            >,
        >,
    );
    #[allow(non_camel_case_types)]
    impl<'i> ::pest3_core::typed::PairContainer<super::Rule> for r#int<'i> {
        fn for_each_child_pair(
            &self,
            f: &mut impl ::pest3_core::std::FnMut(::pest3_core::token::Pair<super::Rule>),
        ) {
            self.content.for_self_or_for_each_child_pair(f)
        }
        fn for_self_or_for_each_child_pair(
            &self,
            f: &mut impl ::pest3_core::std::FnMut(::pest3_core::token::Pair<super::Rule>),
        ) {
            use pest3_core::typed::PairTree;
            f(self.as_pair_tree())
        }
    }
    #[allow(non_camel_case_types)]
    impl<'i> ::pest3_core::typed::PairTree<super::Rule> for r#int<'i> {
        fn get_rule() -> super::Rule {
            #[allow(unused_imports)]
            use pest3_core::typed::SubRule as _;
            super::Rule::r#int
        }
        fn get_span(&self) -> (::pest3_core::std::usize, ::pest3_core::std::usize) {
            (self.span.start(), self.span.end())
        }
    }
    #[doc = "Generated for rule `exp`. Grammar: `((\"E\" | \"e\") - ((\"+\" | \"-\")? - p::ascii_digit+))`."]
    #[derive(Clone, Debug, Eq, PartialEq)]
    #[allow(non_camel_case_types)]
    pub struct r#exp<'i> {
        #[doc = r" Matched structure."]
        pub content: ::pest3_core::std::Box<
            super::generics::Sequence3<
                super::generics::Choice2<
                    super::generics::Str<super::wrapper::W4>,
                    super::generics::Str<super::wrapper::W35>,
                >,
                ::pest3_core::typed::template::Empty,
                ::pest3_core::std::Option<
                    super::generics::Choice2<
                        super::generics::Str<super::wrapper::W36>,
                        super::generics::Str<super::wrapper::W33>,
                    >,
                >,
                ::pest3_core::typed::template::Empty,
                super::generics::RepOnce<
                    p::rules::r#ascii_digit<'i>,
                    ::pest3_core::typed::template::Empty,
                >,
                ::pest3_core::typed::template::Empty,
            >,
        >,
        #[doc = r" Matched span."]
        pub span: ::pest3_core::Span<'i>,
    }
    #[allow(non_camel_case_types)]
    impl<'i> ::pest3_core::typed::wrapper::Rule for r#exp<'i> {
        type Rule = super::Rule;
        const RULE: super::Rule = super::Rule::r#exp;
    }
    #[allow(non_camel_case_types)]
    impl<'i> r#exp<'i> {
        #[doc = "A helper function to access [`ascii_digit`]."]
        #[allow(non_snake_case)]
        pub fn r#ascii_digit<'s>(
            &'s self,
        ) -> ::pest3_core::std::Vec<&'s p::rules::r#ascii_digit<'i>> {
            let res = &*self.content;
            {
                let res = &res.field_2;
                {
                    let res = res
                        .content
                        .iter()
                        .map(|res| res)
                        .collect::<::pest3_core::std::Vec<_>>();
                    res
                }
            }
        }
    }
    #[allow(unused_imports)]
    use pest3_core::typed::SubRule as _;
    ::pest3_core::full_rule_struct!(
        r#exp,
        (),
        super::Rule,
        super::Rule::r#exp,
        super::generics::Sequence3::<
            super::generics::Choice2::<
                super::generics::Str::<super::wrapper::W4>,
                super::generics::Str::<super::wrapper::W35>,
            >,
            ::pest3_core::typed::template::Empty,
            ::pest3_core::std::Option::<
                super::generics::Choice2::<
                    super::generics::Str::<super::wrapper::W36>,
                    super::generics::Str::<super::wrapper::W33>,
                >,
            >,
            ::pest3_core::typed::template::Empty,
            super::generics::RepOnce::<
                p::rules::r#ascii_digit::<'i>,
                ::pest3_core::typed::template::Empty,
            >,
            ::pest3_core::typed::template::Empty,
        >,
        ::pest3_core::std::Box<
            super::generics::Sequence3::<
                super::generics::Choice2::<
                    super::generics::Str::<super::wrapper::W4>,
                    super::generics::Str::<super::wrapper::W35>,
                >,
                ::pest3_core::typed::template::Empty,
                ::pest3_core::std::Option::<
                    super::generics::Choice2::<
                        super::generics::Str::<super::wrapper::W36>,
                        super::generics::Str::<super::wrapper::W33>,
                    >,
                >,
                ::pest3_core::typed::template::Empty,
                super::generics::RepOnce::<
                    p::rules::r#ascii_digit::<'i>,
                    ::pest3_core::typed::template::Empty,
                >,
                ::pest3_core::typed::template::Empty,
            >,
        >,
    );
    #[allow(non_camel_case_types)]
    impl<'i> ::pest3_core::typed::PairContainer<super::Rule> for r#exp<'i> {
        fn for_each_child_pair(
            &self,
            f: &mut impl ::pest3_core::std::FnMut(::pest3_core::token::Pair<super::Rule>),
        ) {
            self.content.for_self_or_for_each_child_pair(f)
        }
        fn for_self_or_for_each_child_pair(
            &self,
            f: &mut impl ::pest3_core::std::FnMut(::pest3_core::token::Pair<super::Rule>),
        ) {
            use pest3_core::typed::PairTree;
            f(self.as_pair_tree())
        }
    }
    #[allow(non_camel_case_types)]
    impl<'i> ::pest3_core::typed::PairTree<super::Rule> for r#exp<'i> {
        fn get_rule() -> super::Rule {
            #[allow(unused_imports)]
            use pest3_core::typed::SubRule as _;
            super::Rule::r#exp
        }
        fn get_span(&self) -> (::pest3_core::std::usize, ::pest3_core::std::usize) {
            (self.span.start(), self.span.end())
        }
    }
    #[doc = "Generated for rule `bool`. Grammar: `(\"true\" | \"false\")`."]
    #[derive(Clone, Debug, Eq, PartialEq)]
    #[allow(non_camel_case_types)]
    pub struct r#bool<'i> {
        #[doc = r" Matched structure."]
        pub content: ::pest3_core::std::Box<
            super::generics::Choice2<
                super::generics::Str<super::wrapper::W37>,
                super::generics::Str<super::wrapper::W38>,
            >,
        >,
        #[doc = r" Matched span."]
        pub span: ::pest3_core::Span<'i>,
    }
    #[allow(non_camel_case_types)]
    impl<'i> ::pest3_core::typed::wrapper::Rule for r#bool<'i> {
        type Rule = super::Rule;
        const RULE: super::Rule = super::Rule::r#bool;
    }
    #[allow(non_camel_case_types)]
    impl<'i> r#bool<'i> {}
    #[allow(unused_imports)]
    use pest3_core::typed::SubRule as _;
    ::pest3_core::full_rule_struct!(
        r#bool,
        (),
        super::Rule,
        super::Rule::r#bool,
        super::generics::Choice2::<
            super::generics::Str::<super::wrapper::W37>,
            super::generics::Str::<super::wrapper::W38>,
        >,
        ::pest3_core::std::Box<
            super::generics::Choice2::<
                super::generics::Str::<super::wrapper::W37>,
                super::generics::Str::<super::wrapper::W38>,
            >,
        >,
    );
    #[allow(non_camel_case_types)]
    impl<'i> ::pest3_core::typed::PairContainer<super::Rule> for r#bool<'i> {
        fn for_each_child_pair(
            &self,
            f: &mut impl ::pest3_core::std::FnMut(::pest3_core::token::Pair<super::Rule>),
        ) {
            self.content.for_self_or_for_each_child_pair(f)
        }
        fn for_self_or_for_each_child_pair(
            &self,
            f: &mut impl ::pest3_core::std::FnMut(::pest3_core::token::Pair<super::Rule>),
        ) {
            use pest3_core::typed::PairTree;
            f(self.as_pair_tree())
        }
    }
    #[allow(non_camel_case_types)]
    impl<'i> ::pest3_core::typed::PairTree<super::Rule> for r#bool<'i> {
        fn get_rule() -> super::Rule {
            #[allow(unused_imports)]
            use pest3_core::typed::SubRule as _;
            super::Rule::r#bool
        }
        fn get_span(&self) -> (::pest3_core::std::usize, ::pest3_core::std::usize) {
            (self.span.start(), self.span.end())
        }
    }
    #[doc = "Generated for rule `null`. Grammar: `\"null\"`."]
    #[derive(Clone, Debug, Eq, PartialEq)]
    #[allow(non_camel_case_types)]
    pub struct r#null<'i> {
        #[doc = r" Matched structure."]
        pub content: ::pest3_core::std::Box<super::generics::Str<super::wrapper::W39>>,
        #[doc = r" Matched span."]
        pub span: ::pest3_core::Span<'i>,
    }
    #[allow(non_camel_case_types)]
    impl<'i> ::pest3_core::typed::wrapper::Rule for r#null<'i> {
        type Rule = super::Rule;
        const RULE: super::Rule = super::Rule::r#null;
    }
    #[allow(non_camel_case_types)]
    impl<'i> r#null<'i> {}
    #[allow(unused_imports)]
    use pest3_core::typed::SubRule as _;
    ::pest3_core::full_rule_struct!(
        r#null,
        (),
        super::Rule,
        super::Rule::r#null,
        super::generics::Str::<super::wrapper::W39>,
        ::pest3_core::std::Box<super::generics::Str::<super::wrapper::W39>>,
    );
    #[allow(non_camel_case_types)]
    impl<'i> ::pest3_core::typed::PairContainer<super::Rule> for r#null<'i> {
        fn for_each_child_pair(
            &self,
            f: &mut impl ::pest3_core::std::FnMut(::pest3_core::token::Pair<super::Rule>),
        ) {
            self.content.for_self_or_for_each_child_pair(f)
        }
        fn for_self_or_for_each_child_pair(
            &self,
            f: &mut impl ::pest3_core::std::FnMut(::pest3_core::token::Pair<super::Rule>),
        ) {
            use pest3_core::typed::PairTree;
            f(self.as_pair_tree())
        }
    }
    #[allow(non_camel_case_types)]
    impl<'i> ::pest3_core::typed::PairTree<super::Rule> for r#null<'i> {
        fn get_rule() -> super::Rule {
            #[allow(unused_imports)]
            use pest3_core::typed::SubRule as _;
            super::Rule::r#null
        }
        fn get_span(&self) -> (::pest3_core::std::usize, ::pest3_core::std::usize) {
            (self.span.start(), self.span.end())
        }
    }
    #[doc = "Generated for rule `space`. Grammar: `(\" \" | (\"\\t\" | (\"\\r\" | \"\\n\")))`."]
    #[derive(Clone, Debug, Eq, PartialEq)]
    #[allow(non_camel_case_types)]
    pub struct r#space<'i> {
        #[doc = r" Matched structure."]
        pub content: ::pest3_core::std::Box<
            super::generics::Choice4<
                super::generics::Str<super::wrapper::W16>,
                super::generics::Str<super::wrapper::W17>,
                super::generics::Str<super::wrapper::W40>,
                super::generics::Str<super::wrapper::W41>,
            >,
        >,
        #[doc = r" Matched span."]
        pub span: ::pest3_core::Span<'i>,
    }
    #[allow(non_camel_case_types)]
    impl<'i> ::pest3_core::typed::wrapper::Rule for r#space<'i> {
        type Rule = super::Rule;
        const RULE: super::Rule = super::Rule::r#space;
    }
    #[allow(non_camel_case_types)]
    impl<'i> r#space<'i> {}
    #[allow(unused_imports)]
    use pest3_core::typed::SubRule as _;
    ::pest3_core::full_rule_struct!(
        r#space,
        (),
        super::Rule,
        super::Rule::r#space,
        super::generics::Choice4::<
            super::generics::Str::<super::wrapper::W16>,
            super::generics::Str::<super::wrapper::W17>,
            super::generics::Str::<super::wrapper::W40>,
            super::generics::Str::<super::wrapper::W41>,
        >,
        ::pest3_core::std::Box<
            super::generics::Choice4::<
                super::generics::Str::<super::wrapper::W16>,
                super::generics::Str::<super::wrapper::W17>,
                super::generics::Str::<super::wrapper::W40>,
                super::generics::Str::<super::wrapper::W41>,
            >,
        >,
    );
    #[allow(non_camel_case_types)]
    impl<'i> ::pest3_core::typed::PairContainer<super::Rule> for r#space<'i> {
        fn for_each_child_pair(
            &self,
            f: &mut impl ::pest3_core::std::FnMut(::pest3_core::token::Pair<super::Rule>),
        ) {
            self.content.for_self_or_for_each_child_pair(f)
        }
        fn for_self_or_for_each_child_pair(
            &self,
            f: &mut impl ::pest3_core::std::FnMut(::pest3_core::token::Pair<super::Rule>),
        ) {
            use pest3_core::typed::PairTree;
            f(self.as_pair_tree())
        }
    }
    #[allow(non_camel_case_types)]
    impl<'i> ::pest3_core::typed::PairTree<super::Rule> for r#space<'i> {
        fn get_rule() -> super::Rule {
            #[allow(unused_imports)]
            use pest3_core::typed::SubRule as _;
            super::Rule::r#space
        }
        fn get_span(&self) -> (::pest3_core::std::usize, ::pest3_core::std::usize) {
            (self.span.start(), self.span.end())
        }
    }
}
mod wrapper {
    #[doc = "A wrapper for `\"A\"`."]
    #[derive(Clone, Debug, Hash, PartialEq, Eq)]
    pub struct W0;
    impl ::pest3_core::typed::wrapper::String for W0 {
        const CONTENT: &'static ::core::primitive::str = "A";
    }
    #[doc = "A wrapper for `\"B\"`."]
    #[derive(Clone, Debug, Hash, PartialEq, Eq)]
    pub struct W1;
    impl ::pest3_core::typed::wrapper::String for W1 {
        const CONTENT: &'static ::core::primitive::str = "B";
    }
    #[doc = "A wrapper for `\"C\"`."]
    #[derive(Clone, Debug, Hash, PartialEq, Eq)]
    pub struct W2;
    impl ::pest3_core::typed::wrapper::String for W2 {
        const CONTENT: &'static ::core::primitive::str = "C";
    }
    #[doc = "A wrapper for `\"D\"`."]
    #[derive(Clone, Debug, Hash, PartialEq, Eq)]
    pub struct W3;
    impl ::pest3_core::typed::wrapper::String for W3 {
        const CONTENT: &'static ::core::primitive::str = "D";
    }
    #[doc = "A wrapper for `\"E\"`."]
    #[derive(Clone, Debug, Hash, PartialEq, Eq)]
    pub struct W4;
    impl ::pest3_core::typed::wrapper::String for W4 {
        const CONTENT: &'static ::core::primitive::str = "E";
    }
    #[doc = "A wrapper for `\"F\"`."]
    #[derive(Clone, Debug, Hash, PartialEq, Eq)]
    pub struct W5;
    impl ::pest3_core::typed::wrapper::String for W5 {
        const CONTENT: &'static ::core::primitive::str = "F";
    }
    #[doc = "A wrapper for `\"0\"`."]
    #[derive(Clone, Debug, Hash, PartialEq, Eq)]
    pub struct W6;
    impl ::pest3_core::typed::wrapper::String for W6 {
        const CONTENT: &'static ::core::primitive::str = "0";
    }
    #[doc = "A wrapper for `\"1\"`."]
    #[derive(Clone, Debug, Hash, PartialEq, Eq)]
    pub struct W7;
    impl ::pest3_core::typed::wrapper::String for W7 {
        const CONTENT: &'static ::core::primitive::str = "1";
    }
    #[doc = "A wrapper for `\"2\"`."]
    #[derive(Clone, Debug, Hash, PartialEq, Eq)]
    pub struct W8;
    impl ::pest3_core::typed::wrapper::String for W8 {
        const CONTENT: &'static ::core::primitive::str = "2";
    }
    #[doc = "A wrapper for `\"3\"`."]
    #[derive(Clone, Debug, Hash, PartialEq, Eq)]
    pub struct W9;
    impl ::pest3_core::typed::wrapper::String for W9 {
        const CONTENT: &'static ::core::primitive::str = "3";
    }
    #[doc = "A wrapper for `\"4\"`."]
    #[derive(Clone, Debug, Hash, PartialEq, Eq)]
    pub struct W10;
    impl ::pest3_core::typed::wrapper::String for W10 {
        const CONTENT: &'static ::core::primitive::str = "4";
    }
    #[doc = "A wrapper for `\"5\"`."]
    #[derive(Clone, Debug, Hash, PartialEq, Eq)]
    pub struct W11;
    impl ::pest3_core::typed::wrapper::String for W11 {
        const CONTENT: &'static ::core::primitive::str = "5";
    }
    #[doc = "A wrapper for `\"6\"`."]
    #[derive(Clone, Debug, Hash, PartialEq, Eq)]
    pub struct W12;
    impl ::pest3_core::typed::wrapper::String for W12 {
        const CONTENT: &'static ::core::primitive::str = "6";
    }
    #[doc = "A wrapper for `\"7\"`."]
    #[derive(Clone, Debug, Hash, PartialEq, Eq)]
    pub struct W13;
    impl ::pest3_core::typed::wrapper::String for W13 {
        const CONTENT: &'static ::core::primitive::str = "7";
    }
    #[doc = "A wrapper for `\"8\"`."]
    #[derive(Clone, Debug, Hash, PartialEq, Eq)]
    pub struct W14;
    impl ::pest3_core::typed::wrapper::String for W14 {
        const CONTENT: &'static ::core::primitive::str = "8";
    }
    #[doc = "A wrapper for `\"9\"`."]
    #[derive(Clone, Debug, Hash, PartialEq, Eq)]
    pub struct W15;
    impl ::pest3_core::typed::wrapper::String for W15 {
        const CONTENT: &'static ::core::primitive::str = "9";
    }
    #[doc = "A wrapper for `\" \"`."]
    #[derive(Clone, Debug, Hash, PartialEq, Eq)]
    pub struct W16;
    impl ::pest3_core::typed::wrapper::String for W16 {
        const CONTENT: &'static ::core::primitive::str = " ";
    }
    #[doc = "A wrapper for `\"\\t\"`."]
    #[derive(Clone, Debug, Hash, PartialEq, Eq)]
    pub struct W17;
    impl ::pest3_core::typed::wrapper::String for W17 {
        const CONTENT: &'static ::core::primitive::str = "\t";
    }
    #[doc = "A wrapper for `\"{\"`."]
    #[derive(Clone, Debug, Hash, PartialEq, Eq)]
    pub struct W18;
    impl ::pest3_core::typed::wrapper::String for W18 {
        const CONTENT: &'static ::core::primitive::str = "{";
    }
    #[doc = "A wrapper for `\"}\"`."]
    #[derive(Clone, Debug, Hash, PartialEq, Eq)]
    pub struct W19;
    impl ::pest3_core::typed::wrapper::String for W19 {
        const CONTENT: &'static ::core::primitive::str = "}";
    }
    #[doc = "A wrapper for `\":\"`."]
    #[derive(Clone, Debug, Hash, PartialEq, Eq)]
    pub struct W20;
    impl ::pest3_core::typed::wrapper::String for W20 {
        const CONTENT: &'static ::core::primitive::str = ":";
    }
    #[doc = "A wrapper for `\"[\"`."]
    #[derive(Clone, Debug, Hash, PartialEq, Eq)]
    pub struct W21;
    impl ::pest3_core::typed::wrapper::String for W21 {
        const CONTENT: &'static ::core::primitive::str = "[";
    }
    #[doc = "A wrapper for `\",\"`."]
    #[derive(Clone, Debug, Hash, PartialEq, Eq)]
    pub struct W22;
    impl ::pest3_core::typed::wrapper::String for W22 {
        const CONTENT: &'static ::core::primitive::str = ",";
    }
    #[doc = "A wrapper for `\"]\"`."]
    #[derive(Clone, Debug, Hash, PartialEq, Eq)]
    pub struct W23;
    impl ::pest3_core::typed::wrapper::String for W23 {
        const CONTENT: &'static ::core::primitive::str = "]";
    }
    #[doc = "A wrapper for `\"\\\"\"`."]
    #[derive(Clone, Debug, Hash, PartialEq, Eq)]
    pub struct W24;
    impl ::pest3_core::typed::wrapper::String for W24 {
        const CONTENT: &'static ::core::primitive::str = "\"";
    }
    #[doc = "A wrapper for `\"\\\\\"`."]
    #[derive(Clone, Debug, Hash, PartialEq, Eq)]
    pub struct W25;
    impl ::pest3_core::typed::wrapper::String for W25 {
        const CONTENT: &'static ::core::primitive::str = "\\";
    }
    #[doc = "A wrapper for `\"/\"`."]
    #[derive(Clone, Debug, Hash, PartialEq, Eq)]
    pub struct W26;
    impl ::pest3_core::typed::wrapper::String for W26 {
        const CONTENT: &'static ::core::primitive::str = "/";
    }
    #[doc = "A wrapper for `\"b\"`."]
    #[derive(Clone, Debug, Hash, PartialEq, Eq)]
    pub struct W27;
    impl ::pest3_core::typed::wrapper::String for W27 {
        const CONTENT: &'static ::core::primitive::str = "b";
    }
    #[doc = "A wrapper for `\"f\"`."]
    #[derive(Clone, Debug, Hash, PartialEq, Eq)]
    pub struct W28;
    impl ::pest3_core::typed::wrapper::String for W28 {
        const CONTENT: &'static ::core::primitive::str = "f";
    }
    #[doc = "A wrapper for `\"n\"`."]
    #[derive(Clone, Debug, Hash, PartialEq, Eq)]
    pub struct W29;
    impl ::pest3_core::typed::wrapper::String for W29 {
        const CONTENT: &'static ::core::primitive::str = "n";
    }
    #[doc = "A wrapper for `\"r\"`."]
    #[derive(Clone, Debug, Hash, PartialEq, Eq)]
    pub struct W30;
    impl ::pest3_core::typed::wrapper::String for W30 {
        const CONTENT: &'static ::core::primitive::str = "r";
    }
    #[doc = "A wrapper for `\"t\"`."]
    #[derive(Clone, Debug, Hash, PartialEq, Eq)]
    pub struct W31;
    impl ::pest3_core::typed::wrapper::String for W31 {
        const CONTENT: &'static ::core::primitive::str = "t";
    }
    #[doc = "A wrapper for `\"u\"`."]
    #[derive(Clone, Debug, Hash, PartialEq, Eq)]
    pub struct W32;
    impl ::pest3_core::typed::wrapper::String for W32 {
        const CONTENT: &'static ::core::primitive::str = "u";
    }
    #[doc = "A wrapper for `\"-\"`."]
    #[derive(Clone, Debug, Hash, PartialEq, Eq)]
    pub struct W33;
    impl ::pest3_core::typed::wrapper::String for W33 {
        const CONTENT: &'static ::core::primitive::str = "-";
    }
    #[doc = "A wrapper for `\".\"`."]
    #[derive(Clone, Debug, Hash, PartialEq, Eq)]
    pub struct W34;
    impl ::pest3_core::typed::wrapper::String for W34 {
        const CONTENT: &'static ::core::primitive::str = ".";
    }
    #[doc = "A wrapper for `\"e\"`."]
    #[derive(Clone, Debug, Hash, PartialEq, Eq)]
    pub struct W35;
    impl ::pest3_core::typed::wrapper::String for W35 {
        const CONTENT: &'static ::core::primitive::str = "e";
    }
    #[doc = "A wrapper for `\"+\"`."]
    #[derive(Clone, Debug, Hash, PartialEq, Eq)]
    pub struct W36;
    impl ::pest3_core::typed::wrapper::String for W36 {
        const CONTENT: &'static ::core::primitive::str = "+";
    }
    #[doc = "A wrapper for `\"true\"`."]
    #[derive(Clone, Debug, Hash, PartialEq, Eq)]
    pub struct W37;
    impl ::pest3_core::typed::wrapper::String for W37 {
        const CONTENT: &'static ::core::primitive::str = "true";
    }
    #[doc = "A wrapper for `\"false\"`."]
    #[derive(Clone, Debug, Hash, PartialEq, Eq)]
    pub struct W38;
    impl ::pest3_core::typed::wrapper::String for W38 {
        const CONTENT: &'static ::core::primitive::str = "false";
    }
    #[doc = "A wrapper for `\"null\"`."]
    #[derive(Clone, Debug, Hash, PartialEq, Eq)]
    pub struct W39;
    impl ::pest3_core::typed::wrapper::String for W39 {
        const CONTENT: &'static ::core::primitive::str = "null";
    }
    #[doc = "A wrapper for `\"\\r\"`."]
    #[derive(Clone, Debug, Hash, PartialEq, Eq)]
    pub struct W40;
    impl ::pest3_core::typed::wrapper::String for W40 {
        const CONTENT: &'static ::core::primitive::str = "\r";
    }
    #[doc = "A wrapper for `\"\\n\"`."]
    #[derive(Clone, Debug, Hash, PartialEq, Eq)]
    pub struct W41;
    impl ::pest3_core::typed::wrapper::String for W41 {
        const CONTENT: &'static ::core::primitive::str = "\n";
    }
}
pub use pest3_core::typed::unicode;
#[doc = "Used generics."]
pub mod generics {
    pub use pest3_core::choice::Choice10;
    pub use pest3_core::choice::Choice2;
    pub use pest3_core::choice::Choice3;
    pub use pest3_core::choice::Choice4;
    pub use pest3_core::choice::Choice6;
    pub use pest3_core::choice::Choice7;
    pub use pest3_core::choice::Choice9;
    pub use pest3_core::sequence::Sequence2;
    pub use pest3_core::sequence::Sequence3;
    pub use pest3_core::sequence::Sequence4;
    pub use pest3_core::typed::template::{
        CharRange, Insens, Negative, PeekSlice1, PeekSlice2, Positive, Rep, RepMax, RepMin,
        RepMinMax, RepOnce, Str, ANY as any, ASCII as ascii, ASCII_ALPHA as ascii_alpha,
        ASCII_ALPHANUMERIC as ascii_alphanumeric, ASCII_ALPHA_LOWER as ascii_alpha_lower,
        ASCII_ALPHA_UPPER as ascii_alpha_upper, ASCII_BIN_DIGIT as ascii_bin_digit,
        ASCII_DIGIT as ascii_digit, ASCII_HEX_DIGIT as ascii_hex_digit,
        ASCII_NONZERO_DIGIT as ascii_nonzero_digit, ASCII_OCT_DIGIT as ascii_oct_digit,
        DROP as drop, EOI, EOI as eoi, NEWLINE as newline, PEEK as peek, PEEK_ALL as peek_all,
        POP as pop, POP_ALL as pop_all, PUSH as push, SOI, SOI as soi,
    };
}
