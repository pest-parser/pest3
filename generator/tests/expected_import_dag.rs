#[allow(
    dead_code,
    missing_docs,
    non_camel_case_types,
    clippy::upper_case_acronyms
)]
#[derive(Clone, Copy, Debug, Eq, Hash, Ord, PartialEq, PartialOrd)]
pub enum Rule {
    EOI,
    r#main,
    r#dag(rules::r#dag::Rule),
}
impl ::pest3_core::typed::SuperRule<rules::r#dag::Rule> for Rule {
    fn cvt_from(rule: rules::r#dag::Rule) -> Self {
        Self::r#dag(rule)
    }
}
impl ::pest3_core::typed::RuleType for Rule {
    const EOI: Self = Rule::EOI;
}
#[doc = "Definitions of statically typed nodes generated by pest-generator."]
pub mod rules {
    pub type __OptionalTrivia<'i> = ::pest3_core::typed::template::Empty;
    pub type __MandatoryTrivia<'i> = ::pest3_core::typed::template::Empty;
    pub mod dag {
        #[allow(
            dead_code,
            missing_docs,
            non_camel_case_types,
            clippy::upper_case_acronyms
        )]
        #[derive(Clone, Copy, Debug, Eq, Hash, Ord, PartialEq, PartialOrd)]
        pub enum Rule {
            EOI,
            r#f,
            r#d(rules::r#d::Rule),
            r#e(rules::r#e::Rule),
        }
        impl ::pest3_core::typed::SuperRule<rules::r#d::Rule> for Rule {
            fn cvt_from(rule: rules::r#d::Rule) -> Self {
                Self::r#d(rule)
            }
        }
        impl ::pest3_core::typed::SuperRule<rules::r#e::Rule> for Rule {
            fn cvt_from(rule: rules::r#e::Rule) -> Self {
                Self::r#e(rule)
            }
        }
        impl ::pest3_core::typed::RuleType for Rule {
            const EOI: Self = Rule::EOI;
        }
        #[doc = "Definitions of statically typed nodes generated by pest-generator."]
        pub mod rules {
            pub type __OptionalTrivia<'i> = ::pest3_core::typed::template::Empty;
            pub type __MandatoryTrivia<'i> = ::pest3_core::typed::template::Empty;
            pub mod d {
                #[allow(
                    dead_code,
                    missing_docs,
                    non_camel_case_types,
                    clippy::upper_case_acronyms
                )]
                #[derive(Clone, Copy, Debug, Eq, Hash, Ord, PartialEq, PartialOrd)]
                pub enum Rule {
                    EOI,
                    r#d,
                    r#a(rules::r#a::Rule),
                    r#c(rules::r#c::Rule),
                }
                impl ::pest3_core::typed::SuperRule<rules::r#a::Rule> for Rule {
                    fn cvt_from(rule: rules::r#a::Rule) -> Self {
                        Self::r#a(rule)
                    }
                }
                impl ::pest3_core::typed::SuperRule<rules::r#c::Rule> for Rule {
                    fn cvt_from(rule: rules::r#c::Rule) -> Self {
                        Self::r#c(rule)
                    }
                }
                impl ::pest3_core::typed::RuleType for Rule {
                    const EOI: Self = Rule::EOI;
                }
                #[doc = "Definitions of statically typed nodes generated by pest-generator."]
                pub mod rules {
                    pub type __OptionalTrivia<'i> = ::pest3_core::typed::template::Empty;
                    pub type __MandatoryTrivia<'i> = ::pest3_core::typed::template::Empty;
                    pub mod a {
                        #[allow(
                            dead_code,
                            missing_docs,
                            non_camel_case_types,
                            clippy::upper_case_acronyms
                        )]
                        #[derive(Clone, Copy, Debug, Eq, Hash, Ord, PartialEq, PartialOrd)]
                        pub enum Rule {
                            EOI,
                            r#a,
                        }
                        impl ::pest3_core::typed::RuleType for Rule {
                            const EOI: Self = Rule::EOI;
                        }
                        #[doc = "Definitions of statically typed nodes generated by pest-generator."]
                        pub mod rules {
                            pub type __OptionalTrivia < 'i > = super :: super :: super :: super :: super :: super :: super :: generics :: Rep :: < super :: super :: super :: super :: super :: super :: super :: generics :: Str :: < super :: super :: super :: super :: super :: super :: super :: wrapper :: W1 > , :: pest3_core :: typed :: template :: Empty > ;
                            pub type __MandatoryTrivia<'i> = ::pest3_core::typed::template::Empty;
                            #[doc = "Generated for rule `a`. Grammar: `(\"a\" ~ \"a\"?)`."]
                            #[derive(Clone, Debug, Eq, PartialEq)]
                            #[allow(non_camel_case_types)]
                            pub struct r#a < 'i , > { # [doc = r" Matched structure."] pub content : :: pest3_core :: std :: Box < super :: super :: super :: super :: super :: super :: super :: generics :: Sequence2 :: < super :: super :: super :: super :: super :: super :: super :: generics :: Str :: < super :: super :: super :: super :: super :: super :: super :: wrapper :: W0 > , :: pest3_core :: typed :: template :: Empty , :: pest3_core :: std :: Option :: < super :: super :: super :: super :: super :: super :: super :: generics :: Str :: < super :: super :: super :: super :: super :: super :: super :: wrapper :: W0 > > , __OptionalTrivia :: < 'i > , > > , # [doc = r" Matched span."] pub span : :: pest3_core :: Span < 'i > , }
                            #[allow(non_camel_case_types)]
                            impl<'i> ::pest3_core::typed::wrapper::Rule for r#a<'i> {
                                type Rule = super::Rule;
                                const RULE: super::Rule = super::Rule::r#a;
                            }
                            #[allow(non_camel_case_types)]
                            impl<'i> r#a<'i> {}
                            #[allow(unused_imports)]
                            use pest3_core::typed::SubRule as _;
                            :: pest3_core :: typed :: full_rule_struct ! (r#a , () , super :: Rule , super :: Rule :: r#a , super :: super :: super :: super :: super :: super :: super :: generics :: Sequence2 :: < super :: super :: super :: super :: super :: super :: super :: generics :: Str :: < super :: super :: super :: super :: super :: super :: super :: wrapper :: W0 > , :: pest3_core :: typed :: template :: Empty , :: pest3_core :: std :: Option :: < super :: super :: super :: super :: super :: super :: super :: generics :: Str :: < super :: super :: super :: super :: super :: super :: super :: wrapper :: W0 > > , __OptionalTrivia :: < 'i > , > , :: pest3_core :: std :: Box < super :: super :: super :: super :: super :: super :: super :: generics :: Sequence2 :: < super :: super :: super :: super :: super :: super :: super :: generics :: Str :: < super :: super :: super :: super :: super :: super :: super :: wrapper :: W0 > , :: pest3_core :: typed :: template :: Empty , :: pest3_core :: std :: Option :: < super :: super :: super :: super :: super :: super :: super :: generics :: Str :: < super :: super :: super :: super :: super :: super :: super :: wrapper :: W0 > > , __OptionalTrivia :: < 'i > , > > ,) ;
                            #[allow(unused_imports)]
                            use pest3_core::typed::SubRule as _;
                            :: pest3_core :: typed :: full_rule_struct ! (r#a , () , super :: super :: super :: Rule , super :: Rule :: r#a . cvt_into () , super :: super :: super :: super :: super :: super :: super :: generics :: Sequence2 :: < super :: super :: super :: super :: super :: super :: super :: generics :: Str :: < super :: super :: super :: super :: super :: super :: super :: wrapper :: W0 > , :: pest3_core :: typed :: template :: Empty , :: pest3_core :: std :: Option :: < super :: super :: super :: super :: super :: super :: super :: generics :: Str :: < super :: super :: super :: super :: super :: super :: super :: wrapper :: W0 > > , __OptionalTrivia :: < 'i > , > , :: pest3_core :: std :: Box < super :: super :: super :: super :: super :: super :: super :: generics :: Sequence2 :: < super :: super :: super :: super :: super :: super :: super :: generics :: Str :: < super :: super :: super :: super :: super :: super :: super :: wrapper :: W0 > , :: pest3_core :: typed :: template :: Empty , :: pest3_core :: std :: Option :: < super :: super :: super :: super :: super :: super :: super :: generics :: Str :: < super :: super :: super :: super :: super :: super :: super :: wrapper :: W0 > > , __OptionalTrivia :: < 'i > , > > ,) ;
                            #[allow(unused_imports)]
                            use pest3_core::typed::SubRule as _;
                            :: pest3_core :: typed :: full_rule_struct ! (r#a , () , super :: super :: super :: super :: super :: Rule , super :: Rule :: r#a . cvt_into () . cvt_into () , super :: super :: super :: super :: super :: super :: super :: generics :: Sequence2 :: < super :: super :: super :: super :: super :: super :: super :: generics :: Str :: < super :: super :: super :: super :: super :: super :: super :: wrapper :: W0 > , :: pest3_core :: typed :: template :: Empty , :: pest3_core :: std :: Option :: < super :: super :: super :: super :: super :: super :: super :: generics :: Str :: < super :: super :: super :: super :: super :: super :: super :: wrapper :: W0 > > , __OptionalTrivia :: < 'i > , > , :: pest3_core :: std :: Box < super :: super :: super :: super :: super :: super :: super :: generics :: Sequence2 :: < super :: super :: super :: super :: super :: super :: super :: generics :: Str :: < super :: super :: super :: super :: super :: super :: super :: wrapper :: W0 > , :: pest3_core :: typed :: template :: Empty , :: pest3_core :: std :: Option :: < super :: super :: super :: super :: super :: super :: super :: generics :: Str :: < super :: super :: super :: super :: super :: super :: super :: wrapper :: W0 > > , __OptionalTrivia :: < 'i > , > > ,) ;
                            #[allow(unused_imports)]
                            use pest3_core::typed::SubRule as _;
                            :: pest3_core :: typed :: full_rule_struct ! (r#a , () , super :: super :: super :: super :: super :: super :: super :: Rule , super :: Rule :: r#a . cvt_into () . cvt_into () . cvt_into () , super :: super :: super :: super :: super :: super :: super :: generics :: Sequence2 :: < super :: super :: super :: super :: super :: super :: super :: generics :: Str :: < super :: super :: super :: super :: super :: super :: super :: wrapper :: W0 > , :: pest3_core :: typed :: template :: Empty , :: pest3_core :: std :: Option :: < super :: super :: super :: super :: super :: super :: super :: generics :: Str :: < super :: super :: super :: super :: super :: super :: super :: wrapper :: W0 > > , __OptionalTrivia :: < 'i > , > , :: pest3_core :: std :: Box < super :: super :: super :: super :: super :: super :: super :: generics :: Sequence2 :: < super :: super :: super :: super :: super :: super :: super :: generics :: Str :: < super :: super :: super :: super :: super :: super :: super :: wrapper :: W0 > , :: pest3_core :: typed :: template :: Empty , :: pest3_core :: std :: Option :: < super :: super :: super :: super :: super :: super :: super :: generics :: Str :: < super :: super :: super :: super :: super :: super :: super :: wrapper :: W0 > > , __OptionalTrivia :: < 'i > , > > ,) ;
                            #[allow(non_camel_case_types)]
                            impl<'i> ::pest3_core::typed::PairContainer<super::Rule> for r#a<'i> {
                                fn for_each_child_pair(
                                    &self,
                                    f: &mut impl ::pest3_core::std::FnMut(
                                        ::pest3_core::token::Pair<super::Rule>,
                                    ),
                                ) {
                                    self.content.for_self_or_for_each_child_pair(f)
                                }
                                fn for_self_or_for_each_child_pair(
                                    &self,
                                    f: &mut impl ::pest3_core::std::FnMut(
                                        ::pest3_core::token::Pair<super::Rule>,
                                    ),
                                ) {
                                    use pest3_core::typed::PairTree;
                                    f(self.as_pair_tree())
                                }
                            }
                            #[allow(non_camel_case_types)]
                            impl<'i> ::pest3_core::typed::PairTree<super::Rule> for r#a<'i> {
                                fn get_rule() -> super::Rule {
                                    #[allow(unused_imports)]
                                    use pest3_core::typed::SubRule as _;
                                    super::Rule::r#a
                                }
                                fn get_span(
                                    &self,
                                ) -> (::pest3_core::std::usize, ::pest3_core::std::usize)
                                {
                                    (self.span.start(), self.span.end())
                                }
                            }
                            #[allow(non_camel_case_types)]
                            impl<'i> ::pest3_core::typed::PairContainer<super::super::super::Rule> for r#a<'i> {
                                fn for_each_child_pair(
                                    &self,
                                    f: &mut impl ::pest3_core::std::FnMut(
                                        ::pest3_core::token::Pair<super::super::super::Rule>,
                                    ),
                                ) {
                                    self.content.for_self_or_for_each_child_pair(f)
                                }
                                fn for_self_or_for_each_child_pair(
                                    &self,
                                    f: &mut impl ::pest3_core::std::FnMut(
                                        ::pest3_core::token::Pair<super::super::super::Rule>,
                                    ),
                                ) {
                                    use pest3_core::typed::PairTree;
                                    f(self.as_pair_tree())
                                }
                            }
                            #[allow(non_camel_case_types)]
                            impl<'i> ::pest3_core::typed::PairTree<super::super::super::Rule> for r#a<'i> {
                                fn get_rule() -> super::super::super::Rule {
                                    #[allow(unused_imports)]
                                    use pest3_core::typed::SubRule as _;
                                    super::Rule::r#a.cvt_into()
                                }
                                fn get_span(
                                    &self,
                                ) -> (::pest3_core::std::usize, ::pest3_core::std::usize)
                                {
                                    (self.span.start(), self.span.end())
                                }
                            }
                            #[allow(non_camel_case_types)]
                            impl<'i>
                                ::pest3_core::typed::PairContainer<
                                    super::super::super::super::super::Rule,
                                > for r#a<'i>
                            {
                                fn for_each_child_pair(
                                    &self,
                                    f: &mut impl ::pest3_core::std::FnMut(
                                        ::pest3_core::token::Pair<
                                            super::super::super::super::super::Rule,
                                        >,
                                    ),
                                ) {
                                    self.content.for_self_or_for_each_child_pair(f)
                                }
                                fn for_self_or_for_each_child_pair(
                                    &self,
                                    f: &mut impl ::pest3_core::std::FnMut(
                                        ::pest3_core::token::Pair<
                                            super::super::super::super::super::Rule,
                                        >,
                                    ),
                                ) {
                                    use pest3_core::typed::PairTree;
                                    f(self.as_pair_tree())
                                }
                            }
                            #[allow(non_camel_case_types)]
                            impl<'i>
                                ::pest3_core::typed::PairTree<
                                    super::super::super::super::super::Rule,
                                > for r#a<'i>
                            {
                                fn get_rule() -> super::super::super::super::super::Rule {
                                    #[allow(unused_imports)]
                                    use pest3_core::typed::SubRule as _;
                                    super::Rule::r#a.cvt_into().cvt_into()
                                }
                                fn get_span(
                                    &self,
                                ) -> (::pest3_core::std::usize, ::pest3_core::std::usize)
                                {
                                    (self.span.start(), self.span.end())
                                }
                            }
                            #[allow(non_camel_case_types)]
                            impl<'i>
                                ::pest3_core::typed::PairContainer<
                                    super::super::super::super::super::super::super::Rule,
                                > for r#a<'i>
                            {
                                fn for_each_child_pair(
                                    &self,
                                    f: &mut impl ::pest3_core::std::FnMut(
                                        ::pest3_core::token::Pair<
                                            super::super::super::super::super::super::super::Rule,
                                        >,
                                    ),
                                ) {
                                    self.content.for_self_or_for_each_child_pair(f)
                                }
                                fn for_self_or_for_each_child_pair(
                                    &self,
                                    f: &mut impl ::pest3_core::std::FnMut(
                                        ::pest3_core::token::Pair<
                                            super::super::super::super::super::super::super::Rule,
                                        >,
                                    ),
                                ) {
                                    use pest3_core::typed::PairTree;
                                    f(self.as_pair_tree())
                                }
                            }
                            #[allow(non_camel_case_types)]
                            impl<'i>
                                ::pest3_core::typed::PairTree<
                                    super::super::super::super::super::super::super::Rule,
                                > for r#a<'i>
                            {
                                fn get_rule(
                                ) -> super::super::super::super::super::super::super::Rule
                                {
                                    #[allow(unused_imports)]
                                    use pest3_core::typed::SubRule as _;
                                    super::Rule::r#a.cvt_into().cvt_into().cvt_into()
                                }
                                fn get_span(
                                    &self,
                                ) -> (::pest3_core::std::usize, ::pest3_core::std::usize)
                                {
                                    (self.span.start(), self.span.end())
                                }
                            }
                        }
                    }
                    impl ::pest3_core::typed::SubRule for a::Rule {
                        type Super = super::Rule;
                        fn cvt_into(self) -> Self::Super {
                            super::Rule::a(self)
                        }
                    }
                    pub mod c {
                        #[allow(
                            dead_code,
                            missing_docs,
                            non_camel_case_types,
                            clippy::upper_case_acronyms
                        )]
                        #[derive(Clone, Copy, Debug, Eq, Hash, Ord, PartialEq, PartialOrd)]
                        pub enum Rule {
                            EOI,
                            r#c,
                            r#a(rules::r#a::Rule),
                            r#b(rules::r#b::Rule),
                        }
                        impl ::pest3_core::typed::SuperRule<rules::r#a::Rule> for Rule {
                            fn cvt_from(rule: rules::r#a::Rule) -> Self {
                                Self::r#a(rule)
                            }
                        }
                        impl ::pest3_core::typed::SuperRule<rules::r#b::Rule> for Rule {
                            fn cvt_from(rule: rules::r#b::Rule) -> Self {
                                Self::r#b(rule)
                            }
                        }
                        impl ::pest3_core::typed::RuleType for Rule {
                            const EOI: Self = Rule::EOI;
                        }
                        #[doc = "Definitions of statically typed nodes generated by pest-generator."]
                        pub mod rules {
                            pub type __OptionalTrivia < 'i > = super :: super :: super :: super :: super :: super :: super :: generics :: Sequence3 :: < :: pest3_core :: std :: Option :: < super :: super :: super :: super :: super :: super :: super :: generics :: Str :: < super :: super :: super :: super :: super :: super :: super :: wrapper :: W4 > > , :: pest3_core :: typed :: template :: Empty , :: pest3_core :: std :: Option :: < r#c :: < 'i > > , :: pest3_core :: typed :: template :: Empty , :: pest3_core :: std :: Option :: < super :: super :: super :: super :: super :: super :: super :: generics :: Str :: < super :: super :: super :: super :: super :: super :: super :: wrapper :: W4 > > , :: pest3_core :: typed :: template :: Empty , > ;
                            pub type __MandatoryTrivia<'i> = ::pest3_core::typed::template::Empty;
                            pub mod a {
                                #[allow(
                                    dead_code,
                                    missing_docs,
                                    non_camel_case_types,
                                    clippy::upper_case_acronyms
                                )]
                                #[derive(
                                    Clone, Copy, Debug, Eq, Hash, Ord, PartialEq, PartialOrd,
                                )]
                                pub enum Rule {
                                    EOI,
                                    r#a,
                                }
                                impl ::pest3_core::typed::RuleType for Rule {
                                    const EOI: Self = Rule::EOI;
                                }
                                #[doc = "Definitions of statically typed nodes generated by pest-generator."]
                                pub mod rules {
                                    pub type __OptionalTrivia < 'i > = super :: super :: super :: super :: super :: super :: super :: super :: super :: generics :: Rep :: < super :: super :: super :: super :: super :: super :: super :: super :: super :: generics :: Str :: < super :: super :: super :: super :: super :: super :: super :: super :: super :: wrapper :: W1 > , :: pest3_core :: typed :: template :: Empty > ;
                                    pub type __MandatoryTrivia<'i> =
                                        ::pest3_core::typed::template::Empty;
                                    #[doc = "Generated for rule `a`. Grammar: `(\"a\" ~ \"a\"?)`."]
                                    #[derive(Clone, Debug, Eq, PartialEq)]
                                    #[allow(non_camel_case_types)]
                                    pub struct r#a < 'i , > { # [doc = r" Matched structure."] pub content : :: pest3_core :: std :: Box < super :: super :: super :: super :: super :: super :: super :: super :: super :: generics :: Sequence2 :: < super :: super :: super :: super :: super :: super :: super :: super :: super :: generics :: Str :: < super :: super :: super :: super :: super :: super :: super :: super :: super :: wrapper :: W0 > , :: pest3_core :: typed :: template :: Empty , :: pest3_core :: std :: Option :: < super :: super :: super :: super :: super :: super :: super :: super :: super :: generics :: Str :: < super :: super :: super :: super :: super :: super :: super :: super :: super :: wrapper :: W0 > > , __OptionalTrivia :: < 'i > , > > , # [doc = r" Matched span."] pub span : :: pest3_core :: Span < 'i > , }
                                    #[allow(non_camel_case_types)]
                                    impl<'i> ::pest3_core::typed::wrapper::Rule for r#a<'i> {
                                        type Rule = super::Rule;
                                        const RULE: super::Rule = super::Rule::r#a;
                                    }
                                    #[allow(non_camel_case_types)]
                                    impl<'i> r#a<'i> {}
                                    #[allow(unused_imports)]
                                    use pest3_core::typed::SubRule as _;
                                    :: pest3_core :: typed :: full_rule_struct ! (r#a , () , super :: Rule , super :: Rule :: r#a , super :: super :: super :: super :: super :: super :: super :: super :: super :: generics :: Sequence2 :: < super :: super :: super :: super :: super :: super :: super :: super :: super :: generics :: Str :: < super :: super :: super :: super :: super :: super :: super :: super :: super :: wrapper :: W0 > , :: pest3_core :: typed :: template :: Empty , :: pest3_core :: std :: Option :: < super :: super :: super :: super :: super :: super :: super :: super :: super :: generics :: Str :: < super :: super :: super :: super :: super :: super :: super :: super :: super :: wrapper :: W0 > > , __OptionalTrivia :: < 'i > , > , :: pest3_core :: std :: Box < super :: super :: super :: super :: super :: super :: super :: super :: super :: generics :: Sequence2 :: < super :: super :: super :: super :: super :: super :: super :: super :: super :: generics :: Str :: < super :: super :: super :: super :: super :: super :: super :: super :: super :: wrapper :: W0 > , :: pest3_core :: typed :: template :: Empty , :: pest3_core :: std :: Option :: < super :: super :: super :: super :: super :: super :: super :: super :: super :: generics :: Str :: < super :: super :: super :: super :: super :: super :: super :: super :: super :: wrapper :: W0 > > , __OptionalTrivia :: < 'i > , > > ,) ;
                                    #[allow(unused_imports)]
                                    use pest3_core::typed::SubRule as _;
                                    :: pest3_core :: typed :: full_rule_struct ! (r#a , () , super :: super :: super :: Rule , super :: Rule :: r#a . cvt_into () , super :: super :: super :: super :: super :: super :: super :: super :: super :: generics :: Sequence2 :: < super :: super :: super :: super :: super :: super :: super :: super :: super :: generics :: Str :: < super :: super :: super :: super :: super :: super :: super :: super :: super :: wrapper :: W0 > , :: pest3_core :: typed :: template :: Empty , :: pest3_core :: std :: Option :: < super :: super :: super :: super :: super :: super :: super :: super :: super :: generics :: Str :: < super :: super :: super :: super :: super :: super :: super :: super :: super :: wrapper :: W0 > > , __OptionalTrivia :: < 'i > , > , :: pest3_core :: std :: Box < super :: super :: super :: super :: super :: super :: super :: super :: super :: generics :: Sequence2 :: < super :: super :: super :: super :: super :: super :: super :: super :: super :: generics :: Str :: < super :: super :: super :: super :: super :: super :: super :: super :: super :: wrapper :: W0 > , :: pest3_core :: typed :: template :: Empty , :: pest3_core :: std :: Option :: < super :: super :: super :: super :: super :: super :: super :: super :: super :: generics :: Str :: < super :: super :: super :: super :: super :: super :: super :: super :: super :: wrapper :: W0 > > , __OptionalTrivia :: < 'i > , > > ,) ;
                                    #[allow(unused_imports)]
                                    use pest3_core::typed::SubRule as _;
                                    :: pest3_core :: typed :: full_rule_struct ! (r#a , () , super :: super :: super :: super :: super :: Rule , super :: Rule :: r#a . cvt_into () . cvt_into () , super :: super :: super :: super :: super :: super :: super :: super :: super :: generics :: Sequence2 :: < super :: super :: super :: super :: super :: super :: super :: super :: super :: generics :: Str :: < super :: super :: super :: super :: super :: super :: super :: super :: super :: wrapper :: W0 > , :: pest3_core :: typed :: template :: Empty , :: pest3_core :: std :: Option :: < super :: super :: super :: super :: super :: super :: super :: super :: super :: generics :: Str :: < super :: super :: super :: super :: super :: super :: super :: super :: super :: wrapper :: W0 > > , __OptionalTrivia :: < 'i > , > , :: pest3_core :: std :: Box < super :: super :: super :: super :: super :: super :: super :: super :: super :: generics :: Sequence2 :: < super :: super :: super :: super :: super :: super :: super :: super :: super :: generics :: Str :: < super :: super :: super :: super :: super :: super :: super :: super :: super :: wrapper :: W0 > , :: pest3_core :: typed :: template :: Empty , :: pest3_core :: std :: Option :: < super :: super :: super :: super :: super :: super :: super :: super :: super :: generics :: Str :: < super :: super :: super :: super :: super :: super :: super :: super :: super :: wrapper :: W0 > > , __OptionalTrivia :: < 'i > , > > ,) ;
                                    #[allow(unused_imports)]
                                    use pest3_core::typed::SubRule as _;
                                    :: pest3_core :: typed :: full_rule_struct ! (r#a , () , super :: super :: super :: super :: super :: super :: super :: Rule , super :: Rule :: r#a . cvt_into () . cvt_into () . cvt_into () , super :: super :: super :: super :: super :: super :: super :: super :: super :: generics :: Sequence2 :: < super :: super :: super :: super :: super :: super :: super :: super :: super :: generics :: Str :: < super :: super :: super :: super :: super :: super :: super :: super :: super :: wrapper :: W0 > , :: pest3_core :: typed :: template :: Empty , :: pest3_core :: std :: Option :: < super :: super :: super :: super :: super :: super :: super :: super :: super :: generics :: Str :: < super :: super :: super :: super :: super :: super :: super :: super :: super :: wrapper :: W0 > > , __OptionalTrivia :: < 'i > , > , :: pest3_core :: std :: Box < super :: super :: super :: super :: super :: super :: super :: super :: super :: generics :: Sequence2 :: < super :: super :: super :: super :: super :: super :: super :: super :: super :: generics :: Str :: < super :: super :: super :: super :: super :: super :: super :: super :: super :: wrapper :: W0 > , :: pest3_core :: typed :: template :: Empty , :: pest3_core :: std :: Option :: < super :: super :: super :: super :: super :: super :: super :: super :: super :: generics :: Str :: < super :: super :: super :: super :: super :: super :: super :: super :: super :: wrapper :: W0 > > , __OptionalTrivia :: < 'i > , > > ,) ;
                                    #[allow(unused_imports)]
                                    use pest3_core::typed::SubRule as _;
                                    :: pest3_core :: typed :: full_rule_struct ! (r#a , () , super :: super :: super :: super :: super :: super :: super :: super :: super :: Rule , super :: Rule :: r#a . cvt_into () . cvt_into () . cvt_into () . cvt_into () , super :: super :: super :: super :: super :: super :: super :: super :: super :: generics :: Sequence2 :: < super :: super :: super :: super :: super :: super :: super :: super :: super :: generics :: Str :: < super :: super :: super :: super :: super :: super :: super :: super :: super :: wrapper :: W0 > , :: pest3_core :: typed :: template :: Empty , :: pest3_core :: std :: Option :: < super :: super :: super :: super :: super :: super :: super :: super :: super :: generics :: Str :: < super :: super :: super :: super :: super :: super :: super :: super :: super :: wrapper :: W0 > > , __OptionalTrivia :: < 'i > , > , :: pest3_core :: std :: Box < super :: super :: super :: super :: super :: super :: super :: super :: super :: generics :: Sequence2 :: < super :: super :: super :: super :: super :: super :: super :: super :: super :: generics :: Str :: < super :: super :: super :: super :: super :: super :: super :: super :: super :: wrapper :: W0 > , :: pest3_core :: typed :: template :: Empty , :: pest3_core :: std :: Option :: < super :: super :: super :: super :: super :: super :: super :: super :: super :: generics :: Str :: < super :: super :: super :: super :: super :: super :: super :: super :: super :: wrapper :: W0 > > , __OptionalTrivia :: < 'i > , > > ,) ;
                                    #[allow(non_camel_case_types)]
                                    impl<'i> ::pest3_core::typed::PairContainer<super::Rule> for r#a<'i> {
                                        fn for_each_child_pair(
                                            &self,
                                            f: &mut impl ::pest3_core::std::FnMut(
                                                ::pest3_core::token::Pair<super::Rule>,
                                            ),
                                        ) {
                                            self.content.for_self_or_for_each_child_pair(f)
                                        }
                                        fn for_self_or_for_each_child_pair(
                                            &self,
                                            f: &mut impl ::pest3_core::std::FnMut(
                                                ::pest3_core::token::Pair<super::Rule>,
                                            ),
                                        ) {
                                            use pest3_core::typed::PairTree;
                                            f(self.as_pair_tree())
                                        }
                                    }
                                    #[allow(non_camel_case_types)]
                                    impl<'i> ::pest3_core::typed::PairTree<super::Rule> for r#a<'i> {
                                        fn get_rule() -> super::Rule {
                                            #[allow(unused_imports)]
                                            use pest3_core::typed::SubRule as _;
                                            super::Rule::r#a
                                        }
                                        fn get_span(
                                            &self,
                                        ) -> (::pest3_core::std::usize, ::pest3_core::std::usize)
                                        {
                                            (self.span.start(), self.span.end())
                                        }
                                    }
                                    #[allow(non_camel_case_types)]
                                    impl<'i>
                                        ::pest3_core::typed::PairContainer<
                                            super::super::super::Rule,
                                        > for r#a<'i>
                                    {
                                        fn for_each_child_pair(
                                            &self,
                                            f: &mut impl ::pest3_core::std::FnMut(
                                                ::pest3_core::token::Pair<super::super::super::Rule>,
                                            ),
                                        ) {
                                            self.content.for_self_or_for_each_child_pair(f)
                                        }
                                        fn for_self_or_for_each_child_pair(
                                            &self,
                                            f: &mut impl ::pest3_core::std::FnMut(
                                                ::pest3_core::token::Pair<super::super::super::Rule>,
                                            ),
                                        ) {
                                            use pest3_core::typed::PairTree;
                                            f(self.as_pair_tree())
                                        }
                                    }
                                    #[allow(non_camel_case_types)]
                                    impl<'i>
                                        ::pest3_core::typed::PairTree<super::super::super::Rule>
                                        for r#a<'i>
                                    {
                                        fn get_rule() -> super::super::super::Rule {
                                            #[allow(unused_imports)]
                                            use pest3_core::typed::SubRule as _;
                                            super::Rule::r#a.cvt_into()
                                        }
                                        fn get_span(
                                            &self,
                                        ) -> (::pest3_core::std::usize, ::pest3_core::std::usize)
                                        {
                                            (self.span.start(), self.span.end())
                                        }
                                    }
                                    #[allow(non_camel_case_types)]
                                    impl<'i>
                                        ::pest3_core::typed::PairContainer<
                                            super::super::super::super::super::Rule,
                                        > for r#a<'i>
                                    {
                                        fn for_each_child_pair(
                                            &self,
                                            f: &mut impl ::pest3_core::std::FnMut(
                                                ::pest3_core::token::Pair<
                                                    super::super::super::super::super::Rule,
                                                >,
                                            ),
                                        ) {
                                            self.content.for_self_or_for_each_child_pair(f)
                                        }
                                        fn for_self_or_for_each_child_pair(
                                            &self,
                                            f: &mut impl ::pest3_core::std::FnMut(
                                                ::pest3_core::token::Pair<
                                                    super::super::super::super::super::Rule,
                                                >,
                                            ),
                                        ) {
                                            use pest3_core::typed::PairTree;
                                            f(self.as_pair_tree())
                                        }
                                    }
                                    #[allow(non_camel_case_types)]
                                    impl<'i>
                                        ::pest3_core::typed::PairTree<
                                            super::super::super::super::super::Rule,
                                        > for r#a<'i>
                                    {
                                        fn get_rule() -> super::super::super::super::super::Rule {
                                            #[allow(unused_imports)]
                                            use pest3_core::typed::SubRule as _;
                                            super::Rule::r#a.cvt_into().cvt_into()
                                        }
                                        fn get_span(
                                            &self,
                                        ) -> (::pest3_core::std::usize, ::pest3_core::std::usize)
                                        {
                                            (self.span.start(), self.span.end())
                                        }
                                    }
                                    #[allow(non_camel_case_types)]
                                    impl<'i>
                                        ::pest3_core::typed::PairContainer<
                                            super::super::super::super::super::super::super::Rule,
                                        > for r#a<'i>
                                    {
                                        fn for_each_child_pair(
                                            &self,
                                            f : & mut impl :: pest3_core :: std :: FnMut (:: pest3_core :: token :: Pair < super :: super :: super :: super :: super :: super :: super :: Rule >),
                                        ) {
                                            self.content.for_self_or_for_each_child_pair(f)
                                        }
                                        fn for_self_or_for_each_child_pair(
                                            &self,
                                            f : & mut impl :: pest3_core :: std :: FnMut (:: pest3_core :: token :: Pair < super :: super :: super :: super :: super :: super :: super :: Rule >),
                                        ) {
                                            use pest3_core::typed::PairTree;
                                            f(self.as_pair_tree())
                                        }
                                    }
                                    #[allow(non_camel_case_types)]
                                    impl<'i>
                                        ::pest3_core::typed::PairTree<
                                            super::super::super::super::super::super::super::Rule,
                                        > for r#a<'i>
                                    {
                                        fn get_rule(
                                        ) -> super::super::super::super::super::super::super::Rule
                                        {
                                            #[allow(unused_imports)]
                                            use pest3_core::typed::SubRule as _;
                                            super::Rule::r#a.cvt_into().cvt_into().cvt_into()
                                        }
                                        fn get_span(
                                            &self,
                                        ) -> (::pest3_core::std::usize, ::pest3_core::std::usize)
                                        {
                                            (self.span.start(), self.span.end())
                                        }
                                    }
                                    #[allow(non_camel_case_types)]
                                    impl < 'i , > :: pest3_core :: typed :: PairContainer < super :: super :: super :: super :: super :: super :: super :: super :: super :: Rule > for r#a < 'i , > { fn for_each_child_pair (& self , f : & mut impl :: pest3_core :: std :: FnMut (:: pest3_core :: token :: Pair < super :: super :: super :: super :: super :: super :: super :: super :: super :: Rule >)) { self . content . for_self_or_for_each_child_pair (f) } fn for_self_or_for_each_child_pair (& self , f : & mut impl :: pest3_core :: std :: FnMut (:: pest3_core :: token :: Pair < super :: super :: super :: super :: super :: super :: super :: super :: super :: Rule >)) { use :: pest3_core :: typed :: PairTree ; f (self . as_pair_tree ()) } }
                                    #[allow(non_camel_case_types)]
                                    impl < 'i , > :: pest3_core :: typed :: PairTree < super :: super :: super :: super :: super :: super :: super :: super :: super :: Rule > for r#a < 'i , > { fn get_rule () -> super :: super :: super :: super :: super :: super :: super :: super :: super :: Rule { # [allow (unused_imports)] use :: pest3_core :: typed :: SubRule as _ ; super :: Rule :: r#a . cvt_into () . cvt_into () . cvt_into () . cvt_into () } fn get_span (& self) -> (:: pest3_core :: std :: usize , :: pest3_core :: std :: usize) { (self . span . start () , self . span . end ()) } }
                                }
                            }
                            impl ::pest3_core::typed::SubRule for a::Rule {
                                type Super = super::Rule;
                                fn cvt_into(self) -> Self::Super {
                                    super::Rule::a(self)
                                }
                            }
                            pub mod b {
                                #[allow(
                                    dead_code,
                                    missing_docs,
                                    non_camel_case_types,
                                    clippy::upper_case_acronyms
                                )]
                                #[derive(
                                    Clone, Copy, Debug, Eq, Hash, Ord, PartialEq, PartialOrd,
                                )]
                                pub enum Rule {
                                    EOI,
                                    r#b,
                                }
                                impl ::pest3_core::typed::RuleType for Rule {
                                    const EOI: Self = Rule::EOI;
                                }
                                #[doc = "Definitions of statically typed nodes generated by pest-generator."]
                                pub mod rules {
                                    pub type __OptionalTrivia<'i> =
                                        ::pest3_core::typed::template::Empty;
                                    pub type __MandatoryTrivia < 'i > = super :: super :: super :: super :: super :: super :: super :: super :: super :: generics :: RepOnce :: < super :: super :: super :: super :: super :: super :: super :: super :: super :: generics :: Str :: < super :: super :: super :: super :: super :: super :: super :: super :: super :: wrapper :: W3 > , :: pest3_core :: typed :: template :: Empty > ;
                                    #[doc = "Generated for rule `b`. Grammar: `(\"b\" ^ \"b\"?)`."]
                                    #[derive(Clone, Debug, Eq, PartialEq)]
                                    #[allow(non_camel_case_types)]
                                    pub struct r#b < 'i , > { # [doc = r" Matched structure."] pub content : :: pest3_core :: std :: Box < super :: super :: super :: super :: super :: super :: super :: super :: super :: generics :: Sequence2 :: < super :: super :: super :: super :: super :: super :: super :: super :: super :: generics :: Str :: < super :: super :: super :: super :: super :: super :: super :: super :: super :: wrapper :: W2 > , :: pest3_core :: typed :: template :: Empty , :: pest3_core :: std :: Option :: < super :: super :: super :: super :: super :: super :: super :: super :: super :: generics :: Str :: < super :: super :: super :: super :: super :: super :: super :: super :: super :: wrapper :: W2 > > , __MandatoryTrivia :: < 'i > , > > , # [doc = r" Matched span."] pub span : :: pest3_core :: Span < 'i > , }
                                    #[allow(non_camel_case_types)]
                                    impl<'i> ::pest3_core::typed::wrapper::Rule for r#b<'i> {
                                        type Rule = super::Rule;
                                        const RULE: super::Rule = super::Rule::r#b;
                                    }
                                    #[allow(non_camel_case_types)]
                                    impl<'i> r#b<'i> {}
                                    #[allow(unused_imports)]
                                    use pest3_core::typed::SubRule as _;
                                    :: pest3_core :: typed :: full_rule_struct ! (r#b , () , super :: Rule , super :: Rule :: r#b , super :: super :: super :: super :: super :: super :: super :: super :: super :: generics :: Sequence2 :: < super :: super :: super :: super :: super :: super :: super :: super :: super :: generics :: Str :: < super :: super :: super :: super :: super :: super :: super :: super :: super :: wrapper :: W2 > , :: pest3_core :: typed :: template :: Empty , :: pest3_core :: std :: Option :: < super :: super :: super :: super :: super :: super :: super :: super :: super :: generics :: Str :: < super :: super :: super :: super :: super :: super :: super :: super :: super :: wrapper :: W2 > > , __MandatoryTrivia :: < 'i > , > , :: pest3_core :: std :: Box < super :: super :: super :: super :: super :: super :: super :: super :: super :: generics :: Sequence2 :: < super :: super :: super :: super :: super :: super :: super :: super :: super :: generics :: Str :: < super :: super :: super :: super :: super :: super :: super :: super :: super :: wrapper :: W2 > , :: pest3_core :: typed :: template :: Empty , :: pest3_core :: std :: Option :: < super :: super :: super :: super :: super :: super :: super :: super :: super :: generics :: Str :: < super :: super :: super :: super :: super :: super :: super :: super :: super :: wrapper :: W2 > > , __MandatoryTrivia :: < 'i > , > > ,) ;
                                    #[allow(unused_imports)]
                                    use pest3_core::typed::SubRule as _;
                                    :: pest3_core :: typed :: full_rule_struct ! (r#b , () , super :: super :: super :: Rule , super :: Rule :: r#b . cvt_into () , super :: super :: super :: super :: super :: super :: super :: super :: super :: generics :: Sequence2 :: < super :: super :: super :: super :: super :: super :: super :: super :: super :: generics :: Str :: < super :: super :: super :: super :: super :: super :: super :: super :: super :: wrapper :: W2 > , :: pest3_core :: typed :: template :: Empty , :: pest3_core :: std :: Option :: < super :: super :: super :: super :: super :: super :: super :: super :: super :: generics :: Str :: < super :: super :: super :: super :: super :: super :: super :: super :: super :: wrapper :: W2 > > , __MandatoryTrivia :: < 'i > , > , :: pest3_core :: std :: Box < super :: super :: super :: super :: super :: super :: super :: super :: super :: generics :: Sequence2 :: < super :: super :: super :: super :: super :: super :: super :: super :: super :: generics :: Str :: < super :: super :: super :: super :: super :: super :: super :: super :: super :: wrapper :: W2 > , :: pest3_core :: typed :: template :: Empty , :: pest3_core :: std :: Option :: < super :: super :: super :: super :: super :: super :: super :: super :: super :: generics :: Str :: < super :: super :: super :: super :: super :: super :: super :: super :: super :: wrapper :: W2 > > , __MandatoryTrivia :: < 'i > , > > ,) ;
                                    #[allow(unused_imports)]
                                    use pest3_core::typed::SubRule as _;
                                    :: pest3_core :: typed :: full_rule_struct ! (r#b , () , super :: super :: super :: super :: super :: Rule , super :: Rule :: r#b . cvt_into () . cvt_into () , super :: super :: super :: super :: super :: super :: super :: super :: super :: generics :: Sequence2 :: < super :: super :: super :: super :: super :: super :: super :: super :: super :: generics :: Str :: < super :: super :: super :: super :: super :: super :: super :: super :: super :: wrapper :: W2 > , :: pest3_core :: typed :: template :: Empty , :: pest3_core :: std :: Option :: < super :: super :: super :: super :: super :: super :: super :: super :: super :: generics :: Str :: < super :: super :: super :: super :: super :: super :: super :: super :: super :: wrapper :: W2 > > , __MandatoryTrivia :: < 'i > , > , :: pest3_core :: std :: Box < super :: super :: super :: super :: super :: super :: super :: super :: super :: generics :: Sequence2 :: < super :: super :: super :: super :: super :: super :: super :: super :: super :: generics :: Str :: < super :: super :: super :: super :: super :: super :: super :: super :: super :: wrapper :: W2 > , :: pest3_core :: typed :: template :: Empty , :: pest3_core :: std :: Option :: < super :: super :: super :: super :: super :: super :: super :: super :: super :: generics :: Str :: < super :: super :: super :: super :: super :: super :: super :: super :: super :: wrapper :: W2 > > , __MandatoryTrivia :: < 'i > , > > ,) ;
                                    #[allow(unused_imports)]
                                    use pest3_core::typed::SubRule as _;
                                    :: pest3_core :: typed :: full_rule_struct ! (r#b , () , super :: super :: super :: super :: super :: super :: super :: Rule , super :: Rule :: r#b . cvt_into () . cvt_into () . cvt_into () , super :: super :: super :: super :: super :: super :: super :: super :: super :: generics :: Sequence2 :: < super :: super :: super :: super :: super :: super :: super :: super :: super :: generics :: Str :: < super :: super :: super :: super :: super :: super :: super :: super :: super :: wrapper :: W2 > , :: pest3_core :: typed :: template :: Empty , :: pest3_core :: std :: Option :: < super :: super :: super :: super :: super :: super :: super :: super :: super :: generics :: Str :: < super :: super :: super :: super :: super :: super :: super :: super :: super :: wrapper :: W2 > > , __MandatoryTrivia :: < 'i > , > , :: pest3_core :: std :: Box < super :: super :: super :: super :: super :: super :: super :: super :: super :: generics :: Sequence2 :: < super :: super :: super :: super :: super :: super :: super :: super :: super :: generics :: Str :: < super :: super :: super :: super :: super :: super :: super :: super :: super :: wrapper :: W2 > , :: pest3_core :: typed :: template :: Empty , :: pest3_core :: std :: Option :: < super :: super :: super :: super :: super :: super :: super :: super :: super :: generics :: Str :: < super :: super :: super :: super :: super :: super :: super :: super :: super :: wrapper :: W2 > > , __MandatoryTrivia :: < 'i > , > > ,) ;
                                    #[allow(unused_imports)]
                                    use pest3_core::typed::SubRule as _;
                                    :: pest3_core :: typed :: full_rule_struct ! (r#b , () , super :: super :: super :: super :: super :: super :: super :: super :: super :: Rule , super :: Rule :: r#b . cvt_into () . cvt_into () . cvt_into () . cvt_into () , super :: super :: super :: super :: super :: super :: super :: super :: super :: generics :: Sequence2 :: < super :: super :: super :: super :: super :: super :: super :: super :: super :: generics :: Str :: < super :: super :: super :: super :: super :: super :: super :: super :: super :: wrapper :: W2 > , :: pest3_core :: typed :: template :: Empty , :: pest3_core :: std :: Option :: < super :: super :: super :: super :: super :: super :: super :: super :: super :: generics :: Str :: < super :: super :: super :: super :: super :: super :: super :: super :: super :: wrapper :: W2 > > , __MandatoryTrivia :: < 'i > , > , :: pest3_core :: std :: Box < super :: super :: super :: super :: super :: super :: super :: super :: super :: generics :: Sequence2 :: < super :: super :: super :: super :: super :: super :: super :: super :: super :: generics :: Str :: < super :: super :: super :: super :: super :: super :: super :: super :: super :: wrapper :: W2 > , :: pest3_core :: typed :: template :: Empty , :: pest3_core :: std :: Option :: < super :: super :: super :: super :: super :: super :: super :: super :: super :: generics :: Str :: < super :: super :: super :: super :: super :: super :: super :: super :: super :: wrapper :: W2 > > , __MandatoryTrivia :: < 'i > , > > ,) ;
                                    #[allow(non_camel_case_types)]
                                    impl<'i> ::pest3_core::typed::PairContainer<super::Rule> for r#b<'i> {
                                        fn for_each_child_pair(
                                            &self,
                                            f: &mut impl ::pest3_core::std::FnMut(
                                                ::pest3_core::token::Pair<super::Rule>,
                                            ),
                                        ) {
                                            self.content.for_self_or_for_each_child_pair(f)
                                        }
                                        fn for_self_or_for_each_child_pair(
                                            &self,
                                            f: &mut impl ::pest3_core::std::FnMut(
                                                ::pest3_core::token::Pair<super::Rule>,
                                            ),
                                        ) {
                                            use pest3_core::typed::PairTree;
                                            f(self.as_pair_tree())
                                        }
                                    }
                                    #[allow(non_camel_case_types)]
                                    impl<'i> ::pest3_core::typed::PairTree<super::Rule> for r#b<'i> {
                                        fn get_rule() -> super::Rule {
                                            #[allow(unused_imports)]
                                            use pest3_core::typed::SubRule as _;
                                            super::Rule::r#b
                                        }
                                        fn get_span(
                                            &self,
                                        ) -> (::pest3_core::std::usize, ::pest3_core::std::usize)
                                        {
                                            (self.span.start(), self.span.end())
                                        }
                                    }
                                    #[allow(non_camel_case_types)]
                                    impl<'i>
                                        ::pest3_core::typed::PairContainer<
                                            super::super::super::Rule,
                                        > for r#b<'i>
                                    {
                                        fn for_each_child_pair(
                                            &self,
                                            f: &mut impl ::pest3_core::std::FnMut(
                                                ::pest3_core::token::Pair<super::super::super::Rule>,
                                            ),
                                        ) {
                                            self.content.for_self_or_for_each_child_pair(f)
                                        }
                                        fn for_self_or_for_each_child_pair(
                                            &self,
                                            f: &mut impl ::pest3_core::std::FnMut(
                                                ::pest3_core::token::Pair<super::super::super::Rule>,
                                            ),
                                        ) {
                                            use pest3_core::typed::PairTree;
                                            f(self.as_pair_tree())
                                        }
                                    }
                                    #[allow(non_camel_case_types)]
                                    impl<'i>
                                        ::pest3_core::typed::PairTree<super::super::super::Rule>
                                        for r#b<'i>
                                    {
                                        fn get_rule() -> super::super::super::Rule {
                                            #[allow(unused_imports)]
                                            use pest3_core::typed::SubRule as _;
                                            super::Rule::r#b.cvt_into()
                                        }
                                        fn get_span(
                                            &self,
                                        ) -> (::pest3_core::std::usize, ::pest3_core::std::usize)
                                        {
                                            (self.span.start(), self.span.end())
                                        }
                                    }
                                    #[allow(non_camel_case_types)]
                                    impl<'i>
                                        ::pest3_core::typed::PairContainer<
                                            super::super::super::super::super::Rule,
                                        > for r#b<'i>
                                    {
                                        fn for_each_child_pair(
                                            &self,
                                            f: &mut impl ::pest3_core::std::FnMut(
                                                ::pest3_core::token::Pair<
                                                    super::super::super::super::super::Rule,
                                                >,
                                            ),
                                        ) {
                                            self.content.for_self_or_for_each_child_pair(f)
                                        }
                                        fn for_self_or_for_each_child_pair(
                                            &self,
                                            f: &mut impl ::pest3_core::std::FnMut(
                                                ::pest3_core::token::Pair<
                                                    super::super::super::super::super::Rule,
                                                >,
                                            ),
                                        ) {
                                            use pest3_core::typed::PairTree;
                                            f(self.as_pair_tree())
                                        }
                                    }
                                    #[allow(non_camel_case_types)]
                                    impl<'i>
                                        ::pest3_core::typed::PairTree<
                                            super::super::super::super::super::Rule,
                                        > for r#b<'i>
                                    {
                                        fn get_rule() -> super::super::super::super::super::Rule {
                                            #[allow(unused_imports)]
                                            use pest3_core::typed::SubRule as _;
                                            super::Rule::r#b.cvt_into().cvt_into()
                                        }
                                        fn get_span(
                                            &self,
                                        ) -> (::pest3_core::std::usize, ::pest3_core::std::usize)
                                        {
                                            (self.span.start(), self.span.end())
                                        }
                                    }
                                    #[allow(non_camel_case_types)]
                                    impl<'i>
                                        ::pest3_core::typed::PairContainer<
                                            super::super::super::super::super::super::super::Rule,
                                        > for r#b<'i>
                                    {
                                        fn for_each_child_pair(
                                            &self,
                                            f : & mut impl :: pest3_core :: std :: FnMut (:: pest3_core :: token :: Pair < super :: super :: super :: super :: super :: super :: super :: Rule >),
                                        ) {
                                            self.content.for_self_or_for_each_child_pair(f)
                                        }
                                        fn for_self_or_for_each_child_pair(
                                            &self,
                                            f : & mut impl :: pest3_core :: std :: FnMut (:: pest3_core :: token :: Pair < super :: super :: super :: super :: super :: super :: super :: Rule >),
                                        ) {
                                            use pest3_core::typed::PairTree;
                                            f(self.as_pair_tree())
                                        }
                                    }
                                    #[allow(non_camel_case_types)]
                                    impl<'i>
                                        ::pest3_core::typed::PairTree<
                                            super::super::super::super::super::super::super::Rule,
                                        > for r#b<'i>
                                    {
                                        fn get_rule(
                                        ) -> super::super::super::super::super::super::super::Rule
                                        {
                                            #[allow(unused_imports)]
                                            use pest3_core::typed::SubRule as _;
                                            super::Rule::r#b.cvt_into().cvt_into().cvt_into()
                                        }
                                        fn get_span(
                                            &self,
                                        ) -> (::pest3_core::std::usize, ::pest3_core::std::usize)
                                        {
                                            (self.span.start(), self.span.end())
                                        }
                                    }
                                    #[allow(non_camel_case_types)]
                                    impl < 'i , > :: pest3_core :: typed :: PairContainer < super :: super :: super :: super :: super :: super :: super :: super :: super :: Rule > for r#b < 'i , > { fn for_each_child_pair (& self , f : & mut impl :: pest3_core :: std :: FnMut (:: pest3_core :: token :: Pair < super :: super :: super :: super :: super :: super :: super :: super :: super :: Rule >)) { self . content . for_self_or_for_each_child_pair (f) } fn for_self_or_for_each_child_pair (& self , f : & mut impl :: pest3_core :: std :: FnMut (:: pest3_core :: token :: Pair < super :: super :: super :: super :: super :: super :: super :: super :: super :: Rule >)) { use :: pest3_core :: typed :: PairTree ; f (self . as_pair_tree ()) } }
                                    #[allow(non_camel_case_types)]
                                    impl < 'i , > :: pest3_core :: typed :: PairTree < super :: super :: super :: super :: super :: super :: super :: super :: super :: Rule > for r#b < 'i , > { fn get_rule () -> super :: super :: super :: super :: super :: super :: super :: super :: super :: Rule { # [allow (unused_imports)] use :: pest3_core :: typed :: SubRule as _ ; super :: Rule :: r#b . cvt_into () . cvt_into () . cvt_into () . cvt_into () } fn get_span (& self) -> (:: pest3_core :: std :: usize , :: pest3_core :: std :: usize) { (self . span . start () , self . span . end ()) } }
                                }
                            }
                            impl ::pest3_core::typed::SubRule for b::Rule {
                                type Super = super::Rule;
                                fn cvt_into(self) -> Self::Super {
                                    super::Rule::b(self)
                                }
                            }
                            #[doc = "Generated for rule `c`. Grammar: `(a::a ~ b::b)`."]
                            #[derive(Clone, Debug, Eq, PartialEq)]
                            #[allow(non_camel_case_types)]
                            pub struct r#c < 'i , > { # [doc = r" Matched structure."] pub content : :: pest3_core :: std :: Box < super :: super :: super :: super :: super :: super :: super :: generics :: Sequence2 :: < a :: rules :: r#a :: < 'i > , :: pest3_core :: typed :: template :: Empty , b :: rules :: r#b :: < 'i > , __OptionalTrivia :: < 'i > , > > , # [doc = r" Matched span."] pub span : :: pest3_core :: Span < 'i > , }
                            #[allow(non_camel_case_types)]
                            impl<'i> ::pest3_core::typed::wrapper::Rule for r#c<'i> {
                                type Rule = super::Rule;
                                const RULE: super::Rule = super::Rule::r#c;
                            }
                            #[allow(non_camel_case_types)]
                            impl<'i> r#c<'i> {
                                #[doc = "A helper function to access [`a`]."]
                                #[allow(non_snake_case)]
                                pub fn r#a<'s>(&'s self) -> &'s a::rules::r#a<'i> {
                                    let res = &*self.content;
                                    {
                                        let res = &res.field_0;
                                        res
                                    }
                                }
                                #[doc = "A helper function to access [`b`]."]
                                #[allow(non_snake_case)]
                                pub fn r#b<'s>(&'s self) -> &'s b::rules::r#b<'i> {
                                    let res = &*self.content;
                                    {
                                        let res = &res.field_1;
                                        res
                                    }
                                }
                            }
                            #[allow(unused_imports)]
                            use pest3_core::typed::SubRule as _;
                            :: pest3_core :: typed :: full_rule_struct ! (r#c , () , super :: Rule , super :: Rule :: r#c , super :: super :: super :: super :: super :: super :: super :: generics :: Sequence2 :: < a :: rules :: r#a :: < 'i > , :: pest3_core :: typed :: template :: Empty , b :: rules :: r#b :: < 'i > , __OptionalTrivia :: < 'i > , > , :: pest3_core :: std :: Box < super :: super :: super :: super :: super :: super :: super :: generics :: Sequence2 :: < a :: rules :: r#a :: < 'i > , :: pest3_core :: typed :: template :: Empty , b :: rules :: r#b :: < 'i > , __OptionalTrivia :: < 'i > , > > ,) ;
                            #[allow(unused_imports)]
                            use pest3_core::typed::SubRule as _;
                            :: pest3_core :: typed :: full_rule_struct ! (r#c , () , super :: super :: super :: Rule , super :: Rule :: r#c . cvt_into () , super :: super :: super :: super :: super :: super :: super :: generics :: Sequence2 :: < a :: rules :: r#a :: < 'i > , :: pest3_core :: typed :: template :: Empty , b :: rules :: r#b :: < 'i > , __OptionalTrivia :: < 'i > , > , :: pest3_core :: std :: Box < super :: super :: super :: super :: super :: super :: super :: generics :: Sequence2 :: < a :: rules :: r#a :: < 'i > , :: pest3_core :: typed :: template :: Empty , b :: rules :: r#b :: < 'i > , __OptionalTrivia :: < 'i > , > > ,) ;
                            #[allow(unused_imports)]
                            use pest3_core::typed::SubRule as _;
                            :: pest3_core :: typed :: full_rule_struct ! (r#c , () , super :: super :: super :: super :: super :: Rule , super :: Rule :: r#c . cvt_into () . cvt_into () , super :: super :: super :: super :: super :: super :: super :: generics :: Sequence2 :: < a :: rules :: r#a :: < 'i > , :: pest3_core :: typed :: template :: Empty , b :: rules :: r#b :: < 'i > , __OptionalTrivia :: < 'i > , > , :: pest3_core :: std :: Box < super :: super :: super :: super :: super :: super :: super :: generics :: Sequence2 :: < a :: rules :: r#a :: < 'i > , :: pest3_core :: typed :: template :: Empty , b :: rules :: r#b :: < 'i > , __OptionalTrivia :: < 'i > , > > ,) ;
                            #[allow(unused_imports)]
                            use pest3_core::typed::SubRule as _;
                            :: pest3_core :: typed :: full_rule_struct ! (r#c , () , super :: super :: super :: super :: super :: super :: super :: Rule , super :: Rule :: r#c . cvt_into () . cvt_into () . cvt_into () , super :: super :: super :: super :: super :: super :: super :: generics :: Sequence2 :: < a :: rules :: r#a :: < 'i > , :: pest3_core :: typed :: template :: Empty , b :: rules :: r#b :: < 'i > , __OptionalTrivia :: < 'i > , > , :: pest3_core :: std :: Box < super :: super :: super :: super :: super :: super :: super :: generics :: Sequence2 :: < a :: rules :: r#a :: < 'i > , :: pest3_core :: typed :: template :: Empty , b :: rules :: r#b :: < 'i > , __OptionalTrivia :: < 'i > , > > ,) ;
                            #[allow(non_camel_case_types)]
                            impl<'i> ::pest3_core::typed::PairContainer<super::Rule> for r#c<'i> {
                                fn for_each_child_pair(
                                    &self,
                                    f: &mut impl ::pest3_core::std::FnMut(
                                        ::pest3_core::token::Pair<super::Rule>,
                                    ),
                                ) {
                                    self.content.for_self_or_for_each_child_pair(f)
                                }
                                fn for_self_or_for_each_child_pair(
                                    &self,
                                    f: &mut impl ::pest3_core::std::FnMut(
                                        ::pest3_core::token::Pair<super::Rule>,
                                    ),
                                ) {
                                    use pest3_core::typed::PairTree;
                                    f(self.as_pair_tree())
                                }
                            }
                            #[allow(non_camel_case_types)]
                            impl<'i> ::pest3_core::typed::PairTree<super::Rule> for r#c<'i> {
                                fn get_rule() -> super::Rule {
                                    #[allow(unused_imports)]
                                    use pest3_core::typed::SubRule as _;
                                    super::Rule::r#c
                                }
                                fn get_span(
                                    &self,
                                ) -> (::pest3_core::std::usize, ::pest3_core::std::usize)
                                {
                                    (self.span.start(), self.span.end())
                                }
                            }
                            #[allow(non_camel_case_types)]
                            impl<'i> ::pest3_core::typed::PairContainer<super::super::super::Rule> for r#c<'i> {
                                fn for_each_child_pair(
                                    &self,
                                    f: &mut impl ::pest3_core::std::FnMut(
                                        ::pest3_core::token::Pair<super::super::super::Rule>,
                                    ),
                                ) {
                                    self.content.for_self_or_for_each_child_pair(f)
                                }
                                fn for_self_or_for_each_child_pair(
                                    &self,
                                    f: &mut impl ::pest3_core::std::FnMut(
                                        ::pest3_core::token::Pair<super::super::super::Rule>,
                                    ),
                                ) {
                                    use pest3_core::typed::PairTree;
                                    f(self.as_pair_tree())
                                }
                            }
                            #[allow(non_camel_case_types)]
                            impl<'i> ::pest3_core::typed::PairTree<super::super::super::Rule> for r#c<'i> {
                                fn get_rule() -> super::super::super::Rule {
                                    #[allow(unused_imports)]
                                    use pest3_core::typed::SubRule as _;
                                    super::Rule::r#c.cvt_into()
                                }
                                fn get_span(
                                    &self,
                                ) -> (::pest3_core::std::usize, ::pest3_core::std::usize)
                                {
                                    (self.span.start(), self.span.end())
                                }
                            }
                            #[allow(non_camel_case_types)]
                            impl<'i>
                                ::pest3_core::typed::PairContainer<
                                    super::super::super::super::super::Rule,
                                > for r#c<'i>
                            {
                                fn for_each_child_pair(
                                    &self,
                                    f: &mut impl ::pest3_core::std::FnMut(
                                        ::pest3_core::token::Pair<
                                            super::super::super::super::super::Rule,
                                        >,
                                    ),
                                ) {
                                    self.content.for_self_or_for_each_child_pair(f)
                                }
                                fn for_self_or_for_each_child_pair(
                                    &self,
                                    f: &mut impl ::pest3_core::std::FnMut(
                                        ::pest3_core::token::Pair<
                                            super::super::super::super::super::Rule,
                                        >,
                                    ),
                                ) {
                                    use pest3_core::typed::PairTree;
                                    f(self.as_pair_tree())
                                }
                            }
                            #[allow(non_camel_case_types)]
                            impl<'i>
                                ::pest3_core::typed::PairTree<
                                    super::super::super::super::super::Rule,
                                > for r#c<'i>
                            {
                                fn get_rule() -> super::super::super::super::super::Rule {
                                    #[allow(unused_imports)]
                                    use pest3_core::typed::SubRule as _;
                                    super::Rule::r#c.cvt_into().cvt_into()
                                }
                                fn get_span(
                                    &self,
                                ) -> (::pest3_core::std::usize, ::pest3_core::std::usize)
                                {
                                    (self.span.start(), self.span.end())
                                }
                            }
                            #[allow(non_camel_case_types)]
                            impl<'i>
                                ::pest3_core::typed::PairContainer<
                                    super::super::super::super::super::super::super::Rule,
                                > for r#c<'i>
                            {
                                fn for_each_child_pair(
                                    &self,
                                    f: &mut impl ::pest3_core::std::FnMut(
                                        ::pest3_core::token::Pair<
                                            super::super::super::super::super::super::super::Rule,
                                        >,
                                    ),
                                ) {
                                    self.content.for_self_or_for_each_child_pair(f)
                                }
                                fn for_self_or_for_each_child_pair(
                                    &self,
                                    f: &mut impl ::pest3_core::std::FnMut(
                                        ::pest3_core::token::Pair<
                                            super::super::super::super::super::super::super::Rule,
                                        >,
                                    ),
                                ) {
                                    use pest3_core::typed::PairTree;
                                    f(self.as_pair_tree())
                                }
                            }
                            #[allow(non_camel_case_types)]
                            impl<'i>
                                ::pest3_core::typed::PairTree<
                                    super::super::super::super::super::super::super::Rule,
                                > for r#c<'i>
                            {
                                fn get_rule(
                                ) -> super::super::super::super::super::super::super::Rule
                                {
                                    #[allow(unused_imports)]
                                    use pest3_core::typed::SubRule as _;
                                    super::Rule::r#c.cvt_into().cvt_into().cvt_into()
                                }
                                fn get_span(
                                    &self,
                                ) -> (::pest3_core::std::usize, ::pest3_core::std::usize)
                                {
                                    (self.span.start(), self.span.end())
                                }
                            }
                        }
                    }
                    impl ::pest3_core::typed::SubRule for c::Rule {
                        type Super = super::Rule;
                        fn cvt_into(self) -> Self::Super {
                            super::Rule::c(self)
                        }
                    }
                    #[doc = "Generated for rule `d`. Grammar: `(a::a - c::c)`."]
                    #[derive(Clone, Debug, Eq, PartialEq)]
                    #[allow(non_camel_case_types)]
                    pub struct r#d<'i> {
                        #[doc = r" Matched structure."]
                        pub content: ::pest3_core::std::Box<
                            super::super::super::super::super::generics::Sequence2<
                                a::rules::r#a<'i>,
                                ::pest3_core::typed::template::Empty,
                                c::rules::r#c<'i>,
                                ::pest3_core::typed::template::Empty,
                            >,
                        >,
                        #[doc = r" Matched span."]
                        pub span: ::pest3_core::Span<'i>,
                    }
                    #[allow(non_camel_case_types)]
                    impl<'i> ::pest3_core::typed::wrapper::Rule for r#d<'i> {
                        type Rule = super::Rule;
                        const RULE: super::Rule = super::Rule::r#d;
                    }
                    #[allow(non_camel_case_types)]
                    impl<'i> r#d<'i> {
                        #[doc = "A helper function to access [`a`]."]
                        #[allow(non_snake_case)]
                        pub fn r#a<'s>(&'s self) -> &'s a::rules::r#a<'i> {
                            let res = &*self.content;
                            {
                                let res = &res.field_0;
                                res
                            }
                        }
                        #[doc = "A helper function to access [`c`]."]
                        #[allow(non_snake_case)]
                        pub fn r#c<'s>(&'s self) -> &'s c::rules::r#c<'i> {
                            let res = &*self.content;
                            {
                                let res = &res.field_1;
                                res
                            }
                        }
                    }
                    #[allow(unused_imports)]
                    use pest3_core::typed::SubRule as _;
                    ::pest3_core::typed::full_rule_struct!(
                        r#d,
                        (),
                        super::Rule,
                        super::Rule::r#d,
                        super::super::super::super::super::generics::Sequence2::<
                            a::rules::r#a::<'i>,
                            ::pest3_core::typed::template::Empty,
                            c::rules::r#c::<'i>,
                            ::pest3_core::typed::template::Empty,
                        >,
                        ::pest3_core::std::Box<
                            super::super::super::super::super::generics::Sequence2::<
                                a::rules::r#a::<'i>,
                                ::pest3_core::typed::template::Empty,
                                c::rules::r#c::<'i>,
                                ::pest3_core::typed::template::Empty,
                            >,
                        >,
                    );
                    #[allow(unused_imports)]
                    use pest3_core::typed::SubRule as _;
                    ::pest3_core::typed::full_rule_struct!(
                        r#d,
                        (),
                        super::super::super::Rule,
                        super::Rule::r#d.cvt_into(),
                        super::super::super::super::super::generics::Sequence2::<
                            a::rules::r#a::<'i>,
                            ::pest3_core::typed::template::Empty,
                            c::rules::r#c::<'i>,
                            ::pest3_core::typed::template::Empty,
                        >,
                        ::pest3_core::std::Box<
                            super::super::super::super::super::generics::Sequence2::<
                                a::rules::r#a::<'i>,
                                ::pest3_core::typed::template::Empty,
                                c::rules::r#c::<'i>,
                                ::pest3_core::typed::template::Empty,
                            >,
                        >,
                    );
                    #[allow(unused_imports)]
                    use pest3_core::typed::SubRule as _;
                    ::pest3_core::typed::full_rule_struct!(
                        r#d,
                        (),
                        super::super::super::super::super::Rule,
                        super::Rule::r#d.cvt_into().cvt_into(),
                        super::super::super::super::super::generics::Sequence2::<
                            a::rules::r#a::<'i>,
                            ::pest3_core::typed::template::Empty,
                            c::rules::r#c::<'i>,
                            ::pest3_core::typed::template::Empty,
                        >,
                        ::pest3_core::std::Box<
                            super::super::super::super::super::generics::Sequence2::<
                                a::rules::r#a::<'i>,
                                ::pest3_core::typed::template::Empty,
                                c::rules::r#c::<'i>,
                                ::pest3_core::typed::template::Empty,
                            >,
                        >,
                    );
                    #[allow(non_camel_case_types)]
                    impl<'i> ::pest3_core::typed::PairContainer<super::Rule> for r#d<'i> {
                        fn for_each_child_pair(
                            &self,
                            f: &mut impl ::pest3_core::std::FnMut(
                                ::pest3_core::token::Pair<super::Rule>,
                            ),
                        ) {
                            self.content.for_self_or_for_each_child_pair(f)
                        }
                        fn for_self_or_for_each_child_pair(
                            &self,
                            f: &mut impl ::pest3_core::std::FnMut(
                                ::pest3_core::token::Pair<super::Rule>,
                            ),
                        ) {
                            use pest3_core::typed::PairTree;
                            f(self.as_pair_tree())
                        }
                    }
                    #[allow(non_camel_case_types)]
                    impl<'i> ::pest3_core::typed::PairTree<super::Rule> for r#d<'i> {
                        fn get_rule() -> super::Rule {
                            #[allow(unused_imports)]
                            use pest3_core::typed::SubRule as _;
                            super::Rule::r#d
                        }
                        fn get_span(&self) -> (::pest3_core::std::usize, ::pest3_core::std::usize) {
                            (self.span.start(), self.span.end())
                        }
                    }
                    #[allow(non_camel_case_types)]
                    impl<'i> ::pest3_core::typed::PairContainer<super::super::super::Rule> for r#d<'i> {
                        fn for_each_child_pair(
                            &self,
                            f: &mut impl ::pest3_core::std::FnMut(
                                ::pest3_core::token::Pair<super::super::super::Rule>,
                            ),
                        ) {
                            self.content.for_self_or_for_each_child_pair(f)
                        }
                        fn for_self_or_for_each_child_pair(
                            &self,
                            f: &mut impl ::pest3_core::std::FnMut(
                                ::pest3_core::token::Pair<super::super::super::Rule>,
                            ),
                        ) {
                            use pest3_core::typed::PairTree;
                            f(self.as_pair_tree())
                        }
                    }
                    #[allow(non_camel_case_types)]
                    impl<'i> ::pest3_core::typed::PairTree<super::super::super::Rule> for r#d<'i> {
                        fn get_rule() -> super::super::super::Rule {
                            #[allow(unused_imports)]
                            use pest3_core::typed::SubRule as _;
                            super::Rule::r#d.cvt_into()
                        }
                        fn get_span(&self) -> (::pest3_core::std::usize, ::pest3_core::std::usize) {
                            (self.span.start(), self.span.end())
                        }
                    }
                    #[allow(non_camel_case_types)]
                    impl<'i>
                        ::pest3_core::typed::PairContainer<super::super::super::super::super::Rule>
                        for r#d<'i>
                    {
                        fn for_each_child_pair(
                            &self,
                            f: &mut impl ::pest3_core::std::FnMut(
                                ::pest3_core::token::Pair<super::super::super::super::super::Rule>,
                            ),
                        ) {
                            self.content.for_self_or_for_each_child_pair(f)
                        }
                        fn for_self_or_for_each_child_pair(
                            &self,
                            f: &mut impl ::pest3_core::std::FnMut(
                                ::pest3_core::token::Pair<super::super::super::super::super::Rule>,
                            ),
                        ) {
                            use pest3_core::typed::PairTree;
                            f(self.as_pair_tree())
                        }
                    }
                    #[allow(non_camel_case_types)]
                    impl<'i> ::pest3_core::typed::PairTree<super::super::super::super::super::Rule> for r#d<'i> {
                        fn get_rule() -> super::super::super::super::super::Rule {
                            #[allow(unused_imports)]
                            use pest3_core::typed::SubRule as _;
                            super::Rule::r#d.cvt_into().cvt_into()
                        }
                        fn get_span(&self) -> (::pest3_core::std::usize, ::pest3_core::std::usize) {
                            (self.span.start(), self.span.end())
                        }
                    }
                }
            }
            impl ::pest3_core::typed::SubRule for d::Rule {
                type Super = super::Rule;
                fn cvt_into(self) -> Self::Super {
                    super::Rule::d(self)
                }
            }
            pub mod e {
                #[allow(
                    dead_code,
                    missing_docs,
                    non_camel_case_types,
                    clippy::upper_case_acronyms
                )]
                #[derive(Clone, Copy, Debug, Eq, Hash, Ord, PartialEq, PartialOrd)]
                pub enum Rule {
                    EOI,
                    r#e,
                    r#a(rules::r#a::Rule),
                    r#_b(rules::r#_b::Rule),
                    r#c(rules::r#c::Rule),
                }
                impl ::pest3_core::typed::SuperRule<rules::r#a::Rule> for Rule {
                    fn cvt_from(rule: rules::r#a::Rule) -> Self {
                        Self::r#a(rule)
                    }
                }
                impl ::pest3_core::typed::SuperRule<rules::r#_b::Rule> for Rule {
                    fn cvt_from(rule: rules::r#_b::Rule) -> Self {
                        Self::r#_b(rule)
                    }
                }
                impl ::pest3_core::typed::SuperRule<rules::r#c::Rule> for Rule {
                    fn cvt_from(rule: rules::r#c::Rule) -> Self {
                        Self::r#c(rule)
                    }
                }
                impl ::pest3_core::typed::RuleType for Rule {
                    const EOI: Self = Rule::EOI;
                }
                #[doc = "Definitions of statically typed nodes generated by pest-generator."]
                pub mod rules {
                    pub type __OptionalTrivia<'i> =
                        super::super::super::super::super::generics::Rep<
                            super::super::super::super::super::generics::Str<
                                super::super::super::super::super::wrapper::W4,
                            >,
                            ::pest3_core::typed::template::Empty,
                        >;
                    pub type __MandatoryTrivia<'i> =
                        super::super::super::super::super::generics::Str<
                            super::super::super::super::super::wrapper::W5,
                        >;
                    pub mod a {
                        #[allow(
                            dead_code,
                            missing_docs,
                            non_camel_case_types,
                            clippy::upper_case_acronyms
                        )]
                        #[derive(Clone, Copy, Debug, Eq, Hash, Ord, PartialEq, PartialOrd)]
                        pub enum Rule {
                            EOI,
                            r#a,
                        }
                        impl ::pest3_core::typed::RuleType for Rule {
                            const EOI: Self = Rule::EOI;
                        }
                        #[doc = "Definitions of statically typed nodes generated by pest-generator."]
                        pub mod rules {
                            pub type __OptionalTrivia < 'i > = super :: super :: super :: super :: super :: super :: super :: generics :: Rep :: < super :: super :: super :: super :: super :: super :: super :: generics :: Str :: < super :: super :: super :: super :: super :: super :: super :: wrapper :: W1 > , :: pest3_core :: typed :: template :: Empty > ;
                            pub type __MandatoryTrivia<'i> = ::pest3_core::typed::template::Empty;
                            #[doc = "Generated for rule `a`. Grammar: `(\"a\" ~ \"a\"?)`."]
                            #[derive(Clone, Debug, Eq, PartialEq)]
                            #[allow(non_camel_case_types)]
                            pub struct r#a < 'i , > { # [doc = r" Matched structure."] pub content : :: pest3_core :: std :: Box < super :: super :: super :: super :: super :: super :: super :: generics :: Sequence2 :: < super :: super :: super :: super :: super :: super :: super :: generics :: Str :: < super :: super :: super :: super :: super :: super :: super :: wrapper :: W0 > , :: pest3_core :: typed :: template :: Empty , :: pest3_core :: std :: Option :: < super :: super :: super :: super :: super :: super :: super :: generics :: Str :: < super :: super :: super :: super :: super :: super :: super :: wrapper :: W0 > > , __OptionalTrivia :: < 'i > , > > , # [doc = r" Matched span."] pub span : :: pest3_core :: Span < 'i > , }
                            #[allow(non_camel_case_types)]
                            impl<'i> ::pest3_core::typed::wrapper::Rule for r#a<'i> {
                                type Rule = super::Rule;
                                const RULE: super::Rule = super::Rule::r#a;
                            }
                            #[allow(non_camel_case_types)]
                            impl<'i> r#a<'i> {}
                            #[allow(unused_imports)]
                            use pest3_core::typed::SubRule as _;
                            :: pest3_core :: typed :: full_rule_struct ! (r#a , () , super :: Rule , super :: Rule :: r#a , super :: super :: super :: super :: super :: super :: super :: generics :: Sequence2 :: < super :: super :: super :: super :: super :: super :: super :: generics :: Str :: < super :: super :: super :: super :: super :: super :: super :: wrapper :: W0 > , :: pest3_core :: typed :: template :: Empty , :: pest3_core :: std :: Option :: < super :: super :: super :: super :: super :: super :: super :: generics :: Str :: < super :: super :: super :: super :: super :: super :: super :: wrapper :: W0 > > , __OptionalTrivia :: < 'i > , > , :: pest3_core :: std :: Box < super :: super :: super :: super :: super :: super :: super :: generics :: Sequence2 :: < super :: super :: super :: super :: super :: super :: super :: generics :: Str :: < super :: super :: super :: super :: super :: super :: super :: wrapper :: W0 > , :: pest3_core :: typed :: template :: Empty , :: pest3_core :: std :: Option :: < super :: super :: super :: super :: super :: super :: super :: generics :: Str :: < super :: super :: super :: super :: super :: super :: super :: wrapper :: W0 > > , __OptionalTrivia :: < 'i > , > > ,) ;
                            #[allow(unused_imports)]
                            use pest3_core::typed::SubRule as _;
                            :: pest3_core :: typed :: full_rule_struct ! (r#a , () , super :: super :: super :: Rule , super :: Rule :: r#a . cvt_into () , super :: super :: super :: super :: super :: super :: super :: generics :: Sequence2 :: < super :: super :: super :: super :: super :: super :: super :: generics :: Str :: < super :: super :: super :: super :: super :: super :: super :: wrapper :: W0 > , :: pest3_core :: typed :: template :: Empty , :: pest3_core :: std :: Option :: < super :: super :: super :: super :: super :: super :: super :: generics :: Str :: < super :: super :: super :: super :: super :: super :: super :: wrapper :: W0 > > , __OptionalTrivia :: < 'i > , > , :: pest3_core :: std :: Box < super :: super :: super :: super :: super :: super :: super :: generics :: Sequence2 :: < super :: super :: super :: super :: super :: super :: super :: generics :: Str :: < super :: super :: super :: super :: super :: super :: super :: wrapper :: W0 > , :: pest3_core :: typed :: template :: Empty , :: pest3_core :: std :: Option :: < super :: super :: super :: super :: super :: super :: super :: generics :: Str :: < super :: super :: super :: super :: super :: super :: super :: wrapper :: W0 > > , __OptionalTrivia :: < 'i > , > > ,) ;
                            #[allow(unused_imports)]
                            use pest3_core::typed::SubRule as _;
                            :: pest3_core :: typed :: full_rule_struct ! (r#a , () , super :: super :: super :: super :: super :: Rule , super :: Rule :: r#a . cvt_into () . cvt_into () , super :: super :: super :: super :: super :: super :: super :: generics :: Sequence2 :: < super :: super :: super :: super :: super :: super :: super :: generics :: Str :: < super :: super :: super :: super :: super :: super :: super :: wrapper :: W0 > , :: pest3_core :: typed :: template :: Empty , :: pest3_core :: std :: Option :: < super :: super :: super :: super :: super :: super :: super :: generics :: Str :: < super :: super :: super :: super :: super :: super :: super :: wrapper :: W0 > > , __OptionalTrivia :: < 'i > , > , :: pest3_core :: std :: Box < super :: super :: super :: super :: super :: super :: super :: generics :: Sequence2 :: < super :: super :: super :: super :: super :: super :: super :: generics :: Str :: < super :: super :: super :: super :: super :: super :: super :: wrapper :: W0 > , :: pest3_core :: typed :: template :: Empty , :: pest3_core :: std :: Option :: < super :: super :: super :: super :: super :: super :: super :: generics :: Str :: < super :: super :: super :: super :: super :: super :: super :: wrapper :: W0 > > , __OptionalTrivia :: < 'i > , > > ,) ;
                            #[allow(unused_imports)]
                            use pest3_core::typed::SubRule as _;
                            :: pest3_core :: typed :: full_rule_struct ! (r#a , () , super :: super :: super :: super :: super :: super :: super :: Rule , super :: Rule :: r#a . cvt_into () . cvt_into () . cvt_into () , super :: super :: super :: super :: super :: super :: super :: generics :: Sequence2 :: < super :: super :: super :: super :: super :: super :: super :: generics :: Str :: < super :: super :: super :: super :: super :: super :: super :: wrapper :: W0 > , :: pest3_core :: typed :: template :: Empty , :: pest3_core :: std :: Option :: < super :: super :: super :: super :: super :: super :: super :: generics :: Str :: < super :: super :: super :: super :: super :: super :: super :: wrapper :: W0 > > , __OptionalTrivia :: < 'i > , > , :: pest3_core :: std :: Box < super :: super :: super :: super :: super :: super :: super :: generics :: Sequence2 :: < super :: super :: super :: super :: super :: super :: super :: generics :: Str :: < super :: super :: super :: super :: super :: super :: super :: wrapper :: W0 > , :: pest3_core :: typed :: template :: Empty , :: pest3_core :: std :: Option :: < super :: super :: super :: super :: super :: super :: super :: generics :: Str :: < super :: super :: super :: super :: super :: super :: super :: wrapper :: W0 > > , __OptionalTrivia :: < 'i > , > > ,) ;
                            #[allow(non_camel_case_types)]
                            impl<'i> ::pest3_core::typed::PairContainer<super::Rule> for r#a<'i> {
                                fn for_each_child_pair(
                                    &self,
                                    f: &mut impl ::pest3_core::std::FnMut(
                                        ::pest3_core::token::Pair<super::Rule>,
                                    ),
                                ) {
                                    self.content.for_self_or_for_each_child_pair(f)
                                }
                                fn for_self_or_for_each_child_pair(
                                    &self,
                                    f: &mut impl ::pest3_core::std::FnMut(
                                        ::pest3_core::token::Pair<super::Rule>,
                                    ),
                                ) {
                                    use pest3_core::typed::PairTree;
                                    f(self.as_pair_tree())
                                }
                            }
                            #[allow(non_camel_case_types)]
                            impl<'i> ::pest3_core::typed::PairTree<super::Rule> for r#a<'i> {
                                fn get_rule() -> super::Rule {
                                    #[allow(unused_imports)]
                                    use pest3_core::typed::SubRule as _;
                                    super::Rule::r#a
                                }
                                fn get_span(
                                    &self,
                                ) -> (::pest3_core::std::usize, ::pest3_core::std::usize)
                                {
                                    (self.span.start(), self.span.end())
                                }
                            }
                            #[allow(non_camel_case_types)]
                            impl<'i> ::pest3_core::typed::PairContainer<super::super::super::Rule> for r#a<'i> {
                                fn for_each_child_pair(
                                    &self,
                                    f: &mut impl ::pest3_core::std::FnMut(
                                        ::pest3_core::token::Pair<super::super::super::Rule>,
                                    ),
                                ) {
                                    self.content.for_self_or_for_each_child_pair(f)
                                }
                                fn for_self_or_for_each_child_pair(
                                    &self,
                                    f: &mut impl ::pest3_core::std::FnMut(
                                        ::pest3_core::token::Pair<super::super::super::Rule>,
                                    ),
                                ) {
                                    use pest3_core::typed::PairTree;
                                    f(self.as_pair_tree())
                                }
                            }
                            #[allow(non_camel_case_types)]
                            impl<'i> ::pest3_core::typed::PairTree<super::super::super::Rule> for r#a<'i> {
                                fn get_rule() -> super::super::super::Rule {
                                    #[allow(unused_imports)]
                                    use pest3_core::typed::SubRule as _;
                                    super::Rule::r#a.cvt_into()
                                }
                                fn get_span(
                                    &self,
                                ) -> (::pest3_core::std::usize, ::pest3_core::std::usize)
                                {
                                    (self.span.start(), self.span.end())
                                }
                            }
                            #[allow(non_camel_case_types)]
                            impl<'i>
                                ::pest3_core::typed::PairContainer<
                                    super::super::super::super::super::Rule,
                                > for r#a<'i>
                            {
                                fn for_each_child_pair(
                                    &self,
                                    f: &mut impl ::pest3_core::std::FnMut(
                                        ::pest3_core::token::Pair<
                                            super::super::super::super::super::Rule,
                                        >,
                                    ),
                                ) {
                                    self.content.for_self_or_for_each_child_pair(f)
                                }
                                fn for_self_or_for_each_child_pair(
                                    &self,
                                    f: &mut impl ::pest3_core::std::FnMut(
                                        ::pest3_core::token::Pair<
                                            super::super::super::super::super::Rule,
                                        >,
                                    ),
                                ) {
                                    use pest3_core::typed::PairTree;
                                    f(self.as_pair_tree())
                                }
                            }
                            #[allow(non_camel_case_types)]
                            impl<'i>
                                ::pest3_core::typed::PairTree<
                                    super::super::super::super::super::Rule,
                                > for r#a<'i>
                            {
                                fn get_rule() -> super::super::super::super::super::Rule {
                                    #[allow(unused_imports)]
                                    use pest3_core::typed::SubRule as _;
                                    super::Rule::r#a.cvt_into().cvt_into()
                                }
                                fn get_span(
                                    &self,
                                ) -> (::pest3_core::std::usize, ::pest3_core::std::usize)
                                {
                                    (self.span.start(), self.span.end())
                                }
                            }
                            #[allow(non_camel_case_types)]
                            impl<'i>
                                ::pest3_core::typed::PairContainer<
                                    super::super::super::super::super::super::super::Rule,
                                > for r#a<'i>
                            {
                                fn for_each_child_pair(
                                    &self,
                                    f: &mut impl ::pest3_core::std::FnMut(
                                        ::pest3_core::token::Pair<
                                            super::super::super::super::super::super::super::Rule,
                                        >,
                                    ),
                                ) {
                                    self.content.for_self_or_for_each_child_pair(f)
                                }
                                fn for_self_or_for_each_child_pair(
                                    &self,
                                    f: &mut impl ::pest3_core::std::FnMut(
                                        ::pest3_core::token::Pair<
                                            super::super::super::super::super::super::super::Rule,
                                        >,
                                    ),
                                ) {
                                    use pest3_core::typed::PairTree;
                                    f(self.as_pair_tree())
                                }
                            }
                            #[allow(non_camel_case_types)]
                            impl<'i>
                                ::pest3_core::typed::PairTree<
                                    super::super::super::super::super::super::super::Rule,
                                > for r#a<'i>
                            {
                                fn get_rule(
                                ) -> super::super::super::super::super::super::super::Rule
                                {
                                    #[allow(unused_imports)]
                                    use pest3_core::typed::SubRule as _;
                                    super::Rule::r#a.cvt_into().cvt_into().cvt_into()
                                }
                                fn get_span(
                                    &self,
                                ) -> (::pest3_core::std::usize, ::pest3_core::std::usize)
                                {
                                    (self.span.start(), self.span.end())
                                }
                            }
                        }
                    }
                    impl ::pest3_core::typed::SubRule for a::Rule {
                        type Super = super::Rule;
                        fn cvt_into(self) -> Self::Super {
                            super::Rule::a(self)
                        }
                    }
                    pub mod _b {
                        #[allow(
                            dead_code,
                            missing_docs,
                            non_camel_case_types,
                            clippy::upper_case_acronyms
                        )]
                        #[derive(Clone, Copy, Debug, Eq, Hash, Ord, PartialEq, PartialOrd)]
                        pub enum Rule {
                            EOI,
                            r#b,
                        }
                        impl ::pest3_core::typed::RuleType for Rule {
                            const EOI: Self = Rule::EOI;
                        }
                        #[doc = "Definitions of statically typed nodes generated by pest-generator."]
                        pub mod rules {
                            pub type __OptionalTrivia<'i> = ::pest3_core::typed::template::Empty;
                            pub type __MandatoryTrivia < 'i > = super :: super :: super :: super :: super :: super :: super :: generics :: RepOnce :: < super :: super :: super :: super :: super :: super :: super :: generics :: Str :: < super :: super :: super :: super :: super :: super :: super :: wrapper :: W3 > , :: pest3_core :: typed :: template :: Empty > ;
                            #[doc = "Generated for rule `b`. Grammar: `(\"b\" ^ \"b\"?)`."]
                            #[derive(Clone, Debug, Eq, PartialEq)]
                            #[allow(non_camel_case_types)]
                            pub struct r#b < 'i , > { # [doc = r" Matched structure."] pub content : :: pest3_core :: std :: Box < super :: super :: super :: super :: super :: super :: super :: generics :: Sequence2 :: < super :: super :: super :: super :: super :: super :: super :: generics :: Str :: < super :: super :: super :: super :: super :: super :: super :: wrapper :: W2 > , :: pest3_core :: typed :: template :: Empty , :: pest3_core :: std :: Option :: < super :: super :: super :: super :: super :: super :: super :: generics :: Str :: < super :: super :: super :: super :: super :: super :: super :: wrapper :: W2 > > , __MandatoryTrivia :: < 'i > , > > , # [doc = r" Matched span."] pub span : :: pest3_core :: Span < 'i > , }
                            #[allow(non_camel_case_types)]
                            impl<'i> ::pest3_core::typed::wrapper::Rule for r#b<'i> {
                                type Rule = super::Rule;
                                const RULE: super::Rule = super::Rule::r#b;
                            }
                            #[allow(non_camel_case_types)]
                            impl<'i> r#b<'i> {}
                            #[allow(unused_imports)]
                            use pest3_core::typed::SubRule as _;
                            :: pest3_core :: typed :: full_rule_struct ! (r#b , () , super :: Rule , super :: Rule :: r#b , super :: super :: super :: super :: super :: super :: super :: generics :: Sequence2 :: < super :: super :: super :: super :: super :: super :: super :: generics :: Str :: < super :: super :: super :: super :: super :: super :: super :: wrapper :: W2 > , :: pest3_core :: typed :: template :: Empty , :: pest3_core :: std :: Option :: < super :: super :: super :: super :: super :: super :: super :: generics :: Str :: < super :: super :: super :: super :: super :: super :: super :: wrapper :: W2 > > , __MandatoryTrivia :: < 'i > , > , :: pest3_core :: std :: Box < super :: super :: super :: super :: super :: super :: super :: generics :: Sequence2 :: < super :: super :: super :: super :: super :: super :: super :: generics :: Str :: < super :: super :: super :: super :: super :: super :: super :: wrapper :: W2 > , :: pest3_core :: typed :: template :: Empty , :: pest3_core :: std :: Option :: < super :: super :: super :: super :: super :: super :: super :: generics :: Str :: < super :: super :: super :: super :: super :: super :: super :: wrapper :: W2 > > , __MandatoryTrivia :: < 'i > , > > ,) ;
                            #[allow(unused_imports)]
                            use pest3_core::typed::SubRule as _;
                            :: pest3_core :: typed :: full_rule_struct ! (r#b , () , super :: super :: super :: Rule , super :: Rule :: r#b . cvt_into () , super :: super :: super :: super :: super :: super :: super :: generics :: Sequence2 :: < super :: super :: super :: super :: super :: super :: super :: generics :: Str :: < super :: super :: super :: super :: super :: super :: super :: wrapper :: W2 > , :: pest3_core :: typed :: template :: Empty , :: pest3_core :: std :: Option :: < super :: super :: super :: super :: super :: super :: super :: generics :: Str :: < super :: super :: super :: super :: super :: super :: super :: wrapper :: W2 > > , __MandatoryTrivia :: < 'i > , > , :: pest3_core :: std :: Box < super :: super :: super :: super :: super :: super :: super :: generics :: Sequence2 :: < super :: super :: super :: super :: super :: super :: super :: generics :: Str :: < super :: super :: super :: super :: super :: super :: super :: wrapper :: W2 > , :: pest3_core :: typed :: template :: Empty , :: pest3_core :: std :: Option :: < super :: super :: super :: super :: super :: super :: super :: generics :: Str :: < super :: super :: super :: super :: super :: super :: super :: wrapper :: W2 > > , __MandatoryTrivia :: < 'i > , > > ,) ;
                            #[allow(unused_imports)]
                            use pest3_core::typed::SubRule as _;
                            :: pest3_core :: typed :: full_rule_struct ! (r#b , () , super :: super :: super :: super :: super :: Rule , super :: Rule :: r#b . cvt_into () . cvt_into () , super :: super :: super :: super :: super :: super :: super :: generics :: Sequence2 :: < super :: super :: super :: super :: super :: super :: super :: generics :: Str :: < super :: super :: super :: super :: super :: super :: super :: wrapper :: W2 > , :: pest3_core :: typed :: template :: Empty , :: pest3_core :: std :: Option :: < super :: super :: super :: super :: super :: super :: super :: generics :: Str :: < super :: super :: super :: super :: super :: super :: super :: wrapper :: W2 > > , __MandatoryTrivia :: < 'i > , > , :: pest3_core :: std :: Box < super :: super :: super :: super :: super :: super :: super :: generics :: Sequence2 :: < super :: super :: super :: super :: super :: super :: super :: generics :: Str :: < super :: super :: super :: super :: super :: super :: super :: wrapper :: W2 > , :: pest3_core :: typed :: template :: Empty , :: pest3_core :: std :: Option :: < super :: super :: super :: super :: super :: super :: super :: generics :: Str :: < super :: super :: super :: super :: super :: super :: super :: wrapper :: W2 > > , __MandatoryTrivia :: < 'i > , > > ,) ;
                            #[allow(unused_imports)]
                            use pest3_core::typed::SubRule as _;
                            :: pest3_core :: typed :: full_rule_struct ! (r#b , () , super :: super :: super :: super :: super :: super :: super :: Rule , super :: Rule :: r#b . cvt_into () . cvt_into () . cvt_into () , super :: super :: super :: super :: super :: super :: super :: generics :: Sequence2 :: < super :: super :: super :: super :: super :: super :: super :: generics :: Str :: < super :: super :: super :: super :: super :: super :: super :: wrapper :: W2 > , :: pest3_core :: typed :: template :: Empty , :: pest3_core :: std :: Option :: < super :: super :: super :: super :: super :: super :: super :: generics :: Str :: < super :: super :: super :: super :: super :: super :: super :: wrapper :: W2 > > , __MandatoryTrivia :: < 'i > , > , :: pest3_core :: std :: Box < super :: super :: super :: super :: super :: super :: super :: generics :: Sequence2 :: < super :: super :: super :: super :: super :: super :: super :: generics :: Str :: < super :: super :: super :: super :: super :: super :: super :: wrapper :: W2 > , :: pest3_core :: typed :: template :: Empty , :: pest3_core :: std :: Option :: < super :: super :: super :: super :: super :: super :: super :: generics :: Str :: < super :: super :: super :: super :: super :: super :: super :: wrapper :: W2 > > , __MandatoryTrivia :: < 'i > , > > ,) ;
                            #[allow(non_camel_case_types)]
                            impl<'i> ::pest3_core::typed::PairContainer<super::Rule> for r#b<'i> {
                                fn for_each_child_pair(
                                    &self,
                                    f: &mut impl ::pest3_core::std::FnMut(
                                        ::pest3_core::token::Pair<super::Rule>,
                                    ),
                                ) {
                                    self.content.for_self_or_for_each_child_pair(f)
                                }
                                fn for_self_or_for_each_child_pair(
                                    &self,
                                    f: &mut impl ::pest3_core::std::FnMut(
                                        ::pest3_core::token::Pair<super::Rule>,
                                    ),
                                ) {
                                    use pest3_core::typed::PairTree;
                                    f(self.as_pair_tree())
                                }
                            }
                            #[allow(non_camel_case_types)]
                            impl<'i> ::pest3_core::typed::PairTree<super::Rule> for r#b<'i> {
                                fn get_rule() -> super::Rule {
                                    #[allow(unused_imports)]
                                    use pest3_core::typed::SubRule as _;
                                    super::Rule::r#b
                                }
                                fn get_span(
                                    &self,
                                ) -> (::pest3_core::std::usize, ::pest3_core::std::usize)
                                {
                                    (self.span.start(), self.span.end())
                                }
                            }
                            #[allow(non_camel_case_types)]
                            impl<'i> ::pest3_core::typed::PairContainer<super::super::super::Rule> for r#b<'i> {
                                fn for_each_child_pair(
                                    &self,
                                    f: &mut impl ::pest3_core::std::FnMut(
                                        ::pest3_core::token::Pair<super::super::super::Rule>,
                                    ),
                                ) {
                                    self.content.for_self_or_for_each_child_pair(f)
                                }
                                fn for_self_or_for_each_child_pair(
                                    &self,
                                    f: &mut impl ::pest3_core::std::FnMut(
                                        ::pest3_core::token::Pair<super::super::super::Rule>,
                                    ),
                                ) {
                                    use pest3_core::typed::PairTree;
                                    f(self.as_pair_tree())
                                }
                            }
                            #[allow(non_camel_case_types)]
                            impl<'i> ::pest3_core::typed::PairTree<super::super::super::Rule> for r#b<'i> {
                                fn get_rule() -> super::super::super::Rule {
                                    #[allow(unused_imports)]
                                    use pest3_core::typed::SubRule as _;
                                    super::Rule::r#b.cvt_into()
                                }
                                fn get_span(
                                    &self,
                                ) -> (::pest3_core::std::usize, ::pest3_core::std::usize)
                                {
                                    (self.span.start(), self.span.end())
                                }
                            }
                            #[allow(non_camel_case_types)]
                            impl<'i>
                                ::pest3_core::typed::PairContainer<
                                    super::super::super::super::super::Rule,
                                > for r#b<'i>
                            {
                                fn for_each_child_pair(
                                    &self,
                                    f: &mut impl ::pest3_core::std::FnMut(
                                        ::pest3_core::token::Pair<
                                            super::super::super::super::super::Rule,
                                        >,
                                    ),
                                ) {
                                    self.content.for_self_or_for_each_child_pair(f)
                                }
                                fn for_self_or_for_each_child_pair(
                                    &self,
                                    f: &mut impl ::pest3_core::std::FnMut(
                                        ::pest3_core::token::Pair<
                                            super::super::super::super::super::Rule,
                                        >,
                                    ),
                                ) {
                                    use pest3_core::typed::PairTree;
                                    f(self.as_pair_tree())
                                }
                            }
                            #[allow(non_camel_case_types)]
                            impl<'i>
                                ::pest3_core::typed::PairTree<
                                    super::super::super::super::super::Rule,
                                > for r#b<'i>
                            {
                                fn get_rule() -> super::super::super::super::super::Rule {
                                    #[allow(unused_imports)]
                                    use pest3_core::typed::SubRule as _;
                                    super::Rule::r#b.cvt_into().cvt_into()
                                }
                                fn get_span(
                                    &self,
                                ) -> (::pest3_core::std::usize, ::pest3_core::std::usize)
                                {
                                    (self.span.start(), self.span.end())
                                }
                            }
                            #[allow(non_camel_case_types)]
                            impl<'i>
                                ::pest3_core::typed::PairContainer<
                                    super::super::super::super::super::super::super::Rule,
                                > for r#b<'i>
                            {
                                fn for_each_child_pair(
                                    &self,
                                    f: &mut impl ::pest3_core::std::FnMut(
                                        ::pest3_core::token::Pair<
                                            super::super::super::super::super::super::super::Rule,
                                        >,
                                    ),
                                ) {
                                    self.content.for_self_or_for_each_child_pair(f)
                                }
                                fn for_self_or_for_each_child_pair(
                                    &self,
                                    f: &mut impl ::pest3_core::std::FnMut(
                                        ::pest3_core::token::Pair<
                                            super::super::super::super::super::super::super::Rule,
                                        >,
                                    ),
                                ) {
                                    use pest3_core::typed::PairTree;
                                    f(self.as_pair_tree())
                                }
                            }
                            #[allow(non_camel_case_types)]
                            impl<'i>
                                ::pest3_core::typed::PairTree<
                                    super::super::super::super::super::super::super::Rule,
                                > for r#b<'i>
                            {
                                fn get_rule(
                                ) -> super::super::super::super::super::super::super::Rule
                                {
                                    #[allow(unused_imports)]
                                    use pest3_core::typed::SubRule as _;
                                    super::Rule::r#b.cvt_into().cvt_into().cvt_into()
                                }
                                fn get_span(
                                    &self,
                                ) -> (::pest3_core::std::usize, ::pest3_core::std::usize)
                                {
                                    (self.span.start(), self.span.end())
                                }
                            }
                        }
                    }
                    impl ::pest3_core::typed::SubRule for _b::Rule {
                        type Super = super::Rule;
                        fn cvt_into(self) -> Self::Super {
                            super::Rule::_b(self)
                        }
                    }
                    pub mod c {
                        #[allow(
                            dead_code,
                            missing_docs,
                            non_camel_case_types,
                            clippy::upper_case_acronyms
                        )]
                        #[derive(Clone, Copy, Debug, Eq, Hash, Ord, PartialEq, PartialOrd)]
                        pub enum Rule {
                            EOI,
                            r#c,
                            r#a(rules::r#a::Rule),
                            r#b(rules::r#b::Rule),
                        }
                        impl ::pest3_core::typed::SuperRule<rules::r#a::Rule> for Rule {
                            fn cvt_from(rule: rules::r#a::Rule) -> Self {
                                Self::r#a(rule)
                            }
                        }
                        impl ::pest3_core::typed::SuperRule<rules::r#b::Rule> for Rule {
                            fn cvt_from(rule: rules::r#b::Rule) -> Self {
                                Self::r#b(rule)
                            }
                        }
                        impl ::pest3_core::typed::RuleType for Rule {
                            const EOI: Self = Rule::EOI;
                        }
                        #[doc = "Definitions of statically typed nodes generated by pest-generator."]
                        pub mod rules {
                            pub type __OptionalTrivia < 'i > = super :: super :: super :: super :: super :: super :: super :: generics :: Sequence3 :: < :: pest3_core :: std :: Option :: < super :: super :: super :: super :: super :: super :: super :: generics :: Str :: < super :: super :: super :: super :: super :: super :: super :: wrapper :: W4 > > , :: pest3_core :: typed :: template :: Empty , :: pest3_core :: std :: Option :: < r#c :: < 'i > > , :: pest3_core :: typed :: template :: Empty , :: pest3_core :: std :: Option :: < super :: super :: super :: super :: super :: super :: super :: generics :: Str :: < super :: super :: super :: super :: super :: super :: super :: wrapper :: W4 > > , :: pest3_core :: typed :: template :: Empty , > ;
                            pub type __MandatoryTrivia<'i> = ::pest3_core::typed::template::Empty;
                            pub mod a {
                                #[allow(
                                    dead_code,
                                    missing_docs,
                                    non_camel_case_types,
                                    clippy::upper_case_acronyms
                                )]
                                #[derive(
                                    Clone, Copy, Debug, Eq, Hash, Ord, PartialEq, PartialOrd,
                                )]
                                pub enum Rule {
                                    EOI,
                                    r#a,
                                }
                                impl ::pest3_core::typed::RuleType for Rule {
                                    const EOI: Self = Rule::EOI;
                                }
                                #[doc = "Definitions of statically typed nodes generated by pest-generator."]
                                pub mod rules {
                                    pub type __OptionalTrivia < 'i > = super :: super :: super :: super :: super :: super :: super :: super :: super :: generics :: Rep :: < super :: super :: super :: super :: super :: super :: super :: super :: super :: generics :: Str :: < super :: super :: super :: super :: super :: super :: super :: super :: super :: wrapper :: W1 > , :: pest3_core :: typed :: template :: Empty > ;
                                    pub type __MandatoryTrivia<'i> =
                                        ::pest3_core::typed::template::Empty;
                                    #[doc = "Generated for rule `a`. Grammar: `(\"a\" ~ \"a\"?)`."]
                                    #[derive(Clone, Debug, Eq, PartialEq)]
                                    #[allow(non_camel_case_types)]
                                    pub struct r#a < 'i , > { # [doc = r" Matched structure."] pub content : :: pest3_core :: std :: Box < super :: super :: super :: super :: super :: super :: super :: super :: super :: generics :: Sequence2 :: < super :: super :: super :: super :: super :: super :: super :: super :: super :: generics :: Str :: < super :: super :: super :: super :: super :: super :: super :: super :: super :: wrapper :: W0 > , :: pest3_core :: typed :: template :: Empty , :: pest3_core :: std :: Option :: < super :: super :: super :: super :: super :: super :: super :: super :: super :: generics :: Str :: < super :: super :: super :: super :: super :: super :: super :: super :: super :: wrapper :: W0 > > , __OptionalTrivia :: < 'i > , > > , # [doc = r" Matched span."] pub span : :: pest3_core :: Span < 'i > , }
                                    #[allow(non_camel_case_types)]
                                    impl<'i> ::pest3_core::typed::wrapper::Rule for r#a<'i> {
                                        type Rule = super::Rule;
                                        const RULE: super::Rule = super::Rule::r#a;
                                    }
                                    #[allow(non_camel_case_types)]
                                    impl<'i> r#a<'i> {}
                                    #[allow(unused_imports)]
                                    use pest3_core::typed::SubRule as _;
                                    :: pest3_core :: typed :: full_rule_struct ! (r#a , () , super :: Rule , super :: Rule :: r#a , super :: super :: super :: super :: super :: super :: super :: super :: super :: generics :: Sequence2 :: < super :: super :: super :: super :: super :: super :: super :: super :: super :: generics :: Str :: < super :: super :: super :: super :: super :: super :: super :: super :: super :: wrapper :: W0 > , :: pest3_core :: typed :: template :: Empty , :: pest3_core :: std :: Option :: < super :: super :: super :: super :: super :: super :: super :: super :: super :: generics :: Str :: < super :: super :: super :: super :: super :: super :: super :: super :: super :: wrapper :: W0 > > , __OptionalTrivia :: < 'i > , > , :: pest3_core :: std :: Box < super :: super :: super :: super :: super :: super :: super :: super :: super :: generics :: Sequence2 :: < super :: super :: super :: super :: super :: super :: super :: super :: super :: generics :: Str :: < super :: super :: super :: super :: super :: super :: super :: super :: super :: wrapper :: W0 > , :: pest3_core :: typed :: template :: Empty , :: pest3_core :: std :: Option :: < super :: super :: super :: super :: super :: super :: super :: super :: super :: generics :: Str :: < super :: super :: super :: super :: super :: super :: super :: super :: super :: wrapper :: W0 > > , __OptionalTrivia :: < 'i > , > > ,) ;
                                    #[allow(unused_imports)]
                                    use pest3_core::typed::SubRule as _;
                                    :: pest3_core :: typed :: full_rule_struct ! (r#a , () , super :: super :: super :: Rule , super :: Rule :: r#a . cvt_into () , super :: super :: super :: super :: super :: super :: super :: super :: super :: generics :: Sequence2 :: < super :: super :: super :: super :: super :: super :: super :: super :: super :: generics :: Str :: < super :: super :: super :: super :: super :: super :: super :: super :: super :: wrapper :: W0 > , :: pest3_core :: typed :: template :: Empty , :: pest3_core :: std :: Option :: < super :: super :: super :: super :: super :: super :: super :: super :: super :: generics :: Str :: < super :: super :: super :: super :: super :: super :: super :: super :: super :: wrapper :: W0 > > , __OptionalTrivia :: < 'i > , > , :: pest3_core :: std :: Box < super :: super :: super :: super :: super :: super :: super :: super :: super :: generics :: Sequence2 :: < super :: super :: super :: super :: super :: super :: super :: super :: super :: generics :: Str :: < super :: super :: super :: super :: super :: super :: super :: super :: super :: wrapper :: W0 > , :: pest3_core :: typed :: template :: Empty , :: pest3_core :: std :: Option :: < super :: super :: super :: super :: super :: super :: super :: super :: super :: generics :: Str :: < super :: super :: super :: super :: super :: super :: super :: super :: super :: wrapper :: W0 > > , __OptionalTrivia :: < 'i > , > > ,) ;
                                    #[allow(unused_imports)]
                                    use pest3_core::typed::SubRule as _;
                                    :: pest3_core :: typed :: full_rule_struct ! (r#a , () , super :: super :: super :: super :: super :: Rule , super :: Rule :: r#a . cvt_into () . cvt_into () , super :: super :: super :: super :: super :: super :: super :: super :: super :: generics :: Sequence2 :: < super :: super :: super :: super :: super :: super :: super :: super :: super :: generics :: Str :: < super :: super :: super :: super :: super :: super :: super :: super :: super :: wrapper :: W0 > , :: pest3_core :: typed :: template :: Empty , :: pest3_core :: std :: Option :: < super :: super :: super :: super :: super :: super :: super :: super :: super :: generics :: Str :: < super :: super :: super :: super :: super :: super :: super :: super :: super :: wrapper :: W0 > > , __OptionalTrivia :: < 'i > , > , :: pest3_core :: std :: Box < super :: super :: super :: super :: super :: super :: super :: super :: super :: generics :: Sequence2 :: < super :: super :: super :: super :: super :: super :: super :: super :: super :: generics :: Str :: < super :: super :: super :: super :: super :: super :: super :: super :: super :: wrapper :: W0 > , :: pest3_core :: typed :: template :: Empty , :: pest3_core :: std :: Option :: < super :: super :: super :: super :: super :: super :: super :: super :: super :: generics :: Str :: < super :: super :: super :: super :: super :: super :: super :: super :: super :: wrapper :: W0 > > , __OptionalTrivia :: < 'i > , > > ,) ;
                                    #[allow(unused_imports)]
                                    use pest3_core::typed::SubRule as _;
                                    :: pest3_core :: typed :: full_rule_struct ! (r#a , () , super :: super :: super :: super :: super :: super :: super :: Rule , super :: Rule :: r#a . cvt_into () . cvt_into () . cvt_into () , super :: super :: super :: super :: super :: super :: super :: super :: super :: generics :: Sequence2 :: < super :: super :: super :: super :: super :: super :: super :: super :: super :: generics :: Str :: < super :: super :: super :: super :: super :: super :: super :: super :: super :: wrapper :: W0 > , :: pest3_core :: typed :: template :: Empty , :: pest3_core :: std :: Option :: < super :: super :: super :: super :: super :: super :: super :: super :: super :: generics :: Str :: < super :: super :: super :: super :: super :: super :: super :: super :: super :: wrapper :: W0 > > , __OptionalTrivia :: < 'i > , > , :: pest3_core :: std :: Box < super :: super :: super :: super :: super :: super :: super :: super :: super :: generics :: Sequence2 :: < super :: super :: super :: super :: super :: super :: super :: super :: super :: generics :: Str :: < super :: super :: super :: super :: super :: super :: super :: super :: super :: wrapper :: W0 > , :: pest3_core :: typed :: template :: Empty , :: pest3_core :: std :: Option :: < super :: super :: super :: super :: super :: super :: super :: super :: super :: generics :: Str :: < super :: super :: super :: super :: super :: super :: super :: super :: super :: wrapper :: W0 > > , __OptionalTrivia :: < 'i > , > > ,) ;
                                    #[allow(unused_imports)]
                                    use pest3_core::typed::SubRule as _;
                                    :: pest3_core :: typed :: full_rule_struct ! (r#a , () , super :: super :: super :: super :: super :: super :: super :: super :: super :: Rule , super :: Rule :: r#a . cvt_into () . cvt_into () . cvt_into () . cvt_into () , super :: super :: super :: super :: super :: super :: super :: super :: super :: generics :: Sequence2 :: < super :: super :: super :: super :: super :: super :: super :: super :: super :: generics :: Str :: < super :: super :: super :: super :: super :: super :: super :: super :: super :: wrapper :: W0 > , :: pest3_core :: typed :: template :: Empty , :: pest3_core :: std :: Option :: < super :: super :: super :: super :: super :: super :: super :: super :: super :: generics :: Str :: < super :: super :: super :: super :: super :: super :: super :: super :: super :: wrapper :: W0 > > , __OptionalTrivia :: < 'i > , > , :: pest3_core :: std :: Box < super :: super :: super :: super :: super :: super :: super :: super :: super :: generics :: Sequence2 :: < super :: super :: super :: super :: super :: super :: super :: super :: super :: generics :: Str :: < super :: super :: super :: super :: super :: super :: super :: super :: super :: wrapper :: W0 > , :: pest3_core :: typed :: template :: Empty , :: pest3_core :: std :: Option :: < super :: super :: super :: super :: super :: super :: super :: super :: super :: generics :: Str :: < super :: super :: super :: super :: super :: super :: super :: super :: super :: wrapper :: W0 > > , __OptionalTrivia :: < 'i > , > > ,) ;
                                    #[allow(non_camel_case_types)]
                                    impl<'i> ::pest3_core::typed::PairContainer<super::Rule> for r#a<'i> {
                                        fn for_each_child_pair(
                                            &self,
                                            f: &mut impl ::pest3_core::std::FnMut(
                                                ::pest3_core::token::Pair<super::Rule>,
                                            ),
                                        ) {
                                            self.content.for_self_or_for_each_child_pair(f)
                                        }
                                        fn for_self_or_for_each_child_pair(
                                            &self,
                                            f: &mut impl ::pest3_core::std::FnMut(
                                                ::pest3_core::token::Pair<super::Rule>,
                                            ),
                                        ) {
                                            use pest3_core::typed::PairTree;
                                            f(self.as_pair_tree())
                                        }
                                    }
                                    #[allow(non_camel_case_types)]
                                    impl<'i> ::pest3_core::typed::PairTree<super::Rule> for r#a<'i> {
                                        fn get_rule() -> super::Rule {
                                            #[allow(unused_imports)]
                                            use pest3_core::typed::SubRule as _;
                                            super::Rule::r#a
                                        }
                                        fn get_span(
                                            &self,
                                        ) -> (::pest3_core::std::usize, ::pest3_core::std::usize)
                                        {
                                            (self.span.start(), self.span.end())
                                        }
                                    }
                                    #[allow(non_camel_case_types)]
                                    impl<'i>
                                        ::pest3_core::typed::PairContainer<
                                            super::super::super::Rule,
                                        > for r#a<'i>
                                    {
                                        fn for_each_child_pair(
                                            &self,
                                            f: &mut impl ::pest3_core::std::FnMut(
                                                ::pest3_core::token::Pair<super::super::super::Rule>,
                                            ),
                                        ) {
                                            self.content.for_self_or_for_each_child_pair(f)
                                        }
                                        fn for_self_or_for_each_child_pair(
                                            &self,
                                            f: &mut impl ::pest3_core::std::FnMut(
                                                ::pest3_core::token::Pair<super::super::super::Rule>,
                                            ),
                                        ) {
                                            use pest3_core::typed::PairTree;
                                            f(self.as_pair_tree())
                                        }
                                    }
                                    #[allow(non_camel_case_types)]
                                    impl<'i>
                                        ::pest3_core::typed::PairTree<super::super::super::Rule>
                                        for r#a<'i>
                                    {
                                        fn get_rule() -> super::super::super::Rule {
                                            #[allow(unused_imports)]
                                            use pest3_core::typed::SubRule as _;
                                            super::Rule::r#a.cvt_into()
                                        }
                                        fn get_span(
                                            &self,
                                        ) -> (::pest3_core::std::usize, ::pest3_core::std::usize)
                                        {
                                            (self.span.start(), self.span.end())
                                        }
                                    }
                                    #[allow(non_camel_case_types)]
                                    impl<'i>
                                        ::pest3_core::typed::PairContainer<
                                            super::super::super::super::super::Rule,
                                        > for r#a<'i>
                                    {
                                        fn for_each_child_pair(
                                            &self,
                                            f: &mut impl ::pest3_core::std::FnMut(
                                                ::pest3_core::token::Pair<
                                                    super::super::super::super::super::Rule,
                                                >,
                                            ),
                                        ) {
                                            self.content.for_self_or_for_each_child_pair(f)
                                        }
                                        fn for_self_or_for_each_child_pair(
                                            &self,
                                            f: &mut impl ::pest3_core::std::FnMut(
                                                ::pest3_core::token::Pair<
                                                    super::super::super::super::super::Rule,
                                                >,
                                            ),
                                        ) {
                                            use pest3_core::typed::PairTree;
                                            f(self.as_pair_tree())
                                        }
                                    }
                                    #[allow(non_camel_case_types)]
                                    impl<'i>
                                        ::pest3_core::typed::PairTree<
                                            super::super::super::super::super::Rule,
                                        > for r#a<'i>
                                    {
                                        fn get_rule() -> super::super::super::super::super::Rule {
                                            #[allow(unused_imports)]
                                            use pest3_core::typed::SubRule as _;
                                            super::Rule::r#a.cvt_into().cvt_into()
                                        }
                                        fn get_span(
                                            &self,
                                        ) -> (::pest3_core::std::usize, ::pest3_core::std::usize)
                                        {
                                            (self.span.start(), self.span.end())
                                        }
                                    }
                                    #[allow(non_camel_case_types)]
                                    impl<'i>
                                        ::pest3_core::typed::PairContainer<
                                            super::super::super::super::super::super::super::Rule,
                                        > for r#a<'i>
                                    {
                                        fn for_each_child_pair(
                                            &self,
                                            f : & mut impl :: pest3_core :: std :: FnMut (:: pest3_core :: token :: Pair < super :: super :: super :: super :: super :: super :: super :: Rule >),
                                        ) {
                                            self.content.for_self_or_for_each_child_pair(f)
                                        }
                                        fn for_self_or_for_each_child_pair(
                                            &self,
                                            f : & mut impl :: pest3_core :: std :: FnMut (:: pest3_core :: token :: Pair < super :: super :: super :: super :: super :: super :: super :: Rule >),
                                        ) {
                                            use pest3_core::typed::PairTree;
                                            f(self.as_pair_tree())
                                        }
                                    }
                                    #[allow(non_camel_case_types)]
                                    impl<'i>
                                        ::pest3_core::typed::PairTree<
                                            super::super::super::super::super::super::super::Rule,
                                        > for r#a<'i>
                                    {
                                        fn get_rule(
                                        ) -> super::super::super::super::super::super::super::Rule
                                        {
                                            #[allow(unused_imports)]
                                            use pest3_core::typed::SubRule as _;
                                            super::Rule::r#a.cvt_into().cvt_into().cvt_into()
                                        }
                                        fn get_span(
                                            &self,
                                        ) -> (::pest3_core::std::usize, ::pest3_core::std::usize)
                                        {
                                            (self.span.start(), self.span.end())
                                        }
                                    }
                                    #[allow(non_camel_case_types)]
                                    impl < 'i , > :: pest3_core :: typed :: PairContainer < super :: super :: super :: super :: super :: super :: super :: super :: super :: Rule > for r#a < 'i , > { fn for_each_child_pair (& self , f : & mut impl :: pest3_core :: std :: FnMut (:: pest3_core :: token :: Pair < super :: super :: super :: super :: super :: super :: super :: super :: super :: Rule >)) { self . content . for_self_or_for_each_child_pair (f) } fn for_self_or_for_each_child_pair (& self , f : & mut impl :: pest3_core :: std :: FnMut (:: pest3_core :: token :: Pair < super :: super :: super :: super :: super :: super :: super :: super :: super :: Rule >)) { use :: pest3_core :: typed :: PairTree ; f (self . as_pair_tree ()) } }
                                    #[allow(non_camel_case_types)]
                                    impl < 'i , > :: pest3_core :: typed :: PairTree < super :: super :: super :: super :: super :: super :: super :: super :: super :: Rule > for r#a < 'i , > { fn get_rule () -> super :: super :: super :: super :: super :: super :: super :: super :: super :: Rule { # [allow (unused_imports)] use :: pest3_core :: typed :: SubRule as _ ; super :: Rule :: r#a . cvt_into () . cvt_into () . cvt_into () . cvt_into () } fn get_span (& self) -> (:: pest3_core :: std :: usize , :: pest3_core :: std :: usize) { (self . span . start () , self . span . end ()) } }
                                }
                            }
                            impl ::pest3_core::typed::SubRule for a::Rule {
                                type Super = super::Rule;
                                fn cvt_into(self) -> Self::Super {
                                    super::Rule::a(self)
                                }
                            }
                            pub mod b {
                                #[allow(
                                    dead_code,
                                    missing_docs,
                                    non_camel_case_types,
                                    clippy::upper_case_acronyms
                                )]
                                #[derive(
                                    Clone, Copy, Debug, Eq, Hash, Ord, PartialEq, PartialOrd,
                                )]
                                pub enum Rule {
                                    EOI,
                                    r#b,
                                }
                                impl ::pest3_core::typed::RuleType for Rule {
                                    const EOI: Self = Rule::EOI;
                                }
                                #[doc = "Definitions of statically typed nodes generated by pest-generator."]
                                pub mod rules {
                                    pub type __OptionalTrivia<'i> =
                                        ::pest3_core::typed::template::Empty;
                                    pub type __MandatoryTrivia < 'i > = super :: super :: super :: super :: super :: super :: super :: super :: super :: generics :: RepOnce :: < super :: super :: super :: super :: super :: super :: super :: super :: super :: generics :: Str :: < super :: super :: super :: super :: super :: super :: super :: super :: super :: wrapper :: W3 > , :: pest3_core :: typed :: template :: Empty > ;
                                    #[doc = "Generated for rule `b`. Grammar: `(\"b\" ^ \"b\"?)`."]
                                    #[derive(Clone, Debug, Eq, PartialEq)]
                                    #[allow(non_camel_case_types)]
                                    pub struct r#b < 'i , > { # [doc = r" Matched structure."] pub content : :: pest3_core :: std :: Box < super :: super :: super :: super :: super :: super :: super :: super :: super :: generics :: Sequence2 :: < super :: super :: super :: super :: super :: super :: super :: super :: super :: generics :: Str :: < super :: super :: super :: super :: super :: super :: super :: super :: super :: wrapper :: W2 > , :: pest3_core :: typed :: template :: Empty , :: pest3_core :: std :: Option :: < super :: super :: super :: super :: super :: super :: super :: super :: super :: generics :: Str :: < super :: super :: super :: super :: super :: super :: super :: super :: super :: wrapper :: W2 > > , __MandatoryTrivia :: < 'i > , > > , # [doc = r" Matched span."] pub span : :: pest3_core :: Span < 'i > , }
                                    #[allow(non_camel_case_types)]
                                    impl<'i> ::pest3_core::typed::wrapper::Rule for r#b<'i> {
                                        type Rule = super::Rule;
                                        const RULE: super::Rule = super::Rule::r#b;
                                    }
                                    #[allow(non_camel_case_types)]
                                    impl<'i> r#b<'i> {}
                                    #[allow(unused_imports)]
                                    use pest3_core::typed::SubRule as _;
                                    :: pest3_core :: typed :: full_rule_struct ! (r#b , () , super :: Rule , super :: Rule :: r#b , super :: super :: super :: super :: super :: super :: super :: super :: super :: generics :: Sequence2 :: < super :: super :: super :: super :: super :: super :: super :: super :: super :: generics :: Str :: < super :: super :: super :: super :: super :: super :: super :: super :: super :: wrapper :: W2 > , :: pest3_core :: typed :: template :: Empty , :: pest3_core :: std :: Option :: < super :: super :: super :: super :: super :: super :: super :: super :: super :: generics :: Str :: < super :: super :: super :: super :: super :: super :: super :: super :: super :: wrapper :: W2 > > , __MandatoryTrivia :: < 'i > , > , :: pest3_core :: std :: Box < super :: super :: super :: super :: super :: super :: super :: super :: super :: generics :: Sequence2 :: < super :: super :: super :: super :: super :: super :: super :: super :: super :: generics :: Str :: < super :: super :: super :: super :: super :: super :: super :: super :: super :: wrapper :: W2 > , :: pest3_core :: typed :: template :: Empty , :: pest3_core :: std :: Option :: < super :: super :: super :: super :: super :: super :: super :: super :: super :: generics :: Str :: < super :: super :: super :: super :: super :: super :: super :: super :: super :: wrapper :: W2 > > , __MandatoryTrivia :: < 'i > , > > ,) ;
                                    #[allow(unused_imports)]
                                    use pest3_core::typed::SubRule as _;
                                    :: pest3_core :: typed :: full_rule_struct ! (r#b , () , super :: super :: super :: Rule , super :: Rule :: r#b . cvt_into () , super :: super :: super :: super :: super :: super :: super :: super :: super :: generics :: Sequence2 :: < super :: super :: super :: super :: super :: super :: super :: super :: super :: generics :: Str :: < super :: super :: super :: super :: super :: super :: super :: super :: super :: wrapper :: W2 > , :: pest3_core :: typed :: template :: Empty , :: pest3_core :: std :: Option :: < super :: super :: super :: super :: super :: super :: super :: super :: super :: generics :: Str :: < super :: super :: super :: super :: super :: super :: super :: super :: super :: wrapper :: W2 > > , __MandatoryTrivia :: < 'i > , > , :: pest3_core :: std :: Box < super :: super :: super :: super :: super :: super :: super :: super :: super :: generics :: Sequence2 :: < super :: super :: super :: super :: super :: super :: super :: super :: super :: generics :: Str :: < super :: super :: super :: super :: super :: super :: super :: super :: super :: wrapper :: W2 > , :: pest3_core :: typed :: template :: Empty , :: pest3_core :: std :: Option :: < super :: super :: super :: super :: super :: super :: super :: super :: super :: generics :: Str :: < super :: super :: super :: super :: super :: super :: super :: super :: super :: wrapper :: W2 > > , __MandatoryTrivia :: < 'i > , > > ,) ;
                                    #[allow(unused_imports)]
                                    use pest3_core::typed::SubRule as _;
                                    :: pest3_core :: typed :: full_rule_struct ! (r#b , () , super :: super :: super :: super :: super :: Rule , super :: Rule :: r#b . cvt_into () . cvt_into () , super :: super :: super :: super :: super :: super :: super :: super :: super :: generics :: Sequence2 :: < super :: super :: super :: super :: super :: super :: super :: super :: super :: generics :: Str :: < super :: super :: super :: super :: super :: super :: super :: super :: super :: wrapper :: W2 > , :: pest3_core :: typed :: template :: Empty , :: pest3_core :: std :: Option :: < super :: super :: super :: super :: super :: super :: super :: super :: super :: generics :: Str :: < super :: super :: super :: super :: super :: super :: super :: super :: super :: wrapper :: W2 > > , __MandatoryTrivia :: < 'i > , > , :: pest3_core :: std :: Box < super :: super :: super :: super :: super :: super :: super :: super :: super :: generics :: Sequence2 :: < super :: super :: super :: super :: super :: super :: super :: super :: super :: generics :: Str :: < super :: super :: super :: super :: super :: super :: super :: super :: super :: wrapper :: W2 > , :: pest3_core :: typed :: template :: Empty , :: pest3_core :: std :: Option :: < super :: super :: super :: super :: super :: super :: super :: super :: super :: generics :: Str :: < super :: super :: super :: super :: super :: super :: super :: super :: super :: wrapper :: W2 > > , __MandatoryTrivia :: < 'i > , > > ,) ;
                                    #[allow(unused_imports)]
                                    use pest3_core::typed::SubRule as _;
                                    :: pest3_core :: typed :: full_rule_struct ! (r#b , () , super :: super :: super :: super :: super :: super :: super :: Rule , super :: Rule :: r#b . cvt_into () . cvt_into () . cvt_into () , super :: super :: super :: super :: super :: super :: super :: super :: super :: generics :: Sequence2 :: < super :: super :: super :: super :: super :: super :: super :: super :: super :: generics :: Str :: < super :: super :: super :: super :: super :: super :: super :: super :: super :: wrapper :: W2 > , :: pest3_core :: typed :: template :: Empty , :: pest3_core :: std :: Option :: < super :: super :: super :: super :: super :: super :: super :: super :: super :: generics :: Str :: < super :: super :: super :: super :: super :: super :: super :: super :: super :: wrapper :: W2 > > , __MandatoryTrivia :: < 'i > , > , :: pest3_core :: std :: Box < super :: super :: super :: super :: super :: super :: super :: super :: super :: generics :: Sequence2 :: < super :: super :: super :: super :: super :: super :: super :: super :: super :: generics :: Str :: < super :: super :: super :: super :: super :: super :: super :: super :: super :: wrapper :: W2 > , :: pest3_core :: typed :: template :: Empty , :: pest3_core :: std :: Option :: < super :: super :: super :: super :: super :: super :: super :: super :: super :: generics :: Str :: < super :: super :: super :: super :: super :: super :: super :: super :: super :: wrapper :: W2 > > , __MandatoryTrivia :: < 'i > , > > ,) ;
                                    #[allow(unused_imports)]
                                    use pest3_core::typed::SubRule as _;
                                    :: pest3_core :: typed :: full_rule_struct ! (r#b , () , super :: super :: super :: super :: super :: super :: super :: super :: super :: Rule , super :: Rule :: r#b . cvt_into () . cvt_into () . cvt_into () . cvt_into () , super :: super :: super :: super :: super :: super :: super :: super :: super :: generics :: Sequence2 :: < super :: super :: super :: super :: super :: super :: super :: super :: super :: generics :: Str :: < super :: super :: super :: super :: super :: super :: super :: super :: super :: wrapper :: W2 > , :: pest3_core :: typed :: template :: Empty , :: pest3_core :: std :: Option :: < super :: super :: super :: super :: super :: super :: super :: super :: super :: generics :: Str :: < super :: super :: super :: super :: super :: super :: super :: super :: super :: wrapper :: W2 > > , __MandatoryTrivia :: < 'i > , > , :: pest3_core :: std :: Box < super :: super :: super :: super :: super :: super :: super :: super :: super :: generics :: Sequence2 :: < super :: super :: super :: super :: super :: super :: super :: super :: super :: generics :: Str :: < super :: super :: super :: super :: super :: super :: super :: super :: super :: wrapper :: W2 > , :: pest3_core :: typed :: template :: Empty , :: pest3_core :: std :: Option :: < super :: super :: super :: super :: super :: super :: super :: super :: super :: generics :: Str :: < super :: super :: super :: super :: super :: super :: super :: super :: super :: wrapper :: W2 > > , __MandatoryTrivia :: < 'i > , > > ,) ;
                                    #[allow(non_camel_case_types)]
                                    impl<'i> ::pest3_core::typed::PairContainer<super::Rule> for r#b<'i> {
                                        fn for_each_child_pair(
                                            &self,
                                            f: &mut impl ::pest3_core::std::FnMut(
                                                ::pest3_core::token::Pair<super::Rule>,
                                            ),
                                        ) {
                                            self.content.for_self_or_for_each_child_pair(f)
                                        }
                                        fn for_self_or_for_each_child_pair(
                                            &self,
                                            f: &mut impl ::pest3_core::std::FnMut(
                                                ::pest3_core::token::Pair<super::Rule>,
                                            ),
                                        ) {
                                            use pest3_core::typed::PairTree;
                                            f(self.as_pair_tree())
                                        }
                                    }
                                    #[allow(non_camel_case_types)]
                                    impl<'i> ::pest3_core::typed::PairTree<super::Rule> for r#b<'i> {
                                        fn get_rule() -> super::Rule {
                                            #[allow(unused_imports)]
                                            use pest3_core::typed::SubRule as _;
                                            super::Rule::r#b
                                        }
                                        fn get_span(
                                            &self,
                                        ) -> (::pest3_core::std::usize, ::pest3_core::std::usize)
                                        {
                                            (self.span.start(), self.span.end())
                                        }
                                    }
                                    #[allow(non_camel_case_types)]
                                    impl<'i>
                                        ::pest3_core::typed::PairContainer<
                                            super::super::super::Rule,
                                        > for r#b<'i>
                                    {
                                        fn for_each_child_pair(
                                            &self,
                                            f: &mut impl ::pest3_core::std::FnMut(
                                                ::pest3_core::token::Pair<super::super::super::Rule>,
                                            ),
                                        ) {
                                            self.content.for_self_or_for_each_child_pair(f)
                                        }
                                        fn for_self_or_for_each_child_pair(
                                            &self,
                                            f: &mut impl ::pest3_core::std::FnMut(
                                                ::pest3_core::token::Pair<super::super::super::Rule>,
                                            ),
                                        ) {
                                            use pest3_core::typed::PairTree;
                                            f(self.as_pair_tree())
                                        }
                                    }
                                    #[allow(non_camel_case_types)]
                                    impl<'i>
                                        ::pest3_core::typed::PairTree<super::super::super::Rule>
                                        for r#b<'i>
                                    {
                                        fn get_rule() -> super::super::super::Rule {
                                            #[allow(unused_imports)]
                                            use pest3_core::typed::SubRule as _;
                                            super::Rule::r#b.cvt_into()
                                        }
                                        fn get_span(
                                            &self,
                                        ) -> (::pest3_core::std::usize, ::pest3_core::std::usize)
                                        {
                                            (self.span.start(), self.span.end())
                                        }
                                    }
                                    #[allow(non_camel_case_types)]
                                    impl<'i>
                                        ::pest3_core::typed::PairContainer<
                                            super::super::super::super::super::Rule,
                                        > for r#b<'i>
                                    {
                                        fn for_each_child_pair(
                                            &self,
                                            f: &mut impl ::pest3_core::std::FnMut(
                                                ::pest3_core::token::Pair<
                                                    super::super::super::super::super::Rule,
                                                >,
                                            ),
                                        ) {
                                            self.content.for_self_or_for_each_child_pair(f)
                                        }
                                        fn for_self_or_for_each_child_pair(
                                            &self,
                                            f: &mut impl ::pest3_core::std::FnMut(
                                                ::pest3_core::token::Pair<
                                                    super::super::super::super::super::Rule,
                                                >,
                                            ),
                                        ) {
                                            use pest3_core::typed::PairTree;
                                            f(self.as_pair_tree())
                                        }
                                    }
                                    #[allow(non_camel_case_types)]
                                    impl<'i>
                                        ::pest3_core::typed::PairTree<
                                            super::super::super::super::super::Rule,
                                        > for r#b<'i>
                                    {
                                        fn get_rule() -> super::super::super::super::super::Rule {
                                            #[allow(unused_imports)]
                                            use pest3_core::typed::SubRule as _;
                                            super::Rule::r#b.cvt_into().cvt_into()
                                        }
                                        fn get_span(
                                            &self,
                                        ) -> (::pest3_core::std::usize, ::pest3_core::std::usize)
                                        {
                                            (self.span.start(), self.span.end())
                                        }
                                    }
                                    #[allow(non_camel_case_types)]
                                    impl<'i>
                                        ::pest3_core::typed::PairContainer<
                                            super::super::super::super::super::super::super::Rule,
                                        > for r#b<'i>
                                    {
                                        fn for_each_child_pair(
                                            &self,
                                            f : & mut impl :: pest3_core :: std :: FnMut (:: pest3_core :: token :: Pair < super :: super :: super :: super :: super :: super :: super :: Rule >),
                                        ) {
                                            self.content.for_self_or_for_each_child_pair(f)
                                        }
                                        fn for_self_or_for_each_child_pair(
                                            &self,
                                            f : & mut impl :: pest3_core :: std :: FnMut (:: pest3_core :: token :: Pair < super :: super :: super :: super :: super :: super :: super :: Rule >),
                                        ) {
                                            use pest3_core::typed::PairTree;
                                            f(self.as_pair_tree())
                                        }
                                    }
                                    #[allow(non_camel_case_types)]
                                    impl<'i>
                                        ::pest3_core::typed::PairTree<
                                            super::super::super::super::super::super::super::Rule,
                                        > for r#b<'i>
                                    {
                                        fn get_rule(
                                        ) -> super::super::super::super::super::super::super::Rule
                                        {
                                            #[allow(unused_imports)]
                                            use pest3_core::typed::SubRule as _;
                                            super::Rule::r#b.cvt_into().cvt_into().cvt_into()
                                        }
                                        fn get_span(
                                            &self,
                                        ) -> (::pest3_core::std::usize, ::pest3_core::std::usize)
                                        {
                                            (self.span.start(), self.span.end())
                                        }
                                    }
                                    #[allow(non_camel_case_types)]
                                    impl < 'i , > :: pest3_core :: typed :: PairContainer < super :: super :: super :: super :: super :: super :: super :: super :: super :: Rule > for r#b < 'i , > { fn for_each_child_pair (& self , f : & mut impl :: pest3_core :: std :: FnMut (:: pest3_core :: token :: Pair < super :: super :: super :: super :: super :: super :: super :: super :: super :: Rule >)) { self . content . for_self_or_for_each_child_pair (f) } fn for_self_or_for_each_child_pair (& self , f : & mut impl :: pest3_core :: std :: FnMut (:: pest3_core :: token :: Pair < super :: super :: super :: super :: super :: super :: super :: super :: super :: Rule >)) { use :: pest3_core :: typed :: PairTree ; f (self . as_pair_tree ()) } }
                                    #[allow(non_camel_case_types)]
                                    impl < 'i , > :: pest3_core :: typed :: PairTree < super :: super :: super :: super :: super :: super :: super :: super :: super :: Rule > for r#b < 'i , > { fn get_rule () -> super :: super :: super :: super :: super :: super :: super :: super :: super :: Rule { # [allow (unused_imports)] use :: pest3_core :: typed :: SubRule as _ ; super :: Rule :: r#b . cvt_into () . cvt_into () . cvt_into () . cvt_into () } fn get_span (& self) -> (:: pest3_core :: std :: usize , :: pest3_core :: std :: usize) { (self . span . start () , self . span . end ()) } }
                                }
                            }
                            impl ::pest3_core::typed::SubRule for b::Rule {
                                type Super = super::Rule;
                                fn cvt_into(self) -> Self::Super {
                                    super::Rule::b(self)
                                }
                            }
                            #[doc = "Generated for rule `c`. Grammar: `(a::a ~ b::b)`."]
                            #[derive(Clone, Debug, Eq, PartialEq)]
                            #[allow(non_camel_case_types)]
                            pub struct r#c < 'i , > { # [doc = r" Matched structure."] pub content : :: pest3_core :: std :: Box < super :: super :: super :: super :: super :: super :: super :: generics :: Sequence2 :: < a :: rules :: r#a :: < 'i > , :: pest3_core :: typed :: template :: Empty , b :: rules :: r#b :: < 'i > , __OptionalTrivia :: < 'i > , > > , # [doc = r" Matched span."] pub span : :: pest3_core :: Span < 'i > , }
                            #[allow(non_camel_case_types)]
                            impl<'i> ::pest3_core::typed::wrapper::Rule for r#c<'i> {
                                type Rule = super::Rule;
                                const RULE: super::Rule = super::Rule::r#c;
                            }
                            #[allow(non_camel_case_types)]
                            impl<'i> r#c<'i> {
                                #[doc = "A helper function to access [`a`]."]
                                #[allow(non_snake_case)]
                                pub fn r#a<'s>(&'s self) -> &'s a::rules::r#a<'i> {
                                    let res = &*self.content;
                                    {
                                        let res = &res.field_0;
                                        res
                                    }
                                }
                                #[doc = "A helper function to access [`b`]."]
                                #[allow(non_snake_case)]
                                pub fn r#b<'s>(&'s self) -> &'s b::rules::r#b<'i> {
                                    let res = &*self.content;
                                    {
                                        let res = &res.field_1;
                                        res
                                    }
                                }
                            }
                            #[allow(unused_imports)]
                            use pest3_core::typed::SubRule as _;
                            :: pest3_core :: typed :: full_rule_struct ! (r#c , () , super :: Rule , super :: Rule :: r#c , super :: super :: super :: super :: super :: super :: super :: generics :: Sequence2 :: < a :: rules :: r#a :: < 'i > , :: pest3_core :: typed :: template :: Empty , b :: rules :: r#b :: < 'i > , __OptionalTrivia :: < 'i > , > , :: pest3_core :: std :: Box < super :: super :: super :: super :: super :: super :: super :: generics :: Sequence2 :: < a :: rules :: r#a :: < 'i > , :: pest3_core :: typed :: template :: Empty , b :: rules :: r#b :: < 'i > , __OptionalTrivia :: < 'i > , > > ,) ;
                            #[allow(unused_imports)]
                            use pest3_core::typed::SubRule as _;
                            :: pest3_core :: typed :: full_rule_struct ! (r#c , () , super :: super :: super :: Rule , super :: Rule :: r#c . cvt_into () , super :: super :: super :: super :: super :: super :: super :: generics :: Sequence2 :: < a :: rules :: r#a :: < 'i > , :: pest3_core :: typed :: template :: Empty , b :: rules :: r#b :: < 'i > , __OptionalTrivia :: < 'i > , > , :: pest3_core :: std :: Box < super :: super :: super :: super :: super :: super :: super :: generics :: Sequence2 :: < a :: rules :: r#a :: < 'i > , :: pest3_core :: typed :: template :: Empty , b :: rules :: r#b :: < 'i > , __OptionalTrivia :: < 'i > , > > ,) ;
                            #[allow(unused_imports)]
                            use pest3_core::typed::SubRule as _;
                            :: pest3_core :: typed :: full_rule_struct ! (r#c , () , super :: super :: super :: super :: super :: Rule , super :: Rule :: r#c . cvt_into () . cvt_into () , super :: super :: super :: super :: super :: super :: super :: generics :: Sequence2 :: < a :: rules :: r#a :: < 'i > , :: pest3_core :: typed :: template :: Empty , b :: rules :: r#b :: < 'i > , __OptionalTrivia :: < 'i > , > , :: pest3_core :: std :: Box < super :: super :: super :: super :: super :: super :: super :: generics :: Sequence2 :: < a :: rules :: r#a :: < 'i > , :: pest3_core :: typed :: template :: Empty , b :: rules :: r#b :: < 'i > , __OptionalTrivia :: < 'i > , > > ,) ;
                            #[allow(unused_imports)]
                            use pest3_core::typed::SubRule as _;
                            :: pest3_core :: typed :: full_rule_struct ! (r#c , () , super :: super :: super :: super :: super :: super :: super :: Rule , super :: Rule :: r#c . cvt_into () . cvt_into () . cvt_into () , super :: super :: super :: super :: super :: super :: super :: generics :: Sequence2 :: < a :: rules :: r#a :: < 'i > , :: pest3_core :: typed :: template :: Empty , b :: rules :: r#b :: < 'i > , __OptionalTrivia :: < 'i > , > , :: pest3_core :: std :: Box < super :: super :: super :: super :: super :: super :: super :: generics :: Sequence2 :: < a :: rules :: r#a :: < 'i > , :: pest3_core :: typed :: template :: Empty , b :: rules :: r#b :: < 'i > , __OptionalTrivia :: < 'i > , > > ,) ;
                            #[allow(non_camel_case_types)]
                            impl<'i> ::pest3_core::typed::PairContainer<super::Rule> for r#c<'i> {
                                fn for_each_child_pair(
                                    &self,
                                    f: &mut impl ::pest3_core::std::FnMut(
                                        ::pest3_core::token::Pair<super::Rule>,
                                    ),
                                ) {
                                    self.content.for_self_or_for_each_child_pair(f)
                                }
                                fn for_self_or_for_each_child_pair(
                                    &self,
                                    f: &mut impl ::pest3_core::std::FnMut(
                                        ::pest3_core::token::Pair<super::Rule>,
                                    ),
                                ) {
                                    use pest3_core::typed::PairTree;
                                    f(self.as_pair_tree())
                                }
                            }
                            #[allow(non_camel_case_types)]
                            impl<'i> ::pest3_core::typed::PairTree<super::Rule> for r#c<'i> {
                                fn get_rule() -> super::Rule {
                                    #[allow(unused_imports)]
                                    use pest3_core::typed::SubRule as _;
                                    super::Rule::r#c
                                }
                                fn get_span(
                                    &self,
                                ) -> (::pest3_core::std::usize, ::pest3_core::std::usize)
                                {
                                    (self.span.start(), self.span.end())
                                }
                            }
                            #[allow(non_camel_case_types)]
                            impl<'i> ::pest3_core::typed::PairContainer<super::super::super::Rule> for r#c<'i> {
                                fn for_each_child_pair(
                                    &self,
                                    f: &mut impl ::pest3_core::std::FnMut(
                                        ::pest3_core::token::Pair<super::super::super::Rule>,
                                    ),
                                ) {
                                    self.content.for_self_or_for_each_child_pair(f)
                                }
                                fn for_self_or_for_each_child_pair(
                                    &self,
                                    f: &mut impl ::pest3_core::std::FnMut(
                                        ::pest3_core::token::Pair<super::super::super::Rule>,
                                    ),
                                ) {
                                    use pest3_core::typed::PairTree;
                                    f(self.as_pair_tree())
                                }
                            }
                            #[allow(non_camel_case_types)]
                            impl<'i> ::pest3_core::typed::PairTree<super::super::super::Rule> for r#c<'i> {
                                fn get_rule() -> super::super::super::Rule {
                                    #[allow(unused_imports)]
                                    use pest3_core::typed::SubRule as _;
                                    super::Rule::r#c.cvt_into()
                                }
                                fn get_span(
                                    &self,
                                ) -> (::pest3_core::std::usize, ::pest3_core::std::usize)
                                {
                                    (self.span.start(), self.span.end())
                                }
                            }
                            #[allow(non_camel_case_types)]
                            impl<'i>
                                ::pest3_core::typed::PairContainer<
                                    super::super::super::super::super::Rule,
                                > for r#c<'i>
                            {
                                fn for_each_child_pair(
                                    &self,
                                    f: &mut impl ::pest3_core::std::FnMut(
                                        ::pest3_core::token::Pair<
                                            super::super::super::super::super::Rule,
                                        >,
                                    ),
                                ) {
                                    self.content.for_self_or_for_each_child_pair(f)
                                }
                                fn for_self_or_for_each_child_pair(
                                    &self,
                                    f: &mut impl ::pest3_core::std::FnMut(
                                        ::pest3_core::token::Pair<
                                            super::super::super::super::super::Rule,
                                        >,
                                    ),
                                ) {
                                    use pest3_core::typed::PairTree;
                                    f(self.as_pair_tree())
                                }
                            }
                            #[allow(non_camel_case_types)]
                            impl<'i>
                                ::pest3_core::typed::PairTree<
                                    super::super::super::super::super::Rule,
                                > for r#c<'i>
                            {
                                fn get_rule() -> super::super::super::super::super::Rule {
                                    #[allow(unused_imports)]
                                    use pest3_core::typed::SubRule as _;
                                    super::Rule::r#c.cvt_into().cvt_into()
                                }
                                fn get_span(
                                    &self,
                                ) -> (::pest3_core::std::usize, ::pest3_core::std::usize)
                                {
                                    (self.span.start(), self.span.end())
                                }
                            }
                            #[allow(non_camel_case_types)]
                            impl<'i>
                                ::pest3_core::typed::PairContainer<
                                    super::super::super::super::super::super::super::Rule,
                                > for r#c<'i>
                            {
                                fn for_each_child_pair(
                                    &self,
                                    f: &mut impl ::pest3_core::std::FnMut(
                                        ::pest3_core::token::Pair<
                                            super::super::super::super::super::super::super::Rule,
                                        >,
                                    ),
                                ) {
                                    self.content.for_self_or_for_each_child_pair(f)
                                }
                                fn for_self_or_for_each_child_pair(
                                    &self,
                                    f: &mut impl ::pest3_core::std::FnMut(
                                        ::pest3_core::token::Pair<
                                            super::super::super::super::super::super::super::Rule,
                                        >,
                                    ),
                                ) {
                                    use pest3_core::typed::PairTree;
                                    f(self.as_pair_tree())
                                }
                            }
                            #[allow(non_camel_case_types)]
                            impl<'i>
                                ::pest3_core::typed::PairTree<
                                    super::super::super::super::super::super::super::Rule,
                                > for r#c<'i>
                            {
                                fn get_rule(
                                ) -> super::super::super::super::super::super::super::Rule
                                {
                                    #[allow(unused_imports)]
                                    use pest3_core::typed::SubRule as _;
                                    super::Rule::r#c.cvt_into().cvt_into().cvt_into()
                                }
                                fn get_span(
                                    &self,
                                ) -> (::pest3_core::std::usize, ::pest3_core::std::usize)
                                {
                                    (self.span.start(), self.span.end())
                                }
                            }
                        }
                    }
                    impl ::pest3_core::typed::SubRule for c::Rule {
                        type Super = super::Rule;
                        fn cvt_into(self) -> Self::Super {
                            super::Rule::c(self)
                        }
                    }
                    #[doc = "Generated for rule `e`. Grammar: `(a::a? - (_b::b~* - c::c^+))`."]
                    #[derive(Clone, Debug, Eq, PartialEq)]
                    #[allow(non_camel_case_types)]
                    pub struct r#e<'i> {
                        #[doc = r" Matched structure."]
                        pub content: ::pest3_core::std::Box<
                            super::super::super::super::super::generics::Sequence3<
                                ::pest3_core::std::Option<a::rules::r#a<'i>>,
                                ::pest3_core::typed::template::Empty,
                                super::super::super::super::super::generics::Rep<
                                    _b::rules::r#b<'i>,
                                    __OptionalTrivia<'i>,
                                >,
                                ::pest3_core::typed::template::Empty,
                                super::super::super::super::super::generics::RepOnce<
                                    c::rules::r#c<'i>,
                                    __MandatoryTrivia<'i>,
                                >,
                                ::pest3_core::typed::template::Empty,
                            >,
                        >,
                        #[doc = r" Matched span."]
                        pub span: ::pest3_core::Span<'i>,
                    }
                    #[allow(non_camel_case_types)]
                    impl<'i> ::pest3_core::typed::wrapper::Rule for r#e<'i> {
                        type Rule = super::Rule;
                        const RULE: super::Rule = super::Rule::r#e;
                    }
                    #[allow(non_camel_case_types)]
                    impl<'i> r#e<'i> {
                        #[doc = "A helper function to access [`a`]."]
                        #[allow(non_snake_case)]
                        pub fn r#a<'s>(
                            &'s self,
                        ) -> ::pest3_core::std::Option<&'s a::rules::r#a<'i>>
                        {
                            let res = &*self.content;
                            {
                                let res = &res.field_0;
                                {
                                    let res = res.as_ref().map(|res| res);
                                    res
                                }
                            }
                        }
                        #[doc = "A helper function to access [`b`]."]
                        #[allow(non_snake_case)]
                        pub fn r#b<'s>(&'s self) -> ::pest3_core::std::Vec<&'s _b::rules::r#b<'i>> {
                            let res = &*self.content;
                            {
                                let res = &res.field_1;
                                {
                                    let res = res
                                        .content
                                        .iter()
                                        .map(|res| res)
                                        .collect::<::pest3_core::std::Vec<_>>();
                                    res
                                }
                            }
                        }
                        #[doc = "A helper function to access [`c`]."]
                        #[allow(non_snake_case)]
                        pub fn r#c<'s>(&'s self) -> ::pest3_core::std::Vec<&'s c::rules::r#c<'i>> {
                            let res = &*self.content;
                            {
                                let res = &res.field_2;
                                {
                                    let res = res
                                        .content
                                        .iter()
                                        .map(|res| res)
                                        .collect::<::pest3_core::std::Vec<_>>();
                                    res
                                }
                            }
                        }
                    }
                    #[allow(unused_imports)]
                    use pest3_core::typed::SubRule as _;
                    ::pest3_core::typed::full_rule_struct!(
                        r#e,
                        (),
                        super::Rule,
                        super::Rule::r#e,
                        super::super::super::super::super::generics::Sequence3::<
                            ::pest3_core::std::Option::<a::rules::r#a::<'i>>,
                            ::pest3_core::typed::template::Empty,
                            super::super::super::super::super::generics::Rep::<
                                _b::rules::r#b::<'i>,
                                __OptionalTrivia::<'i>,
                            >,
                            ::pest3_core::typed::template::Empty,
                            super::super::super::super::super::generics::RepOnce::<
                                c::rules::r#c::<'i>,
                                __MandatoryTrivia::<'i>,
                            >,
                            ::pest3_core::typed::template::Empty,
                        >,
                        ::pest3_core::std::Box<
                            super::super::super::super::super::generics::Sequence3::<
                                ::pest3_core::std::Option::<a::rules::r#a::<'i>>,
                                ::pest3_core::typed::template::Empty,
                                super::super::super::super::super::generics::Rep::<
                                    _b::rules::r#b::<'i>,
                                    __OptionalTrivia::<'i>,
                                >,
                                ::pest3_core::typed::template::Empty,
                                super::super::super::super::super::generics::RepOnce::<
                                    c::rules::r#c::<'i>,
                                    __MandatoryTrivia::<'i>,
                                >,
                                ::pest3_core::typed::template::Empty,
                            >,
                        >,
                    );
                    #[allow(unused_imports)]
                    use pest3_core::typed::SubRule as _;
                    ::pest3_core::typed::full_rule_struct!(
                        r#e,
                        (),
                        super::super::super::Rule,
                        super::Rule::r#e.cvt_into(),
                        super::super::super::super::super::generics::Sequence3::<
                            ::pest3_core::std::Option::<a::rules::r#a::<'i>>,
                            ::pest3_core::typed::template::Empty,
                            super::super::super::super::super::generics::Rep::<
                                _b::rules::r#b::<'i>,
                                __OptionalTrivia::<'i>,
                            >,
                            ::pest3_core::typed::template::Empty,
                            super::super::super::super::super::generics::RepOnce::<
                                c::rules::r#c::<'i>,
                                __MandatoryTrivia::<'i>,
                            >,
                            ::pest3_core::typed::template::Empty,
                        >,
                        ::pest3_core::std::Box<
                            super::super::super::super::super::generics::Sequence3::<
                                ::pest3_core::std::Option::<a::rules::r#a::<'i>>,
                                ::pest3_core::typed::template::Empty,
                                super::super::super::super::super::generics::Rep::<
                                    _b::rules::r#b::<'i>,
                                    __OptionalTrivia::<'i>,
                                >,
                                ::pest3_core::typed::template::Empty,
                                super::super::super::super::super::generics::RepOnce::<
                                    c::rules::r#c::<'i>,
                                    __MandatoryTrivia::<'i>,
                                >,
                                ::pest3_core::typed::template::Empty,
                            >,
                        >,
                    );
                    #[allow(unused_imports)]
                    use pest3_core::typed::SubRule as _;
                    ::pest3_core::typed::full_rule_struct!(
                        r#e,
                        (),
                        super::super::super::super::super::Rule,
                        super::Rule::r#e.cvt_into().cvt_into(),
                        super::super::super::super::super::generics::Sequence3::<
                            ::pest3_core::std::Option::<a::rules::r#a::<'i>>,
                            ::pest3_core::typed::template::Empty,
                            super::super::super::super::super::generics::Rep::<
                                _b::rules::r#b::<'i>,
                                __OptionalTrivia::<'i>,
                            >,
                            ::pest3_core::typed::template::Empty,
                            super::super::super::super::super::generics::RepOnce::<
                                c::rules::r#c::<'i>,
                                __MandatoryTrivia::<'i>,
                            >,
                            ::pest3_core::typed::template::Empty,
                        >,
                        ::pest3_core::std::Box<
                            super::super::super::super::super::generics::Sequence3::<
                                ::pest3_core::std::Option::<a::rules::r#a::<'i>>,
                                ::pest3_core::typed::template::Empty,
                                super::super::super::super::super::generics::Rep::<
                                    _b::rules::r#b::<'i>,
                                    __OptionalTrivia::<'i>,
                                >,
                                ::pest3_core::typed::template::Empty,
                                super::super::super::super::super::generics::RepOnce::<
                                    c::rules::r#c::<'i>,
                                    __MandatoryTrivia::<'i>,
                                >,
                                ::pest3_core::typed::template::Empty,
                            >,
                        >,
                    );
                    #[allow(non_camel_case_types)]
                    impl<'i> ::pest3_core::typed::PairContainer<super::Rule> for r#e<'i> {
                        fn for_each_child_pair(
                            &self,
                            f: &mut impl ::pest3_core::std::FnMut(
                                ::pest3_core::token::Pair<super::Rule>,
                            ),
                        ) {
                            self.content.for_self_or_for_each_child_pair(f)
                        }
                        fn for_self_or_for_each_child_pair(
                            &self,
                            f: &mut impl ::pest3_core::std::FnMut(
                                ::pest3_core::token::Pair<super::Rule>,
                            ),
                        ) {
                            use pest3_core::typed::PairTree;
                            f(self.as_pair_tree())
                        }
                    }
                    #[allow(non_camel_case_types)]
                    impl<'i> ::pest3_core::typed::PairTree<super::Rule> for r#e<'i> {
                        fn get_rule() -> super::Rule {
                            #[allow(unused_imports)]
                            use pest3_core::typed::SubRule as _;
                            super::Rule::r#e
                        }
                        fn get_span(&self) -> (::pest3_core::std::usize, ::pest3_core::std::usize) {
                            (self.span.start(), self.span.end())
                        }
                    }
                    #[allow(non_camel_case_types)]
                    impl<'i> ::pest3_core::typed::PairContainer<super::super::super::Rule> for r#e<'i> {
                        fn for_each_child_pair(
                            &self,
                            f: &mut impl ::pest3_core::std::FnMut(
                                ::pest3_core::token::Pair<super::super::super::Rule>,
                            ),
                        ) {
                            self.content.for_self_or_for_each_child_pair(f)
                        }
                        fn for_self_or_for_each_child_pair(
                            &self,
                            f: &mut impl ::pest3_core::std::FnMut(
                                ::pest3_core::token::Pair<super::super::super::Rule>,
                            ),
                        ) {
                            use pest3_core::typed::PairTree;
                            f(self.as_pair_tree())
                        }
                    }
                    #[allow(non_camel_case_types)]
                    impl<'i> ::pest3_core::typed::PairTree<super::super::super::Rule> for r#e<'i> {
                        fn get_rule() -> super::super::super::Rule {
                            #[allow(unused_imports)]
                            use pest3_core::typed::SubRule as _;
                            super::Rule::r#e.cvt_into()
                        }
                        fn get_span(&self) -> (::pest3_core::std::usize, ::pest3_core::std::usize) {
                            (self.span.start(), self.span.end())
                        }
                    }
                    #[allow(non_camel_case_types)]
                    impl<'i>
                        ::pest3_core::typed::PairContainer<super::super::super::super::super::Rule>
                        for r#e<'i>
                    {
                        fn for_each_child_pair(
                            &self,
                            f: &mut impl ::pest3_core::std::FnMut(
                                ::pest3_core::token::Pair<super::super::super::super::super::Rule>,
                            ),
                        ) {
                            self.content.for_self_or_for_each_child_pair(f)
                        }
                        fn for_self_or_for_each_child_pair(
                            &self,
                            f: &mut impl ::pest3_core::std::FnMut(
                                ::pest3_core::token::Pair<super::super::super::super::super::Rule>,
                            ),
                        ) {
                            use pest3_core::typed::PairTree;
                            f(self.as_pair_tree())
                        }
                    }
                    #[allow(non_camel_case_types)]
                    impl<'i> ::pest3_core::typed::PairTree<super::super::super::super::super::Rule> for r#e<'i> {
                        fn get_rule() -> super::super::super::super::super::Rule {
                            #[allow(unused_imports)]
                            use pest3_core::typed::SubRule as _;
                            super::Rule::r#e.cvt_into().cvt_into()
                        }
                        fn get_span(&self) -> (::pest3_core::std::usize, ::pest3_core::std::usize) {
                            (self.span.start(), self.span.end())
                        }
                    }
                }
            }
            impl ::pest3_core::typed::SubRule for e::Rule {
                type Super = super::Rule;
                fn cvt_into(self) -> Self::Super {
                    super::Rule::e(self)
                }
            }
            #[doc = "Generated for rule `f`. Grammar: `(d::d | e::e)`."]
            #[derive(Clone, Debug, Eq, PartialEq)]
            #[allow(non_camel_case_types)]
            pub struct r#f<'i> {
                #[doc = r" Matched structure."]
                pub content: ::pest3_core::std::Box<
                    super::super::super::generics::Choice2<d::rules::r#d<'i>, e::rules::r#e<'i>>,
                >,
                #[doc = r" Matched span."]
                pub span: ::pest3_core::Span<'i>,
            }
            #[allow(non_camel_case_types)]
            impl<'i> ::pest3_core::typed::wrapper::Rule for r#f<'i> {
                type Rule = super::Rule;
                const RULE: super::Rule = super::Rule::r#f;
            }
            #[allow(non_camel_case_types)]
            impl<'i> r#f<'i> {
                #[doc = "A helper function to access [`d`]."]
                #[allow(non_snake_case)]
                pub fn r#d<'s>(&'s self) -> ::pest3_core::std::Option<&'s d::rules::r#d<'i>> {
                    let res = &*self.content;
                    {
                        let res = res.choice_0().map(|res| res);
                        res
                    }
                }
                #[doc = "A helper function to access [`e`]."]
                #[allow(non_snake_case)]
                pub fn r#e<'s>(&'s self) -> ::pest3_core::std::Option<&'s e::rules::r#e<'i>> {
                    let res = &*self.content;
                    {
                        let res = res.choice_1().map(|res| res);
                        res
                    }
                }
            }
            #[allow(unused_imports)]
            use pest3_core::typed::SubRule as _;
            ::pest3_core::typed::full_rule_struct!(
                r#f,
                (),
                super::Rule,
                super::Rule::r#f,
                super::super::super::generics::Choice2::<d::rules::r#d::<'i>, e::rules::r#e::<'i>>,
                ::pest3_core::std::Box<
                    super::super::super::generics::Choice2::<
                        d::rules::r#d::<'i>,
                        e::rules::r#e::<'i>,
                    >,
                >,
            );
            #[allow(unused_imports)]
            use pest3_core::typed::SubRule as _;
            ::pest3_core::typed::full_rule_struct!(
                r#f,
                (),
                super::super::super::Rule,
                super::Rule::r#f.cvt_into(),
                super::super::super::generics::Choice2::<d::rules::r#d::<'i>, e::rules::r#e::<'i>>,
                ::pest3_core::std::Box<
                    super::super::super::generics::Choice2::<
                        d::rules::r#d::<'i>,
                        e::rules::r#e::<'i>,
                    >,
                >,
            );
            #[allow(non_camel_case_types)]
            impl<'i> ::pest3_core::typed::PairContainer<super::Rule> for r#f<'i> {
                fn for_each_child_pair(
                    &self,
                    f: &mut impl ::pest3_core::std::FnMut(::pest3_core::token::Pair<super::Rule>),
                ) {
                    self.content.for_self_or_for_each_child_pair(f)
                }
                fn for_self_or_for_each_child_pair(
                    &self,
                    f: &mut impl ::pest3_core::std::FnMut(::pest3_core::token::Pair<super::Rule>),
                ) {
                    use pest3_core::typed::PairTree;
                    f(self.as_pair_tree())
                }
            }
            #[allow(non_camel_case_types)]
            impl<'i> ::pest3_core::typed::PairTree<super::Rule> for r#f<'i> {
                fn get_rule() -> super::Rule {
                    #[allow(unused_imports)]
                    use pest3_core::typed::SubRule as _;
                    super::Rule::r#f
                }
                fn get_span(&self) -> (::pest3_core::std::usize, ::pest3_core::std::usize) {
                    (self.span.start(), self.span.end())
                }
            }
            #[allow(non_camel_case_types)]
            impl<'i> ::pest3_core::typed::PairContainer<super::super::super::Rule> for r#f<'i> {
                fn for_each_child_pair(
                    &self,
                    f: &mut impl ::pest3_core::std::FnMut(
                        ::pest3_core::token::Pair<super::super::super::Rule>,
                    ),
                ) {
                    self.content.for_self_or_for_each_child_pair(f)
                }
                fn for_self_or_for_each_child_pair(
                    &self,
                    f: &mut impl ::pest3_core::std::FnMut(
                        ::pest3_core::token::Pair<super::super::super::Rule>,
                    ),
                ) {
                    use pest3_core::typed::PairTree;
                    f(self.as_pair_tree())
                }
            }
            #[allow(non_camel_case_types)]
            impl<'i> ::pest3_core::typed::PairTree<super::super::super::Rule> for r#f<'i> {
                fn get_rule() -> super::super::super::Rule {
                    #[allow(unused_imports)]
                    use pest3_core::typed::SubRule as _;
                    super::Rule::r#f.cvt_into()
                }
                fn get_span(&self) -> (::pest3_core::std::usize, ::pest3_core::std::usize) {
                    (self.span.start(), self.span.end())
                }
            }
        }
    }
    impl ::pest3_core::typed::SubRule for dag::Rule {
        type Super = super::Rule;
        fn cvt_into(self) -> Self::Super {
            super::Rule::dag(self)
        }
    }
    #[doc = "Generated for rule `main`. Grammar: `dag::f`."]
    #[derive(Clone, Debug, Eq, PartialEq)]
    #[allow(non_camel_case_types)]
    pub struct r#main<'i> {
        #[doc = r" Matched structure."]
        pub content: ::pest3_core::std::Box<dag::rules::r#f<'i>>,
        #[doc = r" Matched span."]
        pub span: ::pest3_core::Span<'i>,
    }
    #[allow(non_camel_case_types)]
    impl<'i> ::pest3_core::typed::wrapper::Rule for r#main<'i> {
        type Rule = super::Rule;
        const RULE: super::Rule = super::Rule::r#main;
    }
    #[allow(non_camel_case_types)]
    impl<'i> r#main<'i> {
        #[doc = "A helper function to access [`f`]."]
        #[allow(non_snake_case)]
        pub fn r#f<'s>(&'s self) -> &'s dag::rules::r#f<'i> {
            let res = &*self.content;
            res
        }
    }
    #[allow(unused_imports)]
    use pest3_core::typed::SubRule as _;
    ::pest3_core::typed::full_rule_struct!(
        r#main,
        (),
        super::Rule,
        super::Rule::r#main,
        dag::rules::r#f::<'i>,
        ::pest3_core::std::Box<dag::rules::r#f::<'i>>,
    );
    #[allow(non_camel_case_types)]
    impl<'i> ::pest3_core::typed::PairContainer<super::Rule> for r#main<'i> {
        fn for_each_child_pair(
            &self,
            f: &mut impl ::pest3_core::std::FnMut(::pest3_core::token::Pair<super::Rule>),
        ) {
            self.content.for_self_or_for_each_child_pair(f)
        }
        fn for_self_or_for_each_child_pair(
            &self,
            f: &mut impl ::pest3_core::std::FnMut(::pest3_core::token::Pair<super::Rule>),
        ) {
            use pest3_core::typed::PairTree;
            f(self.as_pair_tree())
        }
    }
    #[allow(non_camel_case_types)]
    impl<'i> ::pest3_core::typed::PairTree<super::Rule> for r#main<'i> {
        fn get_rule() -> super::Rule {
            #[allow(unused_imports)]
            use pest3_core::typed::SubRule as _;
            super::Rule::r#main
        }
        fn get_span(&self) -> (::pest3_core::std::usize, ::pest3_core::std::usize) {
            (self.span.start(), self.span.end())
        }
    }
}
mod wrapper {
    #[doc = "A wrapper for `\"a\"`."]
    #[derive(Clone, Debug, Hash, PartialEq, Eq)]
    pub struct W0;
    impl ::pest3_core::typed::wrapper::String for W0 {
        const CONTENT: &'static ::core::primitive::str = "a";
    }
    #[doc = "A wrapper for `\"~\"`."]
    #[derive(Clone, Debug, Hash, PartialEq, Eq)]
    pub struct W1;
    impl ::pest3_core::typed::wrapper::String for W1 {
        const CONTENT: &'static ::core::primitive::str = "~";
    }
    #[doc = "A wrapper for `\"b\"`."]
    #[derive(Clone, Debug, Hash, PartialEq, Eq)]
    pub struct W2;
    impl ::pest3_core::typed::wrapper::String for W2 {
        const CONTENT: &'static ::core::primitive::str = "b";
    }
    #[doc = "A wrapper for `\"^\"`."]
    #[derive(Clone, Debug, Hash, PartialEq, Eq)]
    pub struct W3;
    impl ::pest3_core::typed::wrapper::String for W3 {
        const CONTENT: &'static ::core::primitive::str = "^";
    }
    #[doc = "A wrapper for `\" \"`."]
    #[derive(Clone, Debug, Hash, PartialEq, Eq)]
    pub struct W4;
    impl ::pest3_core::typed::wrapper::String for W4 {
        const CONTENT: &'static ::core::primitive::str = " ";
    }
    #[doc = "A wrapper for `\",\"`."]
    #[derive(Clone, Debug, Hash, PartialEq, Eq)]
    pub struct W5;
    impl ::pest3_core::typed::wrapper::String for W5 {
        const CONTENT: &'static ::core::primitive::str = ",";
    }
}
pub use pest3_core::typed::unicode;
#[doc = "Used generics."]
pub mod generics {
    pub use pest3_core::choice::Choice2;
    pub use pest3_core::sequence::Sequence2;
    pub use pest3_core::sequence::Sequence3;
    pub use pest3_core::typed::template::{
        ascii, ascii_alpha, ascii_alpha_lower, ascii_alpha_upper, ascii_alphanumeric,
        ascii_bin_digit, ascii_digit, ascii_hex_digit, ascii_nonzero_digit, ascii_oct_digit,
        CharRange, Insens, Negative, PeekSlice1, PeekSlice2, Positive, Rep, RepMax, RepMin,
        RepMinMax, RepOnce, Str, ANY as any, DROP as drop, EOI, EOI as eoi, NEWLINE as newline,
        PEEK as peek, PEEK_ALL as peek_all, POP as pop, POP_ALL as pop_all, PUSH as push, SOI,
        SOI as soi,
    };
}
