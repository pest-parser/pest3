#[doc = "For compatibility."]
#[allow(dead_code, missing_docs, non_camel_case_types, clippy::upper_case_acronyms)]
#[derive(Clone, Copy, Debug, Eq, Hash, Ord, PartialEq, PartialOrd)]
pub enum Rule {
    EOI,
    #[doc = "Regular rule."]
    r#Regular,
    #[doc = "Atomic rule."]
    r#Atomic,
    #[doc = "Silent rule."]
    r#NonAtomic,
    r#ExactString,
    r#CharRange,
    r#Any,
    r#Seq,
    r#Choice,
    r#Rep,
    r#RepAtLeastOnce,
    r#Opt,
    r#RepExact,
    r#RepLeft,
    r#RepRight,
    r#RepLeftRight,
    r#Pos,
    r#Neg,
    r#Push,
    r#Pop,
    r#PopAll,
    r#Peek,
    r#PeekUnlimited,
    r#PeekLeft,
    r#PeekRight,
    r#PeekLeftRight,
    r#Drop,
    r#PeekAll,
}
impl ::pest::typed::RuleType for Rule {
    const EOI: Self = Rule::EOI;
    type OptionalTrivia<'i> = trivia::OptionalTrivia<'i>;
    type MandatoryTrivia<'i> = trivia::MandatoryTrivia<'i>;
}
mod trivia {
    pub type OptionalTrivia<'i> = super::generics::Rep<super::generics::Str<super::wrapper::W0>, 0u8>;
    pub type MandatoryTrivia<'i> = super::generics::RepOnce<super::generics::Str<super::wrapper::W0>, 0u8>;
}
mod wrapper {
    #[doc = "A wrapper for `\" \"`."]
    #[derive(Clone, Debug, Hash, PartialEq, Eq)]
    pub struct W0;
    impl ::pest::typed::wrapper::String for W0 {
        const CONTENT: &'static ::core::primitive::str = " ";
    }
    #[doc = "A wrapper for `\"+\"`."]
    #[derive(Clone, Debug, Hash, PartialEq, Eq)]
    pub struct W1;
    impl ::pest::typed::wrapper::String for W1 {
        const CONTENT: &'static ::core::primitive::str = "+";
    }
    #[doc = "A wrapper for `\"(\"`."]
    #[derive(Clone, Debug, Hash, PartialEq, Eq)]
    pub struct W2;
    impl ::pest::typed::wrapper::String for W2 {
        const CONTENT: &'static ::core::primitive::str = "(";
    }
    #[doc = "A wrapper for `\")\"`."]
    #[derive(Clone, Debug, Hash, PartialEq, Eq)]
    pub struct W3;
    impl ::pest::typed::wrapper::String for W3 {
        const CONTENT: &'static ::core::primitive::str = ")";
    }
    #[doc = "A wrapper for `\"r#\"`."]
    #[derive(Clone, Debug, Hash, PartialEq, Eq)]
    pub struct W4;
    impl ::pest::typed::wrapper::String for W4 {
        const CONTENT: &'static ::core::primitive::str = "r#";
    }
    #[doc = "A wrapper for `\"1\"`."]
    #[derive(Clone, Debug, Hash, PartialEq, Eq)]
    pub struct W5;
    impl ::pest::typed::wrapper::String for W5 {
        const CONTENT: &'static ::core::primitive::str = "1";
    }
    #[doc = "A wrapper for `\".\"`."]
    #[derive(Clone, Debug, Hash, PartialEq, Eq)]
    pub struct W6;
    impl ::pest::typed::wrapper::String for W6 {
        const CONTENT: &'static ::core::primitive::str = ".";
    }
    #[doc = "A wrapper for `\"a\"`."]
    #[derive(Clone, Debug, Hash, PartialEq, Eq)]
    pub struct W7;
    impl ::pest::typed::wrapper::String for W7 {
        const CONTENT: &'static ::core::primitive::str = "a";
    }
    #[doc = "A wrapper for `\"b\"`."]
    #[derive(Clone, Debug, Hash, PartialEq, Eq)]
    pub struct W8;
    impl ::pest::typed::wrapper::String for W8 {
        const CONTENT: &'static ::core::primitive::str = "b";
    }
    #[doc = "A wrapper for `\"c\"`."]
    #[derive(Clone, Debug, Hash, PartialEq, Eq)]
    pub struct W9;
    impl ::pest::typed::wrapper::String for W9 {
        const CONTENT: &'static ::core::primitive::str = "c";
    }
    #[doc = "A wrapper for `\"?\"`."]
    #[derive(Clone, Debug, Hash, PartialEq, Eq)]
    pub struct W10;
    impl ::pest::typed::wrapper::String for W10 {
        const CONTENT: &'static ::core::primitive::str = "?";
    }
}
#[doc = "Definitions of statically typed nodes generated by pest-generator."]
pub mod rules {
    #[doc = "Generated for rule `Regular`. Grammar: `'0'..'9'+`."]
    #[derive(Clone, Debug, Eq, PartialEq)]
    pub struct r#Regular<'i> {
        content: ::pest::std::Box<super::generics::RepOnce<super::generics::CharRange<'0', '9'>, 0u8>>,
        span: ::pest::Span<'i>,
    }
    impl<'i> ::pest::typed::wrapper::Rule<super::Rule> for r#Regular<'i> {
        type Rule = super::Rule;
        const RULE: super::Rule = super::Rule::r#Regular;
    }
    impl<'i> ::pest::typed::TypedNode<'i, super::Rule> for r#Regular<'i> {
        fn try_parse_with_partial(input: ::pest::Position<'i>, stack: &mut ::pest::Stack<::pest::Span<'i>>, tracker: &mut ::pest::typed::Tracker<'i, super::Rule>) -> ::pest::std::Option<(::pest::Position<'i>, Self)> {
            tracker.record_option_during(input, |tracker| {
                let (pos, content) = super::generics::RepOnce::<super::generics::CharRange<'0', '9'>, 0u8>::try_parse_with_partial(input, stack, tracker)?;
                let content = content.into();
                let span = input.span(&pos);
                ::pest::std::Some((pos, Self { content, span }))
            })
        }
    }
    impl<'i> ::pest::typed::PairContainer<super::Rule> for r#Regular<'i> {
        fn for_each_child_pair(&self, f: &mut impl ::pest::std::FnMut(::pest::token::Pair<super::Rule>)) {
            self.content.for_self_or_for_each_child_pair(f)
        }
        fn for_self_or_for_each_child_pair(&self, f: &mut impl ::pest::std::FnMut(::pest::token::Pair<super::Rule>)) {
            use pest::typed::PairTree;
            f(self.as_pair_tree())
        }
    }
    impl<'i> ::pest::typed::PairTree<super::Rule> for r#Regular<'i> {
        fn get_span(&self) -> (::pest::std::usize, ::pest::std::usize) {
            (self.span.start(), self.span.end())
        }
    }
    #[doc = "Generated for rule `Atomic`. Grammar: `(CharRange+ ~ (\"+\" ~ CharRange+))`."]
    #[derive(Clone, Debug, Eq, PartialEq)]
    pub struct r#Atomic<'i> {
        content: ::pest::std::Box<super::generics::Sequence3<super::generics::RepOnce<super::rules::CharRange<'i>, 0u8>, 0u8, super::generics::Str<super::wrapper::W1>, 1u8, super::generics::RepOnce<super::rules::CharRange<'i>, 0u8>, 1u8>>,
        span: ::pest::Span<'i>,
    }
    impl<'i> ::pest::typed::wrapper::Rule<super::Rule> for r#Atomic<'i> {
        type Rule = super::Rule;
        const RULE: super::Rule = super::Rule::r#Atomic;
    }
    impl<'i> ::pest::typed::TypedNode<'i, super::Rule> for r#Atomic<'i> {
        fn try_parse_with_partial(input: ::pest::Position<'i>, stack: &mut ::pest::Stack<::pest::Span<'i>>, tracker: &mut ::pest::typed::Tracker<'i, super::Rule>) -> ::pest::std::Option<(::pest::Position<'i>, Self)> {
            tracker.record_option_during(input, |tracker| {
                let (pos, content) = super::generics::Sequence3::<super::generics::RepOnce<super::rules::CharRange<'i>, 0u8>, 0u8, super::generics::Str<super::wrapper::W1>, 1u8, super::generics::RepOnce<super::rules::CharRange<'i>, 0u8>, 1u8>::try_parse_with_partial(input, stack, tracker)?;
                let content = content.into();
                let span = input.span(&pos);
                ::pest::std::Some((pos, Self { content, span }))
            })
        }
    }
    impl<'i> ::pest::typed::PairContainer<super::Rule> for r#Atomic<'i> {
        fn for_each_child_pair(&self, f: &mut impl ::pest::std::FnMut(::pest::token::Pair<super::Rule>)) {
            self.content.for_self_or_for_each_child_pair(f)
        }
        fn for_self_or_for_each_child_pair(&self, f: &mut impl ::pest::std::FnMut(::pest::token::Pair<super::Rule>)) {
            use pest::typed::PairTree;
            f(self.as_pair_tree())
        }
    }
    impl<'i> ::pest::typed::PairTree<super::Rule> for r#Atomic<'i> {
        fn get_span(&self) -> (::pest::std::usize, ::pest::std::usize) {
            (self.span.start(), self.span.end())
        }
    }
    #[doc = "Generated for rule `NonAtomic`. Grammar: `(\"(\" ^ \")\")`."]
    #[derive(Clone, Debug, Eq, PartialEq)]
    pub struct r#NonAtomic<'i> {
        content: ::pest::std::Box<super::generics::Sequence2<super::generics::Str<super::wrapper::W2>, 0u8, super::generics::Str<super::wrapper::W3>, 2u8>>,
        span: ::pest::Span<'i>,
    }
    impl<'i> ::pest::typed::wrapper::Rule<super::Rule> for r#NonAtomic<'i> {
        type Rule = super::Rule;
        const RULE: super::Rule = super::Rule::r#NonAtomic;
    }
    impl<'i> ::pest::typed::TypedNode<'i, super::Rule> for r#NonAtomic<'i> {
        fn try_parse_with_partial(input: ::pest::Position<'i>, stack: &mut ::pest::Stack<::pest::Span<'i>>, tracker: &mut ::pest::typed::Tracker<'i, super::Rule>) -> ::pest::std::Option<(::pest::Position<'i>, Self)> {
            tracker.record_option_during(input, |tracker| {
                let (pos, content) = super::generics::Sequence2::<super::generics::Str<super::wrapper::W2>, 0u8, super::generics::Str<super::wrapper::W3>, 2u8>::try_parse_with_partial(input, stack, tracker)?;
                let content = content.into();
                let span = input.span(&pos);
                ::pest::std::Some((pos, Self { content, span }))
            })
        }
    }
    impl<'i> ::pest::typed::PairContainer<super::Rule> for r#NonAtomic<'i> {
        fn for_each_child_pair(&self, f: &mut impl ::pest::std::FnMut(::pest::token::Pair<super::Rule>)) {
            self.content.for_self_or_for_each_child_pair(f)
        }
        fn for_self_or_for_each_child_pair(&self, f: &mut impl ::pest::std::FnMut(::pest::token::Pair<super::Rule>)) {
            use pest::typed::PairTree;
            f(self.as_pair_tree())
        }
    }
    impl<'i> ::pest::typed::PairTree<super::Rule> for r#NonAtomic<'i> {
        fn get_span(&self) -> (::pest::std::usize, ::pest::std::usize) {
            (self.span.start(), self.span.end())
        }
    }
    #[doc = "Generated for rule `ExactString`. Grammar: `\"r#\"`."]
    #[derive(Clone, Debug, Eq, PartialEq)]
    pub struct r#ExactString<'i> {
        content: ::pest::std::Box<super::generics::Str<super::wrapper::W4>>,
        span: ::pest::Span<'i>,
    }
    impl<'i> ::pest::typed::wrapper::Rule<super::Rule> for r#ExactString<'i> {
        type Rule = super::Rule;
        const RULE: super::Rule = super::Rule::r#ExactString;
    }
    impl<'i> ::pest::typed::TypedNode<'i, super::Rule> for r#ExactString<'i> {
        fn try_parse_with_partial(input: ::pest::Position<'i>, stack: &mut ::pest::Stack<::pest::Span<'i>>, tracker: &mut ::pest::typed::Tracker<'i, super::Rule>) -> ::pest::std::Option<(::pest::Position<'i>, Self)> {
            tracker.record_option_during(input, |tracker| {
                let (pos, content) = super::generics::Str::<super::wrapper::W4>::try_parse_with_partial(input, stack, tracker)?;
                let content = content.into();
                let span = input.span(&pos);
                ::pest::std::Some((pos, Self { content, span }))
            })
        }
    }
    impl<'i> ::pest::typed::PairContainer<super::Rule> for r#ExactString<'i> {
        fn for_each_child_pair(&self, f: &mut impl ::pest::std::FnMut(::pest::token::Pair<super::Rule>)) {
            self.content.for_self_or_for_each_child_pair(f)
        }
        fn for_self_or_for_each_child_pair(&self, f: &mut impl ::pest::std::FnMut(::pest::token::Pair<super::Rule>)) {
            use pest::typed::PairTree;
            f(self.as_pair_tree())
        }
    }
    impl<'i> ::pest::typed::PairTree<super::Rule> for r#ExactString<'i> {
        fn get_span(&self) -> (::pest::std::usize, ::pest::std::usize) {
            (self.span.start(), self.span.end())
        }
    }
    #[doc = "Generated for rule `CharRange`. Grammar: `'0'..'9'`."]
    #[derive(Clone, Debug, Eq, PartialEq)]
    pub struct r#CharRange<'i> {
        content: ::pest::std::Box<super::generics::CharRange<'0', '9'>>,
        span: ::pest::Span<'i>,
    }
    impl<'i> ::pest::typed::wrapper::Rule<super::Rule> for r#CharRange<'i> {
        type Rule = super::Rule;
        const RULE: super::Rule = super::Rule::r#CharRange;
    }
    impl<'i> ::pest::typed::TypedNode<'i, super::Rule> for r#CharRange<'i> {
        fn try_parse_with_partial(input: ::pest::Position<'i>, stack: &mut ::pest::Stack<::pest::Span<'i>>, tracker: &mut ::pest::typed::Tracker<'i, super::Rule>) -> ::pest::std::Option<(::pest::Position<'i>, Self)> {
            tracker.record_option_during(input, |tracker| {
                let (pos, content) = super::generics::CharRange::<'0', '9'>::try_parse_with_partial(input, stack, tracker)?;
                let content = content.into();
                let span = input.span(&pos);
                ::pest::std::Some((pos, Self { content, span }))
            })
        }
    }
    impl<'i> ::pest::typed::PairContainer<super::Rule> for r#CharRange<'i> {
        fn for_each_child_pair(&self, f: &mut impl ::pest::std::FnMut(::pest::token::Pair<super::Rule>)) {
            self.content.for_self_or_for_each_child_pair(f)
        }
        fn for_self_or_for_each_child_pair(&self, f: &mut impl ::pest::std::FnMut(::pest::token::Pair<super::Rule>)) {
            use pest::typed::PairTree;
            f(self.as_pair_tree())
        }
    }
    impl<'i> ::pest::typed::PairTree<super::Rule> for r#CharRange<'i> {
        fn get_span(&self) -> (::pest::std::usize, ::pest::std::usize) {
            (self.span.start(), self.span.end())
        }
    }
    #[doc = "Generated for rule `Any`. Grammar: `pest::any`."]
    #[derive(Clone, Debug, Eq, PartialEq)]
    pub struct r#Any<'i> {
        content: ::pest::std::Box<super::generics::r#any>,
        span: ::pest::Span<'i>,
    }
    impl<'i> ::pest::typed::wrapper::Rule<super::Rule> for r#Any<'i> {
        type Rule = super::Rule;
        const RULE: super::Rule = super::Rule::r#Any;
    }
    impl<'i> ::pest::typed::TypedNode<'i, super::Rule> for r#Any<'i> {
        fn try_parse_with_partial(input: ::pest::Position<'i>, stack: &mut ::pest::Stack<::pest::Span<'i>>, tracker: &mut ::pest::typed::Tracker<'i, super::Rule>) -> ::pest::std::Option<(::pest::Position<'i>, Self)> {
            tracker.record_option_during(input, |tracker| {
                let (pos, content) = super::generics::r#any::try_parse_with_partial(input, stack, tracker)?;
                let content = content.into();
                let span = input.span(&pos);
                ::pest::std::Some((pos, Self { content, span }))
            })
        }
    }
    impl<'i> ::pest::typed::PairContainer<super::Rule> for r#Any<'i> {
        fn for_each_child_pair(&self, f: &mut impl ::pest::std::FnMut(::pest::token::Pair<super::Rule>)) {
            self.content.for_self_or_for_each_child_pair(f)
        }
        fn for_self_or_for_each_child_pair(&self, f: &mut impl ::pest::std::FnMut(::pest::token::Pair<super::Rule>)) {
            use pest::typed::PairTree;
            f(self.as_pair_tree())
        }
    }
    impl<'i> ::pest::typed::PairTree<super::Rule> for r#Any<'i> {
        fn get_span(&self) -> (::pest::std::usize, ::pest::std::usize) {
            (self.span.start(), self.span.end())
        }
    }
    #[doc = "Generated for rule `Seq`. Grammar: `(\"1\" ~ ('2'..'9' ~ \".\"))`."]
    #[derive(Clone, Debug, Eq, PartialEq)]
    pub struct r#Seq<'i> {
        content: ::pest::std::Box<super::generics::Sequence3<super::generics::Str<super::wrapper::W5>, 0u8, super::generics::CharRange<'2', '9'>, 1u8, super::generics::Str<super::wrapper::W6>, 1u8>>,
        span: ::pest::Span<'i>,
    }
    impl<'i> ::pest::typed::wrapper::Rule<super::Rule> for r#Seq<'i> {
        type Rule = super::Rule;
        const RULE: super::Rule = super::Rule::r#Seq;
    }
    impl<'i> ::pest::typed::TypedNode<'i, super::Rule> for r#Seq<'i> {
        fn try_parse_with_partial(input: ::pest::Position<'i>, stack: &mut ::pest::Stack<::pest::Span<'i>>, tracker: &mut ::pest::typed::Tracker<'i, super::Rule>) -> ::pest::std::Option<(::pest::Position<'i>, Self)> {
            tracker.record_option_during(input, |tracker| {
                let (pos, content) = super::generics::Sequence3::<super::generics::Str<super::wrapper::W5>, 0u8, super::generics::CharRange<'2', '9'>, 1u8, super::generics::Str<super::wrapper::W6>, 1u8>::try_parse_with_partial(input, stack, tracker)?;
                let content = content.into();
                let span = input.span(&pos);
                ::pest::std::Some((pos, Self { content, span }))
            })
        }
    }
    impl<'i> ::pest::typed::PairContainer<super::Rule> for r#Seq<'i> {
        fn for_each_child_pair(&self, f: &mut impl ::pest::std::FnMut(::pest::token::Pair<super::Rule>)) {
            self.content.for_self_or_for_each_child_pair(f)
        }
        fn for_self_or_for_each_child_pair(&self, f: &mut impl ::pest::std::FnMut(::pest::token::Pair<super::Rule>)) {
            use pest::typed::PairTree;
            f(self.as_pair_tree())
        }
    }
    impl<'i> ::pest::typed::PairTree<super::Rule> for r#Seq<'i> {
        fn get_span(&self) -> (::pest::std::usize, ::pest::std::usize) {
            (self.span.start(), self.span.end())
        }
    }
    #[doc = "Generated for rule `Choice`. Grammar: `(\"a\" | ((\"b\"+ ~ RepAtLeastOnce) | ((&\"c\" ~ (Choice ~ (Rep ~ Opt))) | (Peek | (PeekLeft | (PeekRight | (PeekLeftRight | (Drop | PeekAll))))))))`."]
    #[derive(Clone, Debug, Eq, PartialEq)]
    pub struct r#Choice<'i> {
        content: ::pest::std::Box<super::generics::Choice9<super::generics::Str<super::wrapper::W7>, super::generics::Sequence2<super::generics::RepOnce<super::generics::Str<super::wrapper::W8>, 0u8>, 0u8, super::rules::RepAtLeastOnce<'i>, 1u8>, super::generics::Sequence4<super::generics::Positive<super::generics::Str<super::wrapper::W9>>, 0u8, super::rules::Choice<'i>, 1u8, super::rules::Rep<'i>, 1u8, super::rules::Opt<'i>, 1u8>, super::rules::Peek<'i>, super::rules::PeekLeft<'i>, super::rules::PeekRight<'i>, super::rules::PeekLeftRight<'i>, super::rules::Drop<'i>, super::rules::PeekAll<'i>>>,
        span: ::pest::Span<'i>,
    }
    impl<'i> ::pest::typed::wrapper::Rule<super::Rule> for r#Choice<'i> {
        type Rule = super::Rule;
        const RULE: super::Rule = super::Rule::r#Choice;
    }
    impl<'i> ::pest::typed::TypedNode<'i, super::Rule> for r#Choice<'i> {
        fn try_parse_with_partial(input: ::pest::Position<'i>, stack: &mut ::pest::Stack<::pest::Span<'i>>, tracker: &mut ::pest::typed::Tracker<'i, super::Rule>) -> ::pest::std::Option<(::pest::Position<'i>, Self)> {
            tracker.record_option_during(input, |tracker| {
                let (pos, content) = super::generics::Choice9::<super::generics::Str<super::wrapper::W7>, super::generics::Sequence2<super::generics::RepOnce<super::generics::Str<super::wrapper::W8>, 0u8>, 0u8, super::rules::RepAtLeastOnce<'i>, 1u8>, super::generics::Sequence4<super::generics::Positive<super::generics::Str<super::wrapper::W9>>, 0u8, super::rules::Choice<'i>, 1u8, super::rules::Rep<'i>, 1u8, super::rules::Opt<'i>, 1u8>, super::rules::Peek<'i>, super::rules::PeekLeft<'i>, super::rules::PeekRight<'i>, super::rules::PeekLeftRight<'i>, super::rules::Drop<'i>, super::rules::PeekAll<'i>>::try_parse_with_partial(input, stack, tracker)?;
                let content = content.into();
                let span = input.span(&pos);
                ::pest::std::Some((pos, Self { content, span }))
            })
        }
    }
    impl<'i> ::pest::typed::PairContainer<super::Rule> for r#Choice<'i> {
        fn for_each_child_pair(&self, f: &mut impl ::pest::std::FnMut(::pest::token::Pair<super::Rule>)) {
            self.content.for_self_or_for_each_child_pair(f)
        }
        fn for_self_or_for_each_child_pair(&self, f: &mut impl ::pest::std::FnMut(::pest::token::Pair<super::Rule>)) {
            use pest::typed::PairTree;
            f(self.as_pair_tree())
        }
    }
    impl<'i> ::pest::typed::PairTree<super::Rule> for r#Choice<'i> {
        fn get_span(&self) -> (::pest::std::usize, ::pest::std::usize) {
            (self.span.start(), self.span.end())
        }
    }
    #[doc = "Generated for rule `Rep`. Grammar: `\"b\"*`."]
    #[derive(Clone, Debug, Eq, PartialEq)]
    pub struct r#Rep<'i> {
        content: ::pest::std::Box<super::generics::Rep<super::generics::Str<super::wrapper::W8>, 0u8>>,
        span: ::pest::Span<'i>,
    }
    impl<'i> ::pest::typed::wrapper::Rule<super::Rule> for r#Rep<'i> {
        type Rule = super::Rule;
        const RULE: super::Rule = super::Rule::r#Rep;
    }
    impl<'i> ::pest::typed::TypedNode<'i, super::Rule> for r#Rep<'i> {
        fn try_parse_with_partial(input: ::pest::Position<'i>, stack: &mut ::pest::Stack<::pest::Span<'i>>, tracker: &mut ::pest::typed::Tracker<'i, super::Rule>) -> ::pest::std::Option<(::pest::Position<'i>, Self)> {
            tracker.record_option_during(input, |tracker| {
                let (pos, content) = super::generics::Rep::<super::generics::Str<super::wrapper::W8>, 0u8>::try_parse_with_partial(input, stack, tracker)?;
                let content = content.into();
                let span = input.span(&pos);
                ::pest::std::Some((pos, Self { content, span }))
            })
        }
    }
    impl<'i> ::pest::typed::PairContainer<super::Rule> for r#Rep<'i> {
        fn for_each_child_pair(&self, f: &mut impl ::pest::std::FnMut(::pest::token::Pair<super::Rule>)) {
            self.content.for_self_or_for_each_child_pair(f)
        }
        fn for_self_or_for_each_child_pair(&self, f: &mut impl ::pest::std::FnMut(::pest::token::Pair<super::Rule>)) {
            use pest::typed::PairTree;
            f(self.as_pair_tree())
        }
    }
    impl<'i> ::pest::typed::PairTree<super::Rule> for r#Rep<'i> {
        fn get_span(&self) -> (::pest::std::usize, ::pest::std::usize) {
            (self.span.start(), self.span.end())
        }
    }
    #[doc = "Generated for rule `RepAtLeastOnce`. Grammar: `'0'..'9'+`."]
    #[derive(Clone, Debug, Eq, PartialEq)]
    pub struct r#RepAtLeastOnce<'i> {
        content: ::pest::std::Box<super::generics::RepOnce<super::generics::CharRange<'0', '9'>, 0u8>>,
        span: ::pest::Span<'i>,
    }
    impl<'i> ::pest::typed::wrapper::Rule<super::Rule> for r#RepAtLeastOnce<'i> {
        type Rule = super::Rule;
        const RULE: super::Rule = super::Rule::r#RepAtLeastOnce;
    }
    impl<'i> ::pest::typed::TypedNode<'i, super::Rule> for r#RepAtLeastOnce<'i> {
        fn try_parse_with_partial(input: ::pest::Position<'i>, stack: &mut ::pest::Stack<::pest::Span<'i>>, tracker: &mut ::pest::typed::Tracker<'i, super::Rule>) -> ::pest::std::Option<(::pest::Position<'i>, Self)> {
            tracker.record_option_during(input, |tracker| {
                let (pos, content) = super::generics::RepOnce::<super::generics::CharRange<'0', '9'>, 0u8>::try_parse_with_partial(input, stack, tracker)?;
                let content = content.into();
                let span = input.span(&pos);
                ::pest::std::Some((pos, Self { content, span }))
            })
        }
    }
    impl<'i> ::pest::typed::PairContainer<super::Rule> for r#RepAtLeastOnce<'i> {
        fn for_each_child_pair(&self, f: &mut impl ::pest::std::FnMut(::pest::token::Pair<super::Rule>)) {
            self.content.for_self_or_for_each_child_pair(f)
        }
        fn for_self_or_for_each_child_pair(&self, f: &mut impl ::pest::std::FnMut(::pest::token::Pair<super::Rule>)) {
            use pest::typed::PairTree;
            f(self.as_pair_tree())
        }
    }
    impl<'i> ::pest::typed::PairTree<super::Rule> for r#RepAtLeastOnce<'i> {
        fn get_span(&self) -> (::pest::std::usize, ::pest::std::usize) {
            (self.span.start(), self.span.end())
        }
    }
    #[doc = "Generated for rule `Opt`. Grammar: `\"?\"?`."]
    #[derive(Clone, Debug, Eq, PartialEq)]
    pub struct r#Opt<'i> {
        content: ::pest::std::Box<::pest::std::Option<super::generics::Str<super::wrapper::W10>>>,
        span: ::pest::Span<'i>,
    }
    impl<'i> ::pest::typed::wrapper::Rule<super::Rule> for r#Opt<'i> {
        type Rule = super::Rule;
        const RULE: super::Rule = super::Rule::r#Opt;
    }
    impl<'i> ::pest::typed::TypedNode<'i, super::Rule> for r#Opt<'i> {
        fn try_parse_with_partial(input: ::pest::Position<'i>, stack: &mut ::pest::Stack<::pest::Span<'i>>, tracker: &mut ::pest::typed::Tracker<'i, super::Rule>) -> ::pest::std::Option<(::pest::Position<'i>, Self)> {
            tracker.record_option_during(input, |tracker| {
                let (pos, content) = ::pest::std::Option::<super::generics::Str<super::wrapper::W10>>::try_parse_with_partial(input, stack, tracker)?;
                let content = content.into();
                let span = input.span(&pos);
                ::pest::std::Some((pos, Self { content, span }))
            })
        }
    }
    impl<'i> ::pest::typed::PairContainer<super::Rule> for r#Opt<'i> {
        fn for_each_child_pair(&self, f: &mut impl ::pest::std::FnMut(::pest::token::Pair<super::Rule>)) {
            self.content.for_self_or_for_each_child_pair(f)
        }
        fn for_self_or_for_each_child_pair(&self, f: &mut impl ::pest::std::FnMut(::pest::token::Pair<super::Rule>)) {
            use pest::typed::PairTree;
            f(self.as_pair_tree())
        }
    }
    impl<'i> ::pest::typed::PairTree<super::Rule> for r#Opt<'i> {
        fn get_span(&self) -> (::pest::std::usize, ::pest::std::usize) {
            (self.span.start(), self.span.end())
        }
    }
    #[doc = "Generated for rule `RepExact`. Grammar: `RepAtLeastOnce[3..3]`."]
    #[derive(Clone, Debug, Eq, PartialEq)]
    pub struct r#RepExact<'i> {
        content: ::pest::std::Box<super::generics::RepMinMax<super::rules::RepAtLeastOnce<'i>, 0u8, 3usize, 3usize>>,
        span: ::pest::Span<'i>,
    }
    impl<'i> ::pest::typed::wrapper::Rule<super::Rule> for r#RepExact<'i> {
        type Rule = super::Rule;
        const RULE: super::Rule = super::Rule::r#RepExact;
    }
    impl<'i> ::pest::typed::TypedNode<'i, super::Rule> for r#RepExact<'i> {
        fn try_parse_with_partial(input: ::pest::Position<'i>, stack: &mut ::pest::Stack<::pest::Span<'i>>, tracker: &mut ::pest::typed::Tracker<'i, super::Rule>) -> ::pest::std::Option<(::pest::Position<'i>, Self)> {
            tracker.record_option_during(input, |tracker| {
                let (pos, content) = super::generics::RepMinMax::<super::rules::RepAtLeastOnce<'i>, 0u8, 3usize, 3usize>::try_parse_with_partial(input, stack, tracker)?;
                let content = content.into();
                let span = input.span(&pos);
                ::pest::std::Some((pos, Self { content, span }))
            })
        }
    }
    impl<'i> ::pest::typed::PairContainer<super::Rule> for r#RepExact<'i> {
        fn for_each_child_pair(&self, f: &mut impl ::pest::std::FnMut(::pest::token::Pair<super::Rule>)) {
            self.content.for_self_or_for_each_child_pair(f)
        }
        fn for_self_or_for_each_child_pair(&self, f: &mut impl ::pest::std::FnMut(::pest::token::Pair<super::Rule>)) {
            use pest::typed::PairTree;
            f(self.as_pair_tree())
        }
    }
    impl<'i> ::pest::typed::PairTree<super::Rule> for r#RepExact<'i> {
        fn get_span(&self) -> (::pest::std::usize, ::pest::std::usize) {
            (self.span.start(), self.span.end())
        }
    }
    #[doc = "Generated for rule `RepLeft`. Grammar: `RepExact[1..]`."]
    #[derive(Clone, Debug, Eq, PartialEq)]
    pub struct r#RepLeft<'i> {
        content: ::pest::std::Box<super::generics::RepMin<super::rules::RepExact<'i>, 0u8, 1usize>>,
        span: ::pest::Span<'i>,
    }
    impl<'i> ::pest::typed::wrapper::Rule<super::Rule> for r#RepLeft<'i> {
        type Rule = super::Rule;
        const RULE: super::Rule = super::Rule::r#RepLeft;
    }
    impl<'i> ::pest::typed::TypedNode<'i, super::Rule> for r#RepLeft<'i> {
        fn try_parse_with_partial(input: ::pest::Position<'i>, stack: &mut ::pest::Stack<::pest::Span<'i>>, tracker: &mut ::pest::typed::Tracker<'i, super::Rule>) -> ::pest::std::Option<(::pest::Position<'i>, Self)> {
            tracker.record_option_during(input, |tracker| {
                let (pos, content) = super::generics::RepMin::<super::rules::RepExact<'i>, 0u8, 1usize>::try_parse_with_partial(input, stack, tracker)?;
                let content = content.into();
                let span = input.span(&pos);
                ::pest::std::Some((pos, Self { content, span }))
            })
        }
    }
    impl<'i> ::pest::typed::PairContainer<super::Rule> for r#RepLeft<'i> {
        fn for_each_child_pair(&self, f: &mut impl ::pest::std::FnMut(::pest::token::Pair<super::Rule>)) {
            self.content.for_self_or_for_each_child_pair(f)
        }
        fn for_self_or_for_each_child_pair(&self, f: &mut impl ::pest::std::FnMut(::pest::token::Pair<super::Rule>)) {
            use pest::typed::PairTree;
            f(self.as_pair_tree())
        }
    }
    impl<'i> ::pest::typed::PairTree<super::Rule> for r#RepLeft<'i> {
        fn get_span(&self) -> (::pest::std::usize, ::pest::std::usize) {
            (self.span.start(), self.span.end())
        }
    }
    #[doc = "Generated for rule `RepRight`. Grammar: `RepLeft[..2]`."]
    #[derive(Clone, Debug, Eq, PartialEq)]
    pub struct r#RepRight<'i> {
        content: ::pest::std::Box<super::generics::RepMax<super::rules::RepLeft<'i>, 0u8, 2usize>>,
        span: ::pest::Span<'i>,
    }
    impl<'i> ::pest::typed::wrapper::Rule<super::Rule> for r#RepRight<'i> {
        type Rule = super::Rule;
        const RULE: super::Rule = super::Rule::r#RepRight;
    }
    impl<'i> ::pest::typed::TypedNode<'i, super::Rule> for r#RepRight<'i> {
        fn try_parse_with_partial(input: ::pest::Position<'i>, stack: &mut ::pest::Stack<::pest::Span<'i>>, tracker: &mut ::pest::typed::Tracker<'i, super::Rule>) -> ::pest::std::Option<(::pest::Position<'i>, Self)> {
            tracker.record_option_during(input, |tracker| {
                let (pos, content) = super::generics::RepMax::<super::rules::RepLeft<'i>, 0u8, 2usize>::try_parse_with_partial(input, stack, tracker)?;
                let content = content.into();
                let span = input.span(&pos);
                ::pest::std::Some((pos, Self { content, span }))
            })
        }
    }
    impl<'i> ::pest::typed::PairContainer<super::Rule> for r#RepRight<'i> {
        fn for_each_child_pair(&self, f: &mut impl ::pest::std::FnMut(::pest::token::Pair<super::Rule>)) {
            self.content.for_self_or_for_each_child_pair(f)
        }
        fn for_self_or_for_each_child_pair(&self, f: &mut impl ::pest::std::FnMut(::pest::token::Pair<super::Rule>)) {
            use pest::typed::PairTree;
            f(self.as_pair_tree())
        }
    }
    impl<'i> ::pest::typed::PairTree<super::Rule> for r#RepRight<'i> {
        fn get_span(&self) -> (::pest::std::usize, ::pest::std::usize) {
            (self.span.start(), self.span.end())
        }
    }
    #[doc = "Generated for rule `RepLeftRight`. Grammar: `RepRight[1..2]`."]
    #[derive(Clone, Debug, Eq, PartialEq)]
    pub struct r#RepLeftRight<'i> {
        content: ::pest::std::Box<super::generics::RepMinMax<super::rules::RepRight<'i>, 0u8, 1usize, 2usize>>,
        span: ::pest::Span<'i>,
    }
    impl<'i> ::pest::typed::wrapper::Rule<super::Rule> for r#RepLeftRight<'i> {
        type Rule = super::Rule;
        const RULE: super::Rule = super::Rule::r#RepLeftRight;
    }
    impl<'i> ::pest::typed::TypedNode<'i, super::Rule> for r#RepLeftRight<'i> {
        fn try_parse_with_partial(input: ::pest::Position<'i>, stack: &mut ::pest::Stack<::pest::Span<'i>>, tracker: &mut ::pest::typed::Tracker<'i, super::Rule>) -> ::pest::std::Option<(::pest::Position<'i>, Self)> {
            tracker.record_option_during(input, |tracker| {
                let (pos, content) = super::generics::RepMinMax::<super::rules::RepRight<'i>, 0u8, 1usize, 2usize>::try_parse_with_partial(input, stack, tracker)?;
                let content = content.into();
                let span = input.span(&pos);
                ::pest::std::Some((pos, Self { content, span }))
            })
        }
    }
    impl<'i> ::pest::typed::PairContainer<super::Rule> for r#RepLeftRight<'i> {
        fn for_each_child_pair(&self, f: &mut impl ::pest::std::FnMut(::pest::token::Pair<super::Rule>)) {
            self.content.for_self_or_for_each_child_pair(f)
        }
        fn for_self_or_for_each_child_pair(&self, f: &mut impl ::pest::std::FnMut(::pest::token::Pair<super::Rule>)) {
            use pest::typed::PairTree;
            f(self.as_pair_tree())
        }
    }
    impl<'i> ::pest::typed::PairTree<super::Rule> for r#RepLeftRight<'i> {
        fn get_span(&self) -> (::pest::std::usize, ::pest::std::usize) {
            (self.span.start(), self.span.end())
        }
    }
    #[doc = "Generated for rule `Pos`. Grammar: `&(pest::SOI ~ RepLeftRight[2..4])`."]
    #[derive(Clone, Debug, Eq, PartialEq)]
    pub struct r#Pos<'i> {
        content: ::pest::std::Box<super::generics::Positive<super::generics::Sequence2<super::generics::r#SOI, 0u8, super::generics::RepMinMax<super::rules::RepLeftRight<'i>, 0u8, 2usize, 4usize>, 1u8>>>,
        span: ::pest::Span<'i>,
    }
    impl<'i> ::pest::typed::wrapper::Rule<super::Rule> for r#Pos<'i> {
        type Rule = super::Rule;
        const RULE: super::Rule = super::Rule::r#Pos;
    }
    impl<'i> ::pest::typed::TypedNode<'i, super::Rule> for r#Pos<'i> {
        fn try_parse_with_partial(input: ::pest::Position<'i>, stack: &mut ::pest::Stack<::pest::Span<'i>>, tracker: &mut ::pest::typed::Tracker<'i, super::Rule>) -> ::pest::std::Option<(::pest::Position<'i>, Self)> {
            tracker.record_option_during(input, |tracker| {
                let (pos, content) = super::generics::Positive::<super::generics::Sequence2<super::generics::r#SOI, 0u8, super::generics::RepMinMax<super::rules::RepLeftRight<'i>, 0u8, 2usize, 4usize>, 1u8>>::try_parse_with_partial(input, stack, tracker)?;
                let content = content.into();
                let span = input.span(&pos);
                ::pest::std::Some((pos, Self { content, span }))
            })
        }
    }
    impl<'i> ::pest::typed::PairContainer<super::Rule> for r#Pos<'i> {
        fn for_each_child_pair(&self, f: &mut impl ::pest::std::FnMut(::pest::token::Pair<super::Rule>)) {
            self.content.for_self_or_for_each_child_pair(f)
        }
        fn for_self_or_for_each_child_pair(&self, f: &mut impl ::pest::std::FnMut(::pest::token::Pair<super::Rule>)) {
            use pest::typed::PairTree;
            f(self.as_pair_tree())
        }
    }
    impl<'i> ::pest::typed::PairTree<super::Rule> for r#Pos<'i> {
        fn get_span(&self) -> (::pest::std::usize, ::pest::std::usize) {
            (self.span.start(), self.span.end())
        }
    }
    #[doc = "Generated for rule `Neg`. Grammar: `!(pest::EOI ~ Pos)`."]
    #[derive(Clone, Debug, Eq, PartialEq)]
    pub struct r#Neg<'i> {
        content: ::pest::std::Box<super::generics::Negative<super::generics::Sequence2<super::generics::r#EOI, 0u8, super::rules::Pos<'i>, 1u8>>>,
        span: ::pest::Span<'i>,
    }
    impl<'i> ::pest::typed::wrapper::Rule<super::Rule> for r#Neg<'i> {
        type Rule = super::Rule;
        const RULE: super::Rule = super::Rule::r#Neg;
    }
    impl<'i> ::pest::typed::TypedNode<'i, super::Rule> for r#Neg<'i> {
        fn try_parse_with_partial(input: ::pest::Position<'i>, stack: &mut ::pest::Stack<::pest::Span<'i>>, tracker: &mut ::pest::typed::Tracker<'i, super::Rule>) -> ::pest::std::Option<(::pest::Position<'i>, Self)> {
            tracker.record_option_during(input, |tracker| {
                let (pos, content) = super::generics::Negative::<super::generics::Sequence2<super::generics::r#EOI, 0u8, super::rules::Pos<'i>, 1u8>>::try_parse_with_partial(input, stack, tracker)?;
                let content = content.into();
                let span = input.span(&pos);
                ::pest::std::Some((pos, Self { content, span }))
            })
        }
    }
    impl<'i> ::pest::typed::PairContainer<super::Rule> for r#Neg<'i> {
        fn for_each_child_pair(&self, f: &mut impl ::pest::std::FnMut(::pest::token::Pair<super::Rule>)) {
            self.content.for_self_or_for_each_child_pair(f)
        }
        fn for_self_or_for_each_child_pair(&self, f: &mut impl ::pest::std::FnMut(::pest::token::Pair<super::Rule>)) {
            use pest::typed::PairTree;
            f(self.as_pair_tree())
        }
    }
    impl<'i> ::pest::typed::PairTree<super::Rule> for r#Neg<'i> {
        fn get_span(&self) -> (::pest::std::usize, ::pest::std::usize) {
            (self.span.start(), self.span.end())
        }
    }
    #[doc = "Generated for rule `Push`. Grammar: `pest::push((RepLeft* ~ (Neg ~ (ExactString+ ~ (Push ~ (Pop ~ (Push ~ PopAll)))))))`."]
    #[derive(Clone, Debug, Eq, PartialEq)]
    pub struct r#Push<'i> {
        content: ::pest::std::Box<super::generics::r#push<super::generics::Sequence7<super::generics::Rep<super::rules::RepLeft<'i>, 0u8>, 0u8, super::rules::Neg<'i>, 1u8, super::generics::RepOnce<super::rules::ExactString<'i>, 0u8>, 1u8, super::rules::Push<'i>, 1u8, super::rules::Pop<'i>, 1u8, super::rules::Push<'i>, 1u8, super::rules::PopAll<'i>, 1u8>>>,
        span: ::pest::Span<'i>,
    }
    impl<'i> ::pest::typed::wrapper::Rule<super::Rule> for r#Push<'i> {
        type Rule = super::Rule;
        const RULE: super::Rule = super::Rule::r#Push;
    }
    impl<'i> ::pest::typed::TypedNode<'i, super::Rule> for r#Push<'i> {
        fn try_parse_with_partial(input: ::pest::Position<'i>, stack: &mut ::pest::Stack<::pest::Span<'i>>, tracker: &mut ::pest::typed::Tracker<'i, super::Rule>) -> ::pest::std::Option<(::pest::Position<'i>, Self)> {
            tracker.record_option_during(input, |tracker| {
                let (pos, content) = super::generics::r#push::<super::generics::Sequence7<super::generics::Rep<super::rules::RepLeft<'i>, 0u8>, 0u8, super::rules::Neg<'i>, 1u8, super::generics::RepOnce<super::rules::ExactString<'i>, 0u8>, 1u8, super::rules::Push<'i>, 1u8, super::rules::Pop<'i>, 1u8, super::rules::Push<'i>, 1u8, super::rules::PopAll<'i>, 1u8>>::try_parse_with_partial(input, stack, tracker)?;
                let content = content.into();
                let span = input.span(&pos);
                ::pest::std::Some((pos, Self { content, span }))
            })
        }
    }
    impl<'i> ::pest::typed::PairContainer<super::Rule> for r#Push<'i> {
        fn for_each_child_pair(&self, f: &mut impl ::pest::std::FnMut(::pest::token::Pair<super::Rule>)) {
            self.content.for_self_or_for_each_child_pair(f)
        }
        fn for_self_or_for_each_child_pair(&self, f: &mut impl ::pest::std::FnMut(::pest::token::Pair<super::Rule>)) {
            use pest::typed::PairTree;
            f(self.as_pair_tree())
        }
    }
    impl<'i> ::pest::typed::PairTree<super::Rule> for r#Push<'i> {
        fn get_span(&self) -> (::pest::std::usize, ::pest::std::usize) {
            (self.span.start(), self.span.end())
        }
    }
    #[doc = "Generated for rule `Pop`. Grammar: `pest::pop`."]
    #[derive(Clone, Debug, Eq, PartialEq)]
    pub struct r#Pop<'i> {
        content: ::pest::std::Box<super::generics::r#pop<'i>>,
        span: ::pest::Span<'i>,
    }
    impl<'i> ::pest::typed::wrapper::Rule<super::Rule> for r#Pop<'i> {
        type Rule = super::Rule;
        const RULE: super::Rule = super::Rule::r#Pop;
    }
    impl<'i> ::pest::typed::TypedNode<'i, super::Rule> for r#Pop<'i> {
        fn try_parse_with_partial(input: ::pest::Position<'i>, stack: &mut ::pest::Stack<::pest::Span<'i>>, tracker: &mut ::pest::typed::Tracker<'i, super::Rule>) -> ::pest::std::Option<(::pest::Position<'i>, Self)> {
            tracker.record_option_during(input, |tracker| {
                let (pos, content) = super::generics::r#pop::<'i>::try_parse_with_partial(input, stack, tracker)?;
                let content = content.into();
                let span = input.span(&pos);
                ::pest::std::Some((pos, Self { content, span }))
            })
        }
    }
    impl<'i> ::pest::typed::PairContainer<super::Rule> for r#Pop<'i> {
        fn for_each_child_pair(&self, f: &mut impl ::pest::std::FnMut(::pest::token::Pair<super::Rule>)) {
            self.content.for_self_or_for_each_child_pair(f)
        }
        fn for_self_or_for_each_child_pair(&self, f: &mut impl ::pest::std::FnMut(::pest::token::Pair<super::Rule>)) {
            use pest::typed::PairTree;
            f(self.as_pair_tree())
        }
    }
    impl<'i> ::pest::typed::PairTree<super::Rule> for r#Pop<'i> {
        fn get_span(&self) -> (::pest::std::usize, ::pest::std::usize) {
            (self.span.start(), self.span.end())
        }
    }
    #[doc = "Generated for rule `PopAll`. Grammar: `pest::pop_all`."]
    #[derive(Clone, Debug, Eq, PartialEq)]
    pub struct r#PopAll<'i> {
        content: ::pest::std::Box<super::generics::r#pop_all<'i>>,
        span: ::pest::Span<'i>,
    }
    impl<'i> ::pest::typed::wrapper::Rule<super::Rule> for r#PopAll<'i> {
        type Rule = super::Rule;
        const RULE: super::Rule = super::Rule::r#PopAll;
    }
    impl<'i> ::pest::typed::TypedNode<'i, super::Rule> for r#PopAll<'i> {
        fn try_parse_with_partial(input: ::pest::Position<'i>, stack: &mut ::pest::Stack<::pest::Span<'i>>, tracker: &mut ::pest::typed::Tracker<'i, super::Rule>) -> ::pest::std::Option<(::pest::Position<'i>, Self)> {
            tracker.record_option_during(input, |tracker| {
                let (pos, content) = super::generics::r#pop_all::<'i>::try_parse_with_partial(input, stack, tracker)?;
                let content = content.into();
                let span = input.span(&pos);
                ::pest::std::Some((pos, Self { content, span }))
            })
        }
    }
    impl<'i> ::pest::typed::PairContainer<super::Rule> for r#PopAll<'i> {
        fn for_each_child_pair(&self, f: &mut impl ::pest::std::FnMut(::pest::token::Pair<super::Rule>)) {
            self.content.for_self_or_for_each_child_pair(f)
        }
        fn for_self_or_for_each_child_pair(&self, f: &mut impl ::pest::std::FnMut(::pest::token::Pair<super::Rule>)) {
            use pest::typed::PairTree;
            f(self.as_pair_tree())
        }
    }
    impl<'i> ::pest::typed::PairTree<super::Rule> for r#PopAll<'i> {
        fn get_span(&self) -> (::pest::std::usize, ::pest::std::usize) {
            (self.span.start(), self.span.end())
        }
    }
    #[doc = "Generated for rule `Peek`. Grammar: `pest::peek`."]
    #[derive(Clone, Debug, Eq, PartialEq)]
    pub struct r#Peek<'i> {
        content: ::pest::std::Box<super::generics::r#peek<'i>>,
        span: ::pest::Span<'i>,
    }
    impl<'i> ::pest::typed::wrapper::Rule<super::Rule> for r#Peek<'i> {
        type Rule = super::Rule;
        const RULE: super::Rule = super::Rule::r#Peek;
    }
    impl<'i> ::pest::typed::TypedNode<'i, super::Rule> for r#Peek<'i> {
        fn try_parse_with_partial(input: ::pest::Position<'i>, stack: &mut ::pest::Stack<::pest::Span<'i>>, tracker: &mut ::pest::typed::Tracker<'i, super::Rule>) -> ::pest::std::Option<(::pest::Position<'i>, Self)> {
            tracker.record_option_during(input, |tracker| {
                let (pos, content) = super::generics::r#peek::<'i>::try_parse_with_partial(input, stack, tracker)?;
                let content = content.into();
                let span = input.span(&pos);
                ::pest::std::Some((pos, Self { content, span }))
            })
        }
    }
    impl<'i> ::pest::typed::PairContainer<super::Rule> for r#Peek<'i> {
        fn for_each_child_pair(&self, f: &mut impl ::pest::std::FnMut(::pest::token::Pair<super::Rule>)) {
            self.content.for_self_or_for_each_child_pair(f)
        }
        fn for_self_or_for_each_child_pair(&self, f: &mut impl ::pest::std::FnMut(::pest::token::Pair<super::Rule>)) {
            use pest::typed::PairTree;
            f(self.as_pair_tree())
        }
    }
    impl<'i> ::pest::typed::PairTree<super::Rule> for r#Peek<'i> {
        fn get_span(&self) -> (::pest::std::usize, ::pest::std::usize) {
            (self.span.start(), self.span.end())
        }
    }
    #[doc = "Generated for rule `PeekUnlimited`. Grammar: `pest::peek[..]`."]
    #[derive(Clone, Debug, Eq, PartialEq)]
    pub struct r#PeekUnlimited<'i> {
        content: ::pest::std::Box<super::generics::PeekSlice1<0isize>>,
        span: ::pest::Span<'i>,
    }
    impl<'i> ::pest::typed::wrapper::Rule<super::Rule> for r#PeekUnlimited<'i> {
        type Rule = super::Rule;
        const RULE: super::Rule = super::Rule::r#PeekUnlimited;
    }
    impl<'i> ::pest::typed::TypedNode<'i, super::Rule> for r#PeekUnlimited<'i> {
        fn try_parse_with_partial(input: ::pest::Position<'i>, stack: &mut ::pest::Stack<::pest::Span<'i>>, tracker: &mut ::pest::typed::Tracker<'i, super::Rule>) -> ::pest::std::Option<(::pest::Position<'i>, Self)> {
            tracker.record_option_during(input, |tracker| {
                let (pos, content) = super::generics::PeekSlice1::<0isize>::try_parse_with_partial(input, stack, tracker)?;
                let content = content.into();
                let span = input.span(&pos);
                ::pest::std::Some((pos, Self { content, span }))
            })
        }
    }
    impl<'i> ::pest::typed::PairContainer<super::Rule> for r#PeekUnlimited<'i> {
        fn for_each_child_pair(&self, f: &mut impl ::pest::std::FnMut(::pest::token::Pair<super::Rule>)) {
            self.content.for_self_or_for_each_child_pair(f)
        }
        fn for_self_or_for_each_child_pair(&self, f: &mut impl ::pest::std::FnMut(::pest::token::Pair<super::Rule>)) {
            use pest::typed::PairTree;
            f(self.as_pair_tree())
        }
    }
    impl<'i> ::pest::typed::PairTree<super::Rule> for r#PeekUnlimited<'i> {
        fn get_span(&self) -> (::pest::std::usize, ::pest::std::usize) {
            (self.span.start(), self.span.end())
        }
    }
    #[doc = "Generated for rule `PeekLeft`. Grammar: `pest::peek[1..]`."]
    #[derive(Clone, Debug, Eq, PartialEq)]
    pub struct r#PeekLeft<'i> {
        content: ::pest::std::Box<super::generics::PeekSlice1<1isize>>,
        span: ::pest::Span<'i>,
    }
    impl<'i> ::pest::typed::wrapper::Rule<super::Rule> for r#PeekLeft<'i> {
        type Rule = super::Rule;
        const RULE: super::Rule = super::Rule::r#PeekLeft;
    }
    impl<'i> ::pest::typed::TypedNode<'i, super::Rule> for r#PeekLeft<'i> {
        fn try_parse_with_partial(input: ::pest::Position<'i>, stack: &mut ::pest::Stack<::pest::Span<'i>>, tracker: &mut ::pest::typed::Tracker<'i, super::Rule>) -> ::pest::std::Option<(::pest::Position<'i>, Self)> {
            tracker.record_option_during(input, |tracker| {
                let (pos, content) = super::generics::PeekSlice1::<1isize>::try_parse_with_partial(input, stack, tracker)?;
                let content = content.into();
                let span = input.span(&pos);
                ::pest::std::Some((pos, Self { content, span }))
            })
        }
    }
    impl<'i> ::pest::typed::PairContainer<super::Rule> for r#PeekLeft<'i> {
        fn for_each_child_pair(&self, f: &mut impl ::pest::std::FnMut(::pest::token::Pair<super::Rule>)) {
            self.content.for_self_or_for_each_child_pair(f)
        }
        fn for_self_or_for_each_child_pair(&self, f: &mut impl ::pest::std::FnMut(::pest::token::Pair<super::Rule>)) {
            use pest::typed::PairTree;
            f(self.as_pair_tree())
        }
    }
    impl<'i> ::pest::typed::PairTree<super::Rule> for r#PeekLeft<'i> {
        fn get_span(&self) -> (::pest::std::usize, ::pest::std::usize) {
            (self.span.start(), self.span.end())
        }
    }
    #[doc = "Generated for rule `PeekRight`. Grammar: `pest::peek[..]`."]
    #[derive(Clone, Debug, Eq, PartialEq)]
    pub struct r#PeekRight<'i> {
        content: ::pest::std::Box<super::generics::PeekSlice1<0isize>>,
        span: ::pest::Span<'i>,
    }
    impl<'i> ::pest::typed::wrapper::Rule<super::Rule> for r#PeekRight<'i> {
        type Rule = super::Rule;
        const RULE: super::Rule = super::Rule::r#PeekRight;
    }
    impl<'i> ::pest::typed::TypedNode<'i, super::Rule> for r#PeekRight<'i> {
        fn try_parse_with_partial(input: ::pest::Position<'i>, stack: &mut ::pest::Stack<::pest::Span<'i>>, tracker: &mut ::pest::typed::Tracker<'i, super::Rule>) -> ::pest::std::Option<(::pest::Position<'i>, Self)> {
            tracker.record_option_during(input, |tracker| {
                let (pos, content) = super::generics::PeekSlice1::<0isize>::try_parse_with_partial(input, stack, tracker)?;
                let content = content.into();
                let span = input.span(&pos);
                ::pest::std::Some((pos, Self { content, span }))
            })
        }
    }
    impl<'i> ::pest::typed::PairContainer<super::Rule> for r#PeekRight<'i> {
        fn for_each_child_pair(&self, f: &mut impl ::pest::std::FnMut(::pest::token::Pair<super::Rule>)) {
            self.content.for_self_or_for_each_child_pair(f)
        }
        fn for_self_or_for_each_child_pair(&self, f: &mut impl ::pest::std::FnMut(::pest::token::Pair<super::Rule>)) {
            use pest::typed::PairTree;
            f(self.as_pair_tree())
        }
    }
    impl<'i> ::pest::typed::PairTree<super::Rule> for r#PeekRight<'i> {
        fn get_span(&self) -> (::pest::std::usize, ::pest::std::usize) {
            (self.span.start(), self.span.end())
        }
    }
    #[doc = "Generated for rule `PeekLeftRight`. Grammar: `pest::peek[1..2]`."]
    #[derive(Clone, Debug, Eq, PartialEq)]
    pub struct r#PeekLeftRight<'i> {
        content: ::pest::std::Box<super::generics::PeekSlice2<1isize, 2isize>>,
        span: ::pest::Span<'i>,
    }
    impl<'i> ::pest::typed::wrapper::Rule<super::Rule> for r#PeekLeftRight<'i> {
        type Rule = super::Rule;
        const RULE: super::Rule = super::Rule::r#PeekLeftRight;
    }
    impl<'i> ::pest::typed::TypedNode<'i, super::Rule> for r#PeekLeftRight<'i> {
        fn try_parse_with_partial(input: ::pest::Position<'i>, stack: &mut ::pest::Stack<::pest::Span<'i>>, tracker: &mut ::pest::typed::Tracker<'i, super::Rule>) -> ::pest::std::Option<(::pest::Position<'i>, Self)> {
            tracker.record_option_during(input, |tracker| {
                let (pos, content) = super::generics::PeekSlice2::<1isize, 2isize>::try_parse_with_partial(input, stack, tracker)?;
                let content = content.into();
                let span = input.span(&pos);
                ::pest::std::Some((pos, Self { content, span }))
            })
        }
    }
    impl<'i> ::pest::typed::PairContainer<super::Rule> for r#PeekLeftRight<'i> {
        fn for_each_child_pair(&self, f: &mut impl ::pest::std::FnMut(::pest::token::Pair<super::Rule>)) {
            self.content.for_self_or_for_each_child_pair(f)
        }
        fn for_self_or_for_each_child_pair(&self, f: &mut impl ::pest::std::FnMut(::pest::token::Pair<super::Rule>)) {
            use pest::typed::PairTree;
            f(self.as_pair_tree())
        }
    }
    impl<'i> ::pest::typed::PairTree<super::Rule> for r#PeekLeftRight<'i> {
        fn get_span(&self) -> (::pest::std::usize, ::pest::std::usize) {
            (self.span.start(), self.span.end())
        }
    }
    #[doc = "Generated for rule `Drop`. Grammar: `pest::drop`."]
    #[derive(Clone, Debug, Eq, PartialEq)]
    pub struct r#Drop<'i> {
        content: ::pest::std::Box<super::generics::r#drop>,
        span: ::pest::Span<'i>,
    }
    impl<'i> ::pest::typed::wrapper::Rule<super::Rule> for r#Drop<'i> {
        type Rule = super::Rule;
        const RULE: super::Rule = super::Rule::r#Drop;
    }
    impl<'i> ::pest::typed::TypedNode<'i, super::Rule> for r#Drop<'i> {
        fn try_parse_with_partial(input: ::pest::Position<'i>, stack: &mut ::pest::Stack<::pest::Span<'i>>, tracker: &mut ::pest::typed::Tracker<'i, super::Rule>) -> ::pest::std::Option<(::pest::Position<'i>, Self)> {
            tracker.record_option_during(input, |tracker| {
                let (pos, content) = super::generics::r#drop::try_parse_with_partial(input, stack, tracker)?;
                let content = content.into();
                let span = input.span(&pos);
                ::pest::std::Some((pos, Self { content, span }))
            })
        }
    }
    impl<'i> ::pest::typed::PairContainer<super::Rule> for r#Drop<'i> {
        fn for_each_child_pair(&self, f: &mut impl ::pest::std::FnMut(::pest::token::Pair<super::Rule>)) {
            self.content.for_self_or_for_each_child_pair(f)
        }
        fn for_self_or_for_each_child_pair(&self, f: &mut impl ::pest::std::FnMut(::pest::token::Pair<super::Rule>)) {
            use pest::typed::PairTree;
            f(self.as_pair_tree())
        }
    }
    impl<'i> ::pest::typed::PairTree<super::Rule> for r#Drop<'i> {
        fn get_span(&self) -> (::pest::std::usize, ::pest::std::usize) {
            (self.span.start(), self.span.end())
        }
    }
    #[doc = "Generated for rule `PeekAll`. Grammar: `pest::peek_all`."]
    #[derive(Clone, Debug, Eq, PartialEq)]
    pub struct r#PeekAll<'i> {
        content: ::pest::std::Box<super::generics::r#peek_all<'i>>,
        span: ::pest::Span<'i>,
    }
    impl<'i> ::pest::typed::wrapper::Rule<super::Rule> for r#PeekAll<'i> {
        type Rule = super::Rule;
        const RULE: super::Rule = super::Rule::r#PeekAll;
    }
    impl<'i> ::pest::typed::TypedNode<'i, super::Rule> for r#PeekAll<'i> {
        fn try_parse_with_partial(input: ::pest::Position<'i>, stack: &mut ::pest::Stack<::pest::Span<'i>>, tracker: &mut ::pest::typed::Tracker<'i, super::Rule>) -> ::pest::std::Option<(::pest::Position<'i>, Self)> {
            tracker.record_option_during(input, |tracker| {
                let (pos, content) = super::generics::r#peek_all::<'i>::try_parse_with_partial(input, stack, tracker)?;
                let content = content.into();
                let span = input.span(&pos);
                ::pest::std::Some((pos, Self { content, span }))
            })
        }
    }
    impl<'i> ::pest::typed::PairContainer<super::Rule> for r#PeekAll<'i> {
        fn for_each_child_pair(&self, f: &mut impl ::pest::std::FnMut(::pest::token::Pair<super::Rule>)) {
            self.content.for_self_or_for_each_child_pair(f)
        }
        fn for_self_or_for_each_child_pair(&self, f: &mut impl ::pest::std::FnMut(::pest::token::Pair<super::Rule>)) {
            use pest::typed::PairTree;
            f(self.as_pair_tree())
        }
    }
    impl<'i> ::pest::typed::PairTree<super::Rule> for r#PeekAll<'i> {
        fn get_span(&self) -> (::pest::std::usize, ::pest::std::usize) {
            (self.span.start(), self.span.end())
        }
    }
}
#[doc = "Used generics."]
pub mod generics {
    pub use pest::choice::Choice9;
    pub use pest::sequence::Sequence2;
    pub use pest::sequence::Sequence3;
    pub use pest::sequence::Sequence4;
    pub use pest::sequence::Sequence7;
    pub use pest::typed::template::{CharRange, Insens, Negative, PeekSlice1, PeekSlice2, Positive, Rep, RepMax, RepMin, RepMinMax, RepOnce, Str, ANY as any, DROP as drop, EOI, PEEK as peek, PEEK_ALL as peek_all, POP as pop, POP_ALL as pop_all, PUSH as push, SOI};
}
