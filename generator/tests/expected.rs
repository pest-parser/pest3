#[doc = "For compatibility."]
#[allow(
    dead_code,
    missing_docs,
    non_camel_case_types,
    clippy::upper_case_acronyms
)]
#[derive(Clone, Copy, Debug, Eq, Hash, Ord, PartialEq, PartialOrd)]
pub enum Rule {
    EOI,
    #[doc = "Regular rule."]
    r#Regular,
    #[doc = "Atomic rule."]
    r#Atomic,
    #[doc = "Silent rule."]
    r#NonAtomic,
    r#ExactString,
    r#CharRange,
    r#Any,
    r#Seq,
    r#Choice,
    r#Rep,
    r#RepAtLeastOnce,
    r#Opt,
    r#RepExact,
    r#RepLeft,
    r#RepRight,
    r#RepLeftRight,
    r#Pos,
    r#Neg,
    r#Push,
    r#Pop,
    r#PopAll,
    r#Peek,
    r#PeekUnlimited,
    r#PeekLeft,
    r#PeekRight,
    r#PeekLeftRight,
    r#Drop,
    r#PeekAll,
}
impl ::pest3_core::typed::RuleType for Rule {
    const EOI: Self = Rule::EOI;
}
#[doc = "Definitions of statically typed nodes generated by pest-generator."]
pub mod rules {
    pub type __OptionalTrivia<'i> = super::generics::Rep<
        super::generics::Str<super::wrapper::W0>,
        ::pest3_core::typed::template::Empty,
    >;
    pub type __MandatoryTrivia<'i> = super::generics::RepOnce<
        super::generics::Str<super::wrapper::W0>,
        ::pest3_core::typed::template::Empty,
    >;
    #[doc = "Generated for rule `Regular`. Grammar: `'0'..'9'+`."]
    #[derive(Clone, Debug, Eq, PartialEq)]
    #[allow(non_camel_case_types)]
    pub struct r#Regular<'i> {
        #[doc = r" Matched structure."]
        pub content: ::pest3_core::std::Box<
            super::generics::RepOnce<
                super::generics::CharRange<'0', '9'>,
                ::pest3_core::typed::template::Empty,
            >,
        >,
        #[doc = r" Matched span."]
        pub span: ::pest3_core::Span<'i>,
    }
    #[allow(non_camel_case_types)]
    impl<'i> ::pest3_core::typed::wrapper::Rule for r#Regular<'i> {
        type Rule = super::Rule;
        const RULE: super::Rule = super::Rule::r#Regular;
    }
    #[allow(non_camel_case_types)]
    impl<'i> r#Regular<'i> {}
    #[allow(unused_imports)]
    use pest3_core::typed::SubRule as _;
    ::pest3_core::typed::full_rule_struct!(
        r#Regular,
        (),
        super::Rule,
        super::Rule::r#Regular,
        super::generics::RepOnce::<
            super::generics::CharRange::<'0', '9'>,
            ::pest3_core::typed::template::Empty,
        >,
        ::pest3_core::std::Box<
            super::generics::RepOnce::<
                super::generics::CharRange::<'0', '9'>,
                ::pest3_core::typed::template::Empty,
            >,
        >,
    );
    #[allow(non_camel_case_types)]
    impl<'i> ::pest3_core::typed::PairContainer<super::Rule> for r#Regular<'i> {
        fn for_each_child_pair(
            &self,
            f: &mut impl ::pest3_core::std::FnMut(::pest3_core::token::Pair<super::Rule>),
        ) {
            self.content.for_self_or_for_each_child_pair(f)
        }
        fn for_self_or_for_each_child_pair(
            &self,
            f: &mut impl ::pest3_core::std::FnMut(::pest3_core::token::Pair<super::Rule>),
        ) {
            use pest3_core::typed::PairTree;
            f(self.as_pair_tree())
        }
    }
    #[allow(non_camel_case_types)]
    impl<'i> ::pest3_core::typed::PairTree<super::Rule> for r#Regular<'i> {
        fn get_rule() -> super::Rule {
            #[allow(unused_imports)]
            use pest3_core::typed::SubRule as _;
            super::Rule::r#Regular
        }
        fn get_span(&self) -> (::pest3_core::std::usize, ::pest3_core::std::usize) {
            (self.span.start(), self.span.end())
        }
    }
    #[doc = "Generated for rule `Atomic`. Grammar: `(CharRange+ ~ (\"+\" ~ CharRange+))`."]
    #[derive(Clone, Debug, Eq, PartialEq)]
    #[allow(non_camel_case_types)]
    pub struct r#Atomic<'i> {
        #[doc = r" Matched structure."]
        pub content: ::pest3_core::std::Box<
            super::generics::Sequence3<
                super::generics::RepOnce<r#CharRange<'i>, ::pest3_core::typed::template::Empty>,
                ::pest3_core::typed::template::Empty,
                super::generics::Str<super::wrapper::W1>,
                __OptionalTrivia<'i>,
                super::generics::RepOnce<r#CharRange<'i>, ::pest3_core::typed::template::Empty>,
                __OptionalTrivia<'i>,
            >,
        >,
        #[doc = r" Matched span."]
        pub span: ::pest3_core::Span<'i>,
    }
    #[allow(non_camel_case_types)]
    impl<'i> ::pest3_core::typed::wrapper::Rule for r#Atomic<'i> {
        type Rule = super::Rule;
        const RULE: super::Rule = super::Rule::r#Atomic;
    }
    #[allow(non_camel_case_types)]
    impl<'i> r#Atomic<'i> {
        #[doc = "A helper function to access [`CharRange`]."]
        #[allow(non_snake_case)]
        pub fn r#CharRange<'s>(
            &'s self,
        ) -> (
            ::pest3_core::std::Vec<&'s r#CharRange<'i>>,
            ::pest3_core::std::Vec<&'s r#CharRange<'i>>,
        ) {
            let res = &*self.content;
            {
                let res = (
                    {
                        let res = &res.field_0;
                        {
                            let res = res
                                .content
                                .iter()
                                .map(|res| res)
                                .collect::<::pest3_core::std::Vec<_>>();
                            res
                        }
                    },
                    {
                        let res = &res.field_2;
                        {
                            let res = res
                                .content
                                .iter()
                                .map(|res| res)
                                .collect::<::pest3_core::std::Vec<_>>();
                            res
                        }
                    },
                );
                res
            }
        }
    }
    #[allow(unused_imports)]
    use pest3_core::typed::SubRule as _;
    ::pest3_core::typed::full_rule_struct!(
        r#Atomic,
        (),
        super::Rule,
        super::Rule::r#Atomic,
        super::generics::Sequence3::<
            super::generics::RepOnce::<r#CharRange::<'i>, ::pest3_core::typed::template::Empty>,
            ::pest3_core::typed::template::Empty,
            super::generics::Str::<super::wrapper::W1>,
            __OptionalTrivia::<'i>,
            super::generics::RepOnce::<r#CharRange::<'i>, ::pest3_core::typed::template::Empty>,
            __OptionalTrivia::<'i>,
        >,
        ::pest3_core::std::Box<
            super::generics::Sequence3::<
                super::generics::RepOnce::<r#CharRange::<'i>, ::pest3_core::typed::template::Empty>,
                ::pest3_core::typed::template::Empty,
                super::generics::Str::<super::wrapper::W1>,
                __OptionalTrivia::<'i>,
                super::generics::RepOnce::<r#CharRange::<'i>, ::pest3_core::typed::template::Empty>,
                __OptionalTrivia::<'i>,
            >,
        >,
    );
    #[allow(non_camel_case_types)]
    impl<'i> ::pest3_core::typed::PairContainer<super::Rule> for r#Atomic<'i> {
        fn for_each_child_pair(
            &self,
            f: &mut impl ::pest3_core::std::FnMut(::pest3_core::token::Pair<super::Rule>),
        ) {
            self.content.for_self_or_for_each_child_pair(f)
        }
        fn for_self_or_for_each_child_pair(
            &self,
            f: &mut impl ::pest3_core::std::FnMut(::pest3_core::token::Pair<super::Rule>),
        ) {
            use pest3_core::typed::PairTree;
            f(self.as_pair_tree())
        }
    }
    #[allow(non_camel_case_types)]
    impl<'i> ::pest3_core::typed::PairTree<super::Rule> for r#Atomic<'i> {
        fn get_rule() -> super::Rule {
            #[allow(unused_imports)]
            use pest3_core::typed::SubRule as _;
            super::Rule::r#Atomic
        }
        fn get_span(&self) -> (::pest3_core::std::usize, ::pest3_core::std::usize) {
            (self.span.start(), self.span.end())
        }
    }
    #[doc = "Generated for rule `NonAtomic`. Grammar: `(\"(\" ^ \")\")`."]
    #[derive(Clone, Debug, Eq, PartialEq)]
    #[allow(non_camel_case_types)]
    pub struct r#NonAtomic<'i> {
        #[doc = r" Matched structure."]
        pub content: ::pest3_core::std::Box<
            super::generics::Sequence2<
                super::generics::Str<super::wrapper::W2>,
                ::pest3_core::typed::template::Empty,
                super::generics::Str<super::wrapper::W3>,
                __MandatoryTrivia<'i>,
            >,
        >,
        #[doc = r" Matched span."]
        pub span: ::pest3_core::Span<'i>,
    }
    #[allow(non_camel_case_types)]
    impl<'i> ::pest3_core::typed::wrapper::Rule for r#NonAtomic<'i> {
        type Rule = super::Rule;
        const RULE: super::Rule = super::Rule::r#NonAtomic;
    }
    #[allow(non_camel_case_types)]
    impl<'i> r#NonAtomic<'i> {}
    #[allow(unused_imports)]
    use pest3_core::typed::SubRule as _;
    ::pest3_core::typed::full_rule_struct!(
        r#NonAtomic,
        (),
        super::Rule,
        super::Rule::r#NonAtomic,
        super::generics::Sequence2::<
            super::generics::Str::<super::wrapper::W2>,
            ::pest3_core::typed::template::Empty,
            super::generics::Str::<super::wrapper::W3>,
            __MandatoryTrivia::<'i>,
        >,
        ::pest3_core::std::Box<
            super::generics::Sequence2::<
                super::generics::Str::<super::wrapper::W2>,
                ::pest3_core::typed::template::Empty,
                super::generics::Str::<super::wrapper::W3>,
                __MandatoryTrivia::<'i>,
            >,
        >,
    );
    #[allow(non_camel_case_types)]
    impl<'i> ::pest3_core::typed::PairContainer<super::Rule> for r#NonAtomic<'i> {
        fn for_each_child_pair(
            &self,
            f: &mut impl ::pest3_core::std::FnMut(::pest3_core::token::Pair<super::Rule>),
        ) {
            self.content.for_self_or_for_each_child_pair(f)
        }
        fn for_self_or_for_each_child_pair(
            &self,
            f: &mut impl ::pest3_core::std::FnMut(::pest3_core::token::Pair<super::Rule>),
        ) {
            use pest3_core::typed::PairTree;
            f(self.as_pair_tree())
        }
    }
    #[allow(non_camel_case_types)]
    impl<'i> ::pest3_core::typed::PairTree<super::Rule> for r#NonAtomic<'i> {
        fn get_rule() -> super::Rule {
            #[allow(unused_imports)]
            use pest3_core::typed::SubRule as _;
            super::Rule::r#NonAtomic
        }
        fn get_span(&self) -> (::pest3_core::std::usize, ::pest3_core::std::usize) {
            (self.span.start(), self.span.end())
        }
    }
    #[doc = "Generated for rule `ExactString`. Grammar: `\"r#\"`."]
    #[derive(Clone, Debug, Eq, PartialEq)]
    #[allow(non_camel_case_types)]
    pub struct r#ExactString<'i> {
        #[doc = r" Matched structure."]
        pub content: ::pest3_core::std::Box<super::generics::Str<super::wrapper::W4>>,
        #[doc = r" Matched span."]
        pub span: ::pest3_core::Span<'i>,
    }
    #[allow(non_camel_case_types)]
    impl<'i> ::pest3_core::typed::wrapper::Rule for r#ExactString<'i> {
        type Rule = super::Rule;
        const RULE: super::Rule = super::Rule::r#ExactString;
    }
    #[allow(non_camel_case_types)]
    impl<'i> r#ExactString<'i> {}
    #[allow(unused_imports)]
    use pest3_core::typed::SubRule as _;
    ::pest3_core::typed::full_rule_struct!(
        r#ExactString,
        (),
        super::Rule,
        super::Rule::r#ExactString,
        super::generics::Str::<super::wrapper::W4>,
        ::pest3_core::std::Box<super::generics::Str::<super::wrapper::W4>>,
    );
    #[allow(non_camel_case_types)]
    impl<'i> ::pest3_core::typed::PairContainer<super::Rule> for r#ExactString<'i> {
        fn for_each_child_pair(
            &self,
            f: &mut impl ::pest3_core::std::FnMut(::pest3_core::token::Pair<super::Rule>),
        ) {
            self.content.for_self_or_for_each_child_pair(f)
        }
        fn for_self_or_for_each_child_pair(
            &self,
            f: &mut impl ::pest3_core::std::FnMut(::pest3_core::token::Pair<super::Rule>),
        ) {
            use pest3_core::typed::PairTree;
            f(self.as_pair_tree())
        }
    }
    #[allow(non_camel_case_types)]
    impl<'i> ::pest3_core::typed::PairTree<super::Rule> for r#ExactString<'i> {
        fn get_rule() -> super::Rule {
            #[allow(unused_imports)]
            use pest3_core::typed::SubRule as _;
            super::Rule::r#ExactString
        }
        fn get_span(&self) -> (::pest3_core::std::usize, ::pest3_core::std::usize) {
            (self.span.start(), self.span.end())
        }
    }
    #[doc = "Generated for rule `CharRange`. Grammar: `'0'..'9'`."]
    #[derive(Clone, Debug, Eq, PartialEq)]
    #[allow(non_camel_case_types)]
    pub struct r#CharRange<'i> {
        #[doc = r" Matched structure."]
        pub content: ::pest3_core::std::Box<super::generics::CharRange<'0', '9'>>,
        #[doc = r" Matched span."]
        pub span: ::pest3_core::Span<'i>,
    }
    #[allow(non_camel_case_types)]
    impl<'i> ::pest3_core::typed::wrapper::Rule for r#CharRange<'i> {
        type Rule = super::Rule;
        const RULE: super::Rule = super::Rule::r#CharRange;
    }
    #[allow(non_camel_case_types)]
    impl<'i> r#CharRange<'i> {}
    #[allow(unused_imports)]
    use pest3_core::typed::SubRule as _;
    ::pest3_core::typed::full_rule_struct!(
        r#CharRange,
        (),
        super::Rule,
        super::Rule::r#CharRange,
        super::generics::CharRange::<'0', '9'>,
        ::pest3_core::std::Box<super::generics::CharRange::<'0', '9'>>,
    );
    #[allow(non_camel_case_types)]
    impl<'i> ::pest3_core::typed::PairContainer<super::Rule> for r#CharRange<'i> {
        fn for_each_child_pair(
            &self,
            f: &mut impl ::pest3_core::std::FnMut(::pest3_core::token::Pair<super::Rule>),
        ) {
            self.content.for_self_or_for_each_child_pair(f)
        }
        fn for_self_or_for_each_child_pair(
            &self,
            f: &mut impl ::pest3_core::std::FnMut(::pest3_core::token::Pair<super::Rule>),
        ) {
            use pest3_core::typed::PairTree;
            f(self.as_pair_tree())
        }
    }
    #[allow(non_camel_case_types)]
    impl<'i> ::pest3_core::typed::PairTree<super::Rule> for r#CharRange<'i> {
        fn get_rule() -> super::Rule {
            #[allow(unused_imports)]
            use pest3_core::typed::SubRule as _;
            super::Rule::r#CharRange
        }
        fn get_span(&self) -> (::pest3_core::std::usize, ::pest3_core::std::usize) {
            (self.span.start(), self.span.end())
        }
    }
    #[doc = "Generated for rule `Any`. Grammar: `pest::any`."]
    #[derive(Clone, Debug, Eq, PartialEq)]
    #[allow(non_camel_case_types)]
    pub struct r#Any<'i> {
        #[doc = r" Matched structure."]
        pub content: ::pest3_core::std::Box<super::generics::r#any>,
        #[doc = r" Matched span."]
        pub span: ::pest3_core::Span<'i>,
    }
    #[allow(non_camel_case_types)]
    impl<'i> ::pest3_core::typed::wrapper::Rule for r#Any<'i> {
        type Rule = super::Rule;
        const RULE: super::Rule = super::Rule::r#Any;
    }
    #[allow(non_camel_case_types)]
    impl<'i> r#Any<'i> {
        #[doc = "A helper function to access [`any`]."]
        #[allow(non_snake_case)]
        pub fn r#any<'s>(&'s self) -> &'s super::generics::r#any {
            let res = &*self.content;
            res
        }
    }
    #[allow(unused_imports)]
    use pest3_core::typed::SubRule as _;
    ::pest3_core::typed::full_rule_struct!(
        r#Any,
        (),
        super::Rule,
        super::Rule::r#Any,
        super::generics::r#any,
        ::pest3_core::std::Box<super::generics::r#any>,
    );
    #[allow(non_camel_case_types)]
    impl<'i> ::pest3_core::typed::PairContainer<super::Rule> for r#Any<'i> {
        fn for_each_child_pair(
            &self,
            f: &mut impl ::pest3_core::std::FnMut(::pest3_core::token::Pair<super::Rule>),
        ) {
            self.content.for_self_or_for_each_child_pair(f)
        }
        fn for_self_or_for_each_child_pair(
            &self,
            f: &mut impl ::pest3_core::std::FnMut(::pest3_core::token::Pair<super::Rule>),
        ) {
            use pest3_core::typed::PairTree;
            f(self.as_pair_tree())
        }
    }
    #[allow(non_camel_case_types)]
    impl<'i> ::pest3_core::typed::PairTree<super::Rule> for r#Any<'i> {
        fn get_rule() -> super::Rule {
            #[allow(unused_imports)]
            use pest3_core::typed::SubRule as _;
            super::Rule::r#Any
        }
        fn get_span(&self) -> (::pest3_core::std::usize, ::pest3_core::std::usize) {
            (self.span.start(), self.span.end())
        }
    }
    #[doc = "Generated for rule `Seq`. Grammar: `(\"1\" ~ ('2'..'9' ~ \".\"))`."]
    #[derive(Clone, Debug, Eq, PartialEq)]
    #[allow(non_camel_case_types)]
    pub struct r#Seq<'i> {
        #[doc = r" Matched structure."]
        pub content: ::pest3_core::std::Box<
            super::generics::Sequence3<
                super::generics::Str<super::wrapper::W5>,
                ::pest3_core::typed::template::Empty,
                super::generics::CharRange<'2', '9'>,
                __OptionalTrivia<'i>,
                super::generics::Str<super::wrapper::W6>,
                __OptionalTrivia<'i>,
            >,
        >,
        #[doc = r" Matched span."]
        pub span: ::pest3_core::Span<'i>,
    }
    #[allow(non_camel_case_types)]
    impl<'i> ::pest3_core::typed::wrapper::Rule for r#Seq<'i> {
        type Rule = super::Rule;
        const RULE: super::Rule = super::Rule::r#Seq;
    }
    #[allow(non_camel_case_types)]
    impl<'i> r#Seq<'i> {}
    #[allow(unused_imports)]
    use pest3_core::typed::SubRule as _;
    ::pest3_core::typed::full_rule_struct!(
        r#Seq,
        (),
        super::Rule,
        super::Rule::r#Seq,
        super::generics::Sequence3::<
            super::generics::Str::<super::wrapper::W5>,
            ::pest3_core::typed::template::Empty,
            super::generics::CharRange::<'2', '9'>,
            __OptionalTrivia::<'i>,
            super::generics::Str::<super::wrapper::W6>,
            __OptionalTrivia::<'i>,
        >,
        ::pest3_core::std::Box<
            super::generics::Sequence3::<
                super::generics::Str::<super::wrapper::W5>,
                ::pest3_core::typed::template::Empty,
                super::generics::CharRange::<'2', '9'>,
                __OptionalTrivia::<'i>,
                super::generics::Str::<super::wrapper::W6>,
                __OptionalTrivia::<'i>,
            >,
        >,
    );
    #[allow(non_camel_case_types)]
    impl<'i> ::pest3_core::typed::PairContainer<super::Rule> for r#Seq<'i> {
        fn for_each_child_pair(
            &self,
            f: &mut impl ::pest3_core::std::FnMut(::pest3_core::token::Pair<super::Rule>),
        ) {
            self.content.for_self_or_for_each_child_pair(f)
        }
        fn for_self_or_for_each_child_pair(
            &self,
            f: &mut impl ::pest3_core::std::FnMut(::pest3_core::token::Pair<super::Rule>),
        ) {
            use pest3_core::typed::PairTree;
            f(self.as_pair_tree())
        }
    }
    #[allow(non_camel_case_types)]
    impl<'i> ::pest3_core::typed::PairTree<super::Rule> for r#Seq<'i> {
        fn get_rule() -> super::Rule {
            #[allow(unused_imports)]
            use pest3_core::typed::SubRule as _;
            super::Rule::r#Seq
        }
        fn get_span(&self) -> (::pest3_core::std::usize, ::pest3_core::std::usize) {
            (self.span.start(), self.span.end())
        }
    }
    #[doc = "Generated for rule `Choice`. Grammar: `(\"a\" | ((\"b\"+ ~ RepAtLeastOnce) | ((&\"c\" ~ (Choice ~ (Rep ~ Opt))) | (Peek | (PeekLeft | (PeekRight | (PeekLeftRight | (Drop | PeekAll))))))))`."]
    #[derive(Clone, Debug, Eq, PartialEq)]
    #[allow(non_camel_case_types)]
    pub struct r#Choice<'i> {
        #[doc = r" Matched structure."]
        pub content: ::pest3_core::std::Box<
            super::generics::Choice9<
                super::generics::Str<super::wrapper::W7>,
                super::generics::Sequence2<
                    super::generics::RepOnce<
                        super::generics::Str<super::wrapper::W8>,
                        ::pest3_core::typed::template::Empty,
                    >,
                    ::pest3_core::typed::template::Empty,
                    r#RepAtLeastOnce<'i>,
                    __OptionalTrivia<'i>,
                >,
                super::generics::Sequence4<
                    super::generics::Positive<super::generics::Str<super::wrapper::W9>>,
                    ::pest3_core::typed::template::Empty,
                    r#Choice<'i>,
                    __OptionalTrivia<'i>,
                    r#Rep<'i>,
                    __OptionalTrivia<'i>,
                    r#Opt<'i>,
                    __OptionalTrivia<'i>,
                >,
                r#Peek<'i>,
                r#PeekLeft<'i>,
                r#PeekRight<'i>,
                r#PeekLeftRight<'i>,
                r#Drop<'i>,
                r#PeekAll<'i>,
            >,
        >,
        #[doc = r" Matched span."]
        pub span: ::pest3_core::Span<'i>,
    }
    #[allow(non_camel_case_types)]
    impl<'i> ::pest3_core::typed::wrapper::Rule for r#Choice<'i> {
        type Rule = super::Rule;
        const RULE: super::Rule = super::Rule::r#Choice;
    }
    #[allow(non_camel_case_types)]
    impl<'i> r#Choice<'i> {
        #[doc = "A helper function to access [`Choice`]."]
        #[allow(non_snake_case)]
        pub fn r#Choice<'s>(&'s self) -> ::pest3_core::std::Option<&'s r#Choice<'i>> {
            let res = &*self.content;
            {
                let res = res.choice_2().map(|res| {
                    let res = &res.field_1;
                    res
                });
                res
            }
        }
        #[doc = "A helper function to access [`Drop`]."]
        #[allow(non_snake_case)]
        pub fn r#Drop<'s>(&'s self) -> ::pest3_core::std::Option<&'s r#Drop<'i>> {
            let res = &*self.content;
            {
                let res = res.choice_7().map(|res| res);
                res
            }
        }
        #[doc = "A helper function to access [`Opt`]."]
        #[allow(non_snake_case)]
        pub fn r#Opt<'s>(&'s self) -> ::pest3_core::std::Option<&'s r#Opt<'i>> {
            let res = &*self.content;
            {
                let res = res.choice_2().map(|res| {
                    let res = &res.field_3;
                    res
                });
                res
            }
        }
        #[doc = "A helper function to access [`Peek`]."]
        #[allow(non_snake_case)]
        pub fn r#Peek<'s>(&'s self) -> ::pest3_core::std::Option<&'s r#Peek<'i>> {
            let res = &*self.content;
            {
                let res = res.choice_3().map(|res| res);
                res
            }
        }
        #[doc = "A helper function to access [`PeekAll`]."]
        #[allow(non_snake_case)]
        pub fn r#PeekAll<'s>(&'s self) -> ::pest3_core::std::Option<&'s r#PeekAll<'i>> {
            let res = &*self.content;
            {
                let res = res.choice_8().map(|res| res);
                res
            }
        }
        #[doc = "A helper function to access [`PeekLeft`]."]
        #[allow(non_snake_case)]
        pub fn r#PeekLeft<'s>(&'s self) -> ::pest3_core::std::Option<&'s r#PeekLeft<'i>> {
            let res = &*self.content;
            {
                let res = res.choice_4().map(|res| res);
                res
            }
        }
        #[doc = "A helper function to access [`PeekLeftRight`]."]
        #[allow(non_snake_case)]
        pub fn r#PeekLeftRight<'s>(&'s self) -> ::pest3_core::std::Option<&'s r#PeekLeftRight<'i>> {
            let res = &*self.content;
            {
                let res = res.choice_6().map(|res| res);
                res
            }
        }
        #[doc = "A helper function to access [`PeekRight`]."]
        #[allow(non_snake_case)]
        pub fn r#PeekRight<'s>(&'s self) -> ::pest3_core::std::Option<&'s r#PeekRight<'i>> {
            let res = &*self.content;
            {
                let res = res.choice_5().map(|res| res);
                res
            }
        }
        #[doc = "A helper function to access [`Rep`]."]
        #[allow(non_snake_case)]
        pub fn r#Rep<'s>(&'s self) -> ::pest3_core::std::Option<&'s r#Rep<'i>> {
            let res = &*self.content;
            {
                let res = res.choice_2().map(|res| {
                    let res = &res.field_2;
                    res
                });
                res
            }
        }
        #[doc = "A helper function to access [`RepAtLeastOnce`]."]
        #[allow(non_snake_case)]
        pub fn r#RepAtLeastOnce<'s>(
            &'s self,
        ) -> ::pest3_core::std::Option<&'s r#RepAtLeastOnce<'i>> {
            let res = &*self.content;
            {
                let res = res.choice_1().map(|res| {
                    let res = &res.field_1;
                    res
                });
                res
            }
        }
    }
    #[allow(unused_imports)]
    use pest3_core::typed::SubRule as _;
    ::pest3_core::typed::full_rule_struct!(
        r#Choice,
        (),
        super::Rule,
        super::Rule::r#Choice,
        super::generics::Choice9::<
            super::generics::Str::<super::wrapper::W7>,
            super::generics::Sequence2::<
                super::generics::RepOnce::<
                    super::generics::Str::<super::wrapper::W8>,
                    ::pest3_core::typed::template::Empty,
                >,
                ::pest3_core::typed::template::Empty,
                r#RepAtLeastOnce::<'i>,
                __OptionalTrivia::<'i>,
            >,
            super::generics::Sequence4::<
                super::generics::Positive::<super::generics::Str::<super::wrapper::W9>>,
                ::pest3_core::typed::template::Empty,
                r#Choice::<'i>,
                __OptionalTrivia::<'i>,
                r#Rep::<'i>,
                __OptionalTrivia::<'i>,
                r#Opt::<'i>,
                __OptionalTrivia::<'i>,
            >,
            r#Peek::<'i>,
            r#PeekLeft::<'i>,
            r#PeekRight::<'i>,
            r#PeekLeftRight::<'i>,
            r#Drop::<'i>,
            r#PeekAll::<'i>,
        >,
        ::pest3_core::std::Box<
            super::generics::Choice9::<
                super::generics::Str::<super::wrapper::W7>,
                super::generics::Sequence2::<
                    super::generics::RepOnce::<
                        super::generics::Str::<super::wrapper::W8>,
                        ::pest3_core::typed::template::Empty,
                    >,
                    ::pest3_core::typed::template::Empty,
                    r#RepAtLeastOnce::<'i>,
                    __OptionalTrivia::<'i>,
                >,
                super::generics::Sequence4::<
                    super::generics::Positive::<super::generics::Str::<super::wrapper::W9>>,
                    ::pest3_core::typed::template::Empty,
                    r#Choice::<'i>,
                    __OptionalTrivia::<'i>,
                    r#Rep::<'i>,
                    __OptionalTrivia::<'i>,
                    r#Opt::<'i>,
                    __OptionalTrivia::<'i>,
                >,
                r#Peek::<'i>,
                r#PeekLeft::<'i>,
                r#PeekRight::<'i>,
                r#PeekLeftRight::<'i>,
                r#Drop::<'i>,
                r#PeekAll::<'i>,
            >,
        >,
    );
    #[allow(non_camel_case_types)]
    impl<'i> ::pest3_core::typed::PairContainer<super::Rule> for r#Choice<'i> {
        fn for_each_child_pair(
            &self,
            f: &mut impl ::pest3_core::std::FnMut(::pest3_core::token::Pair<super::Rule>),
        ) {
            self.content.for_self_or_for_each_child_pair(f)
        }
        fn for_self_or_for_each_child_pair(
            &self,
            f: &mut impl ::pest3_core::std::FnMut(::pest3_core::token::Pair<super::Rule>),
        ) {
            use pest3_core::typed::PairTree;
            f(self.as_pair_tree())
        }
    }
    #[allow(non_camel_case_types)]
    impl<'i> ::pest3_core::typed::PairTree<super::Rule> for r#Choice<'i> {
        fn get_rule() -> super::Rule {
            #[allow(unused_imports)]
            use pest3_core::typed::SubRule as _;
            super::Rule::r#Choice
        }
        fn get_span(&self) -> (::pest3_core::std::usize, ::pest3_core::std::usize) {
            (self.span.start(), self.span.end())
        }
    }
    #[doc = "Generated for rule `Rep`. Grammar: `\"b\"*`."]
    #[derive(Clone, Debug, Eq, PartialEq)]
    #[allow(non_camel_case_types)]
    pub struct r#Rep<'i> {
        #[doc = r" Matched structure."]
        pub content: ::pest3_core::std::Box<
            super::generics::Rep<
                super::generics::Str<super::wrapper::W8>,
                ::pest3_core::typed::template::Empty,
            >,
        >,
        #[doc = r" Matched span."]
        pub span: ::pest3_core::Span<'i>,
    }
    #[allow(non_camel_case_types)]
    impl<'i> ::pest3_core::typed::wrapper::Rule for r#Rep<'i> {
        type Rule = super::Rule;
        const RULE: super::Rule = super::Rule::r#Rep;
    }
    #[allow(non_camel_case_types)]
    impl<'i> r#Rep<'i> {}
    #[allow(unused_imports)]
    use pest3_core::typed::SubRule as _;
    ::pest3_core::typed::full_rule_struct!(
        r#Rep,
        (),
        super::Rule,
        super::Rule::r#Rep,
        super::generics::Rep::<
            super::generics::Str::<super::wrapper::W8>,
            ::pest3_core::typed::template::Empty,
        >,
        ::pest3_core::std::Box<
            super::generics::Rep::<
                super::generics::Str::<super::wrapper::W8>,
                ::pest3_core::typed::template::Empty,
            >,
        >,
    );
    #[allow(non_camel_case_types)]
    impl<'i> ::pest3_core::typed::PairContainer<super::Rule> for r#Rep<'i> {
        fn for_each_child_pair(
            &self,
            f: &mut impl ::pest3_core::std::FnMut(::pest3_core::token::Pair<super::Rule>),
        ) {
            self.content.for_self_or_for_each_child_pair(f)
        }
        fn for_self_or_for_each_child_pair(
            &self,
            f: &mut impl ::pest3_core::std::FnMut(::pest3_core::token::Pair<super::Rule>),
        ) {
            use pest3_core::typed::PairTree;
            f(self.as_pair_tree())
        }
    }
    #[allow(non_camel_case_types)]
    impl<'i> ::pest3_core::typed::PairTree<super::Rule> for r#Rep<'i> {
        fn get_rule() -> super::Rule {
            #[allow(unused_imports)]
            use pest3_core::typed::SubRule as _;
            super::Rule::r#Rep
        }
        fn get_span(&self) -> (::pest3_core::std::usize, ::pest3_core::std::usize) {
            (self.span.start(), self.span.end())
        }
    }
    #[doc = "Generated for rule `RepAtLeastOnce`. Grammar: `'0'..'9'+`."]
    #[derive(Clone, Debug, Eq, PartialEq)]
    #[allow(non_camel_case_types)]
    pub struct r#RepAtLeastOnce<'i> {
        #[doc = r" Matched structure."]
        pub content: ::pest3_core::std::Box<
            super::generics::RepOnce<
                super::generics::CharRange<'0', '9'>,
                ::pest3_core::typed::template::Empty,
            >,
        >,
        #[doc = r" Matched span."]
        pub span: ::pest3_core::Span<'i>,
    }
    #[allow(non_camel_case_types)]
    impl<'i> ::pest3_core::typed::wrapper::Rule for r#RepAtLeastOnce<'i> {
        type Rule = super::Rule;
        const RULE: super::Rule = super::Rule::r#RepAtLeastOnce;
    }
    #[allow(non_camel_case_types)]
    impl<'i> r#RepAtLeastOnce<'i> {}
    #[allow(unused_imports)]
    use pest3_core::typed::SubRule as _;
    ::pest3_core::typed::full_rule_struct!(
        r#RepAtLeastOnce,
        (),
        super::Rule,
        super::Rule::r#RepAtLeastOnce,
        super::generics::RepOnce::<
            super::generics::CharRange::<'0', '9'>,
            ::pest3_core::typed::template::Empty,
        >,
        ::pest3_core::std::Box<
            super::generics::RepOnce::<
                super::generics::CharRange::<'0', '9'>,
                ::pest3_core::typed::template::Empty,
            >,
        >,
    );
    #[allow(non_camel_case_types)]
    impl<'i> ::pest3_core::typed::PairContainer<super::Rule> for r#RepAtLeastOnce<'i> {
        fn for_each_child_pair(
            &self,
            f: &mut impl ::pest3_core::std::FnMut(::pest3_core::token::Pair<super::Rule>),
        ) {
            self.content.for_self_or_for_each_child_pair(f)
        }
        fn for_self_or_for_each_child_pair(
            &self,
            f: &mut impl ::pest3_core::std::FnMut(::pest3_core::token::Pair<super::Rule>),
        ) {
            use pest3_core::typed::PairTree;
            f(self.as_pair_tree())
        }
    }
    #[allow(non_camel_case_types)]
    impl<'i> ::pest3_core::typed::PairTree<super::Rule> for r#RepAtLeastOnce<'i> {
        fn get_rule() -> super::Rule {
            #[allow(unused_imports)]
            use pest3_core::typed::SubRule as _;
            super::Rule::r#RepAtLeastOnce
        }
        fn get_span(&self) -> (::pest3_core::std::usize, ::pest3_core::std::usize) {
            (self.span.start(), self.span.end())
        }
    }
    #[doc = "Generated for rule `Opt`. Grammar: `\"?\"?`."]
    #[derive(Clone, Debug, Eq, PartialEq)]
    #[allow(non_camel_case_types)]
    pub struct r#Opt<'i> {
        #[doc = r" Matched structure."]
        pub content: ::pest3_core::std::Box<
            ::pest3_core::std::Option<super::generics::Str<super::wrapper::W10>>,
        >,
        #[doc = r" Matched span."]
        pub span: ::pest3_core::Span<'i>,
    }
    #[allow(non_camel_case_types)]
    impl<'i> ::pest3_core::typed::wrapper::Rule for r#Opt<'i> {
        type Rule = super::Rule;
        const RULE: super::Rule = super::Rule::r#Opt;
    }
    #[allow(non_camel_case_types)]
    impl<'i> r#Opt<'i> {}
    #[allow(unused_imports)]
    use pest3_core::typed::SubRule as _;
    ::pest3_core::typed::full_rule_struct!(
        r#Opt,
        (),
        super::Rule,
        super::Rule::r#Opt,
        ::pest3_core::std::Option::<super::generics::Str::<super::wrapper::W10>>,
        ::pest3_core::std::Box<
            ::pest3_core::std::Option::<super::generics::Str::<super::wrapper::W10>>,
        >,
    );
    #[allow(non_camel_case_types)]
    impl<'i> ::pest3_core::typed::PairContainer<super::Rule> for r#Opt<'i> {
        fn for_each_child_pair(
            &self,
            f: &mut impl ::pest3_core::std::FnMut(::pest3_core::token::Pair<super::Rule>),
        ) {
            self.content.for_self_or_for_each_child_pair(f)
        }
        fn for_self_or_for_each_child_pair(
            &self,
            f: &mut impl ::pest3_core::std::FnMut(::pest3_core::token::Pair<super::Rule>),
        ) {
            use pest3_core::typed::PairTree;
            f(self.as_pair_tree())
        }
    }
    #[allow(non_camel_case_types)]
    impl<'i> ::pest3_core::typed::PairTree<super::Rule> for r#Opt<'i> {
        fn get_rule() -> super::Rule {
            #[allow(unused_imports)]
            use pest3_core::typed::SubRule as _;
            super::Rule::r#Opt
        }
        fn get_span(&self) -> (::pest3_core::std::usize, ::pest3_core::std::usize) {
            (self.span.start(), self.span.end())
        }
    }
    #[doc = "Generated for rule `RepExact`. Grammar: `RepAtLeastOnce[3..3]`."]
    #[derive(Clone, Debug, Eq, PartialEq)]
    #[allow(non_camel_case_types)]
    pub struct r#RepExact<'i> {
        #[doc = r" Matched structure."]
        pub content: ::pest3_core::std::Box<
            super::generics::RepMinMax<
                r#RepAtLeastOnce<'i>,
                ::pest3_core::typed::template::Empty,
                3usize,
                3usize,
            >,
        >,
        #[doc = r" Matched span."]
        pub span: ::pest3_core::Span<'i>,
    }
    #[allow(non_camel_case_types)]
    impl<'i> ::pest3_core::typed::wrapper::Rule for r#RepExact<'i> {
        type Rule = super::Rule;
        const RULE: super::Rule = super::Rule::r#RepExact;
    }
    #[allow(non_camel_case_types)]
    impl<'i> r#RepExact<'i> {
        #[doc = "A helper function to access [`RepAtLeastOnce`]."]
        #[allow(non_snake_case)]
        pub fn r#RepAtLeastOnce<'s>(&'s self) -> ::pest3_core::std::Vec<&'s r#RepAtLeastOnce<'i>> {
            let res = &*self.content;
            {
                let res = res
                    .content
                    .iter()
                    .map(|res| res)
                    .collect::<::pest3_core::std::Vec<_>>();
                res
            }
        }
    }
    #[allow(unused_imports)]
    use pest3_core::typed::SubRule as _;
    ::pest3_core::typed::full_rule_struct!(
        r#RepExact,
        (),
        super::Rule,
        super::Rule::r#RepExact,
        super::generics::RepMinMax::<
            r#RepAtLeastOnce::<'i>,
            ::pest3_core::typed::template::Empty,
            3usize,
            3usize,
        >,
        ::pest3_core::std::Box<
            super::generics::RepMinMax::<
                r#RepAtLeastOnce::<'i>,
                ::pest3_core::typed::template::Empty,
                3usize,
                3usize,
            >,
        >,
    );
    #[allow(non_camel_case_types)]
    impl<'i> ::pest3_core::typed::PairContainer<super::Rule> for r#RepExact<'i> {
        fn for_each_child_pair(
            &self,
            f: &mut impl ::pest3_core::std::FnMut(::pest3_core::token::Pair<super::Rule>),
        ) {
            self.content.for_self_or_for_each_child_pair(f)
        }
        fn for_self_or_for_each_child_pair(
            &self,
            f: &mut impl ::pest3_core::std::FnMut(::pest3_core::token::Pair<super::Rule>),
        ) {
            use pest3_core::typed::PairTree;
            f(self.as_pair_tree())
        }
    }
    #[allow(non_camel_case_types)]
    impl<'i> ::pest3_core::typed::PairTree<super::Rule> for r#RepExact<'i> {
        fn get_rule() -> super::Rule {
            #[allow(unused_imports)]
            use pest3_core::typed::SubRule as _;
            super::Rule::r#RepExact
        }
        fn get_span(&self) -> (::pest3_core::std::usize, ::pest3_core::std::usize) {
            (self.span.start(), self.span.end())
        }
    }
    #[doc = "Generated for rule `RepLeft`. Grammar: `RepExact[1..]`."]
    #[derive(Clone, Debug, Eq, PartialEq)]
    #[allow(non_camel_case_types)]
    pub struct r#RepLeft<'i> {
        #[doc = r" Matched structure."]
        pub content: ::pest3_core::std::Box<
            super::generics::RepMin<r#RepExact<'i>, ::pest3_core::typed::template::Empty, 1usize>,
        >,
        #[doc = r" Matched span."]
        pub span: ::pest3_core::Span<'i>,
    }
    #[allow(non_camel_case_types)]
    impl<'i> ::pest3_core::typed::wrapper::Rule for r#RepLeft<'i> {
        type Rule = super::Rule;
        const RULE: super::Rule = super::Rule::r#RepLeft;
    }
    #[allow(non_camel_case_types)]
    impl<'i> r#RepLeft<'i> {
        #[doc = "A helper function to access [`RepExact`]."]
        #[allow(non_snake_case)]
        pub fn r#RepExact<'s>(&'s self) -> ::pest3_core::std::Vec<&'s r#RepExact<'i>> {
            let res = &*self.content;
            {
                let res = res
                    .content
                    .iter()
                    .map(|res| res)
                    .collect::<::pest3_core::std::Vec<_>>();
                res
            }
        }
    }
    #[allow(unused_imports)]
    use pest3_core::typed::SubRule as _;
    ::pest3_core::typed::full_rule_struct!(
        r#RepLeft,
        (),
        super::Rule,
        super::Rule::r#RepLeft,
        super::generics::RepMin::<r#RepExact::<'i>, ::pest3_core::typed::template::Empty, 1usize>,
        ::pest3_core::std::Box<
            super::generics::RepMin::<r#RepExact::<'i>, ::pest3_core::typed::template::Empty, 1usize>,
        >,
    );
    #[allow(non_camel_case_types)]
    impl<'i> ::pest3_core::typed::PairContainer<super::Rule> for r#RepLeft<'i> {
        fn for_each_child_pair(
            &self,
            f: &mut impl ::pest3_core::std::FnMut(::pest3_core::token::Pair<super::Rule>),
        ) {
            self.content.for_self_or_for_each_child_pair(f)
        }
        fn for_self_or_for_each_child_pair(
            &self,
            f: &mut impl ::pest3_core::std::FnMut(::pest3_core::token::Pair<super::Rule>),
        ) {
            use pest3_core::typed::PairTree;
            f(self.as_pair_tree())
        }
    }
    #[allow(non_camel_case_types)]
    impl<'i> ::pest3_core::typed::PairTree<super::Rule> for r#RepLeft<'i> {
        fn get_rule() -> super::Rule {
            #[allow(unused_imports)]
            use pest3_core::typed::SubRule as _;
            super::Rule::r#RepLeft
        }
        fn get_span(&self) -> (::pest3_core::std::usize, ::pest3_core::std::usize) {
            (self.span.start(), self.span.end())
        }
    }
    #[doc = "Generated for rule `RepRight`. Grammar: `RepLeft[..2]`."]
    #[derive(Clone, Debug, Eq, PartialEq)]
    #[allow(non_camel_case_types)]
    pub struct r#RepRight<'i> {
        #[doc = r" Matched structure."]
        pub content: ::pest3_core::std::Box<
            super::generics::RepMax<r#RepLeft<'i>, ::pest3_core::typed::template::Empty, 2usize>,
        >,
        #[doc = r" Matched span."]
        pub span: ::pest3_core::Span<'i>,
    }
    #[allow(non_camel_case_types)]
    impl<'i> ::pest3_core::typed::wrapper::Rule for r#RepRight<'i> {
        type Rule = super::Rule;
        const RULE: super::Rule = super::Rule::r#RepRight;
    }
    #[allow(non_camel_case_types)]
    impl<'i> r#RepRight<'i> {
        #[doc = "A helper function to access [`RepLeft`]."]
        #[allow(non_snake_case)]
        pub fn r#RepLeft<'s>(&'s self) -> ::pest3_core::std::Vec<&'s r#RepLeft<'i>> {
            let res = &*self.content;
            {
                let res = res
                    .content
                    .iter()
                    .map(|res| res)
                    .collect::<::pest3_core::std::Vec<_>>();
                res
            }
        }
    }
    #[allow(unused_imports)]
    use pest3_core::typed::SubRule as _;
    ::pest3_core::typed::full_rule_struct!(
        r#RepRight,
        (),
        super::Rule,
        super::Rule::r#RepRight,
        super::generics::RepMax::<r#RepLeft::<'i>, ::pest3_core::typed::template::Empty, 2usize>,
        ::pest3_core::std::Box<
            super::generics::RepMax::<r#RepLeft::<'i>, ::pest3_core::typed::template::Empty, 2usize>,
        >,
    );
    #[allow(non_camel_case_types)]
    impl<'i> ::pest3_core::typed::PairContainer<super::Rule> for r#RepRight<'i> {
        fn for_each_child_pair(
            &self,
            f: &mut impl ::pest3_core::std::FnMut(::pest3_core::token::Pair<super::Rule>),
        ) {
            self.content.for_self_or_for_each_child_pair(f)
        }
        fn for_self_or_for_each_child_pair(
            &self,
            f: &mut impl ::pest3_core::std::FnMut(::pest3_core::token::Pair<super::Rule>),
        ) {
            use pest3_core::typed::PairTree;
            f(self.as_pair_tree())
        }
    }
    #[allow(non_camel_case_types)]
    impl<'i> ::pest3_core::typed::PairTree<super::Rule> for r#RepRight<'i> {
        fn get_rule() -> super::Rule {
            #[allow(unused_imports)]
            use pest3_core::typed::SubRule as _;
            super::Rule::r#RepRight
        }
        fn get_span(&self) -> (::pest3_core::std::usize, ::pest3_core::std::usize) {
            (self.span.start(), self.span.end())
        }
    }
    #[doc = "Generated for rule `RepLeftRight`. Grammar: `RepRight[1..2]`."]
    #[derive(Clone, Debug, Eq, PartialEq)]
    #[allow(non_camel_case_types)]
    pub struct r#RepLeftRight<'i> {
        #[doc = r" Matched structure."]
        pub content: ::pest3_core::std::Box<
            super::generics::RepMinMax<
                r#RepRight<'i>,
                ::pest3_core::typed::template::Empty,
                1usize,
                2usize,
            >,
        >,
        #[doc = r" Matched span."]
        pub span: ::pest3_core::Span<'i>,
    }
    #[allow(non_camel_case_types)]
    impl<'i> ::pest3_core::typed::wrapper::Rule for r#RepLeftRight<'i> {
        type Rule = super::Rule;
        const RULE: super::Rule = super::Rule::r#RepLeftRight;
    }
    #[allow(non_camel_case_types)]
    impl<'i> r#RepLeftRight<'i> {
        #[doc = "A helper function to access [`RepRight`]."]
        #[allow(non_snake_case)]
        pub fn r#RepRight<'s>(&'s self) -> ::pest3_core::std::Vec<&'s r#RepRight<'i>> {
            let res = &*self.content;
            {
                let res = res
                    .content
                    .iter()
                    .map(|res| res)
                    .collect::<::pest3_core::std::Vec<_>>();
                res
            }
        }
    }
    #[allow(unused_imports)]
    use pest3_core::typed::SubRule as _;
    ::pest3_core::typed::full_rule_struct!(
        r#RepLeftRight,
        (),
        super::Rule,
        super::Rule::r#RepLeftRight,
        super::generics::RepMinMax::<
            r#RepRight::<'i>,
            ::pest3_core::typed::template::Empty,
            1usize,
            2usize,
        >,
        ::pest3_core::std::Box<
            super::generics::RepMinMax::<
                r#RepRight::<'i>,
                ::pest3_core::typed::template::Empty,
                1usize,
                2usize,
            >,
        >,
    );
    #[allow(non_camel_case_types)]
    impl<'i> ::pest3_core::typed::PairContainer<super::Rule> for r#RepLeftRight<'i> {
        fn for_each_child_pair(
            &self,
            f: &mut impl ::pest3_core::std::FnMut(::pest3_core::token::Pair<super::Rule>),
        ) {
            self.content.for_self_or_for_each_child_pair(f)
        }
        fn for_self_or_for_each_child_pair(
            &self,
            f: &mut impl ::pest3_core::std::FnMut(::pest3_core::token::Pair<super::Rule>),
        ) {
            use pest3_core::typed::PairTree;
            f(self.as_pair_tree())
        }
    }
    #[allow(non_camel_case_types)]
    impl<'i> ::pest3_core::typed::PairTree<super::Rule> for r#RepLeftRight<'i> {
        fn get_rule() -> super::Rule {
            #[allow(unused_imports)]
            use pest3_core::typed::SubRule as _;
            super::Rule::r#RepLeftRight
        }
        fn get_span(&self) -> (::pest3_core::std::usize, ::pest3_core::std::usize) {
            (self.span.start(), self.span.end())
        }
    }
    #[doc = "Generated for rule `Pos`. Grammar: `&(pest::soi ~ RepLeftRight[2..4])`."]
    #[derive(Clone, Debug, Eq, PartialEq)]
    #[allow(non_camel_case_types)]
    pub struct r#Pos<'i> {
        #[doc = r" Matched structure."]
        pub content: ::pest3_core::std::Box<
            super::generics::Positive<
                super::generics::Sequence2<
                    super::generics::r#soi,
                    ::pest3_core::typed::template::Empty,
                    super::generics::RepMinMax<
                        r#RepLeftRight<'i>,
                        ::pest3_core::typed::template::Empty,
                        2usize,
                        4usize,
                    >,
                    __OptionalTrivia<'i>,
                >,
            >,
        >,
        #[doc = r" Matched span."]
        pub span: ::pest3_core::Span<'i>,
    }
    #[allow(non_camel_case_types)]
    impl<'i> ::pest3_core::typed::wrapper::Rule for r#Pos<'i> {
        type Rule = super::Rule;
        const RULE: super::Rule = super::Rule::r#Pos;
    }
    #[allow(non_camel_case_types)]
    impl<'i> r#Pos<'i> {
        #[doc = "A helper function to access [`RepLeftRight`]."]
        #[allow(non_snake_case)]
        pub fn r#RepLeftRight<'s>(&'s self) -> ::pest3_core::std::Vec<&'s r#RepLeftRight<'i>> {
            let res = &*self.content;
            {
                let res = &res.field_1;
                {
                    let res = res
                        .content
                        .iter()
                        .map(|res| res)
                        .collect::<::pest3_core::std::Vec<_>>();
                    res
                }
            }
        }
        #[doc = "A helper function to access [`soi`]."]
        #[allow(non_snake_case)]
        pub fn r#soi<'s>(&'s self) -> &'s super::generics::r#soi {
            let res = &*self.content;
            {
                let res = &res.field_0;
                res
            }
        }
    }
    #[allow(unused_imports)]
    use pest3_core::typed::SubRule as _;
    ::pest3_core::typed::full_rule_struct!(
        r#Pos,
        (),
        super::Rule,
        super::Rule::r#Pos,
        super::generics::Positive::<
            super::generics::Sequence2::<
                super::generics::r#soi,
                ::pest3_core::typed::template::Empty,
                super::generics::RepMinMax::<
                    r#RepLeftRight::<'i>,
                    ::pest3_core::typed::template::Empty,
                    2usize,
                    4usize,
                >,
                __OptionalTrivia::<'i>,
            >,
        >,
        ::pest3_core::std::Box<
            super::generics::Positive::<
                super::generics::Sequence2::<
                    super::generics::r#soi,
                    ::pest3_core::typed::template::Empty,
                    super::generics::RepMinMax::<
                        r#RepLeftRight::<'i>,
                        ::pest3_core::typed::template::Empty,
                        2usize,
                        4usize,
                    >,
                    __OptionalTrivia::<'i>,
                >,
            >,
        >,
    );
    #[allow(non_camel_case_types)]
    impl<'i> ::pest3_core::typed::PairContainer<super::Rule> for r#Pos<'i> {
        fn for_each_child_pair(
            &self,
            f: &mut impl ::pest3_core::std::FnMut(::pest3_core::token::Pair<super::Rule>),
        ) {
            self.content.for_self_or_for_each_child_pair(f)
        }
        fn for_self_or_for_each_child_pair(
            &self,
            f: &mut impl ::pest3_core::std::FnMut(::pest3_core::token::Pair<super::Rule>),
        ) {
            use pest3_core::typed::PairTree;
            f(self.as_pair_tree())
        }
    }
    #[allow(non_camel_case_types)]
    impl<'i> ::pest3_core::typed::PairTree<super::Rule> for r#Pos<'i> {
        fn get_rule() -> super::Rule {
            #[allow(unused_imports)]
            use pest3_core::typed::SubRule as _;
            super::Rule::r#Pos
        }
        fn get_span(&self) -> (::pest3_core::std::usize, ::pest3_core::std::usize) {
            (self.span.start(), self.span.end())
        }
    }
    #[doc = "Generated for rule `Neg`. Grammar: `!(pest::EOI ~ Pos)`."]
    #[derive(Clone, Debug, Eq, PartialEq)]
    #[allow(non_camel_case_types)]
    pub struct r#Neg<'i> {
        #[doc = r" Matched structure."]
        pub content: ::pest3_core::std::Box<
            super::generics::Negative<
                super::generics::Sequence2<
                    super::generics::r#EOI,
                    ::pest3_core::typed::template::Empty,
                    r#Pos<'i>,
                    __OptionalTrivia<'i>,
                >,
            >,
        >,
        #[doc = r" Matched span."]
        pub span: ::pest3_core::Span<'i>,
    }
    #[allow(non_camel_case_types)]
    impl<'i> ::pest3_core::typed::wrapper::Rule for r#Neg<'i> {
        type Rule = super::Rule;
        const RULE: super::Rule = super::Rule::r#Neg;
    }
    #[allow(non_camel_case_types)]
    impl<'i> r#Neg<'i> {}
    #[allow(unused_imports)]
    use pest3_core::typed::SubRule as _;
    ::pest3_core::typed::full_rule_struct!(
        r#Neg,
        (),
        super::Rule,
        super::Rule::r#Neg,
        super::generics::Negative::<
            super::generics::Sequence2::<
                super::generics::r#EOI,
                ::pest3_core::typed::template::Empty,
                r#Pos::<'i>,
                __OptionalTrivia::<'i>,
            >,
        >,
        ::pest3_core::std::Box<
            super::generics::Negative::<
                super::generics::Sequence2::<
                    super::generics::r#EOI,
                    ::pest3_core::typed::template::Empty,
                    r#Pos::<'i>,
                    __OptionalTrivia::<'i>,
                >,
            >,
        >,
    );
    #[allow(non_camel_case_types)]
    impl<'i> ::pest3_core::typed::PairContainer<super::Rule> for r#Neg<'i> {
        fn for_each_child_pair(
            &self,
            f: &mut impl ::pest3_core::std::FnMut(::pest3_core::token::Pair<super::Rule>),
        ) {
            self.content.for_self_or_for_each_child_pair(f)
        }
        fn for_self_or_for_each_child_pair(
            &self,
            f: &mut impl ::pest3_core::std::FnMut(::pest3_core::token::Pair<super::Rule>),
        ) {
            use pest3_core::typed::PairTree;
            f(self.as_pair_tree())
        }
    }
    #[allow(non_camel_case_types)]
    impl<'i> ::pest3_core::typed::PairTree<super::Rule> for r#Neg<'i> {
        fn get_rule() -> super::Rule {
            #[allow(unused_imports)]
            use pest3_core::typed::SubRule as _;
            super::Rule::r#Neg
        }
        fn get_span(&self) -> (::pest3_core::std::usize, ::pest3_core::std::usize) {
            (self.span.start(), self.span.end())
        }
    }
    #[doc = "Generated for rule `Push`. Grammar: `pest::stack::push((RepLeft* ~ (Neg ~ (ExactString+ ~ (Push ~ (Pop ~ (Push ~ PopAll)))))))`."]
    #[derive(Clone, Debug, Eq, PartialEq)]
    #[allow(non_camel_case_types)]
    pub struct r#Push<'i> {
        #[doc = r" Matched structure."]
        pub content: ::pest3_core::std::Box<
            super::generics::r#push<
                super::generics::Sequence7<
                    super::generics::Rep<r#RepLeft<'i>, ::pest3_core::typed::template::Empty>,
                    ::pest3_core::typed::template::Empty,
                    r#Neg<'i>,
                    __OptionalTrivia<'i>,
                    super::generics::RepOnce<
                        r#ExactString<'i>,
                        ::pest3_core::typed::template::Empty,
                    >,
                    __OptionalTrivia<'i>,
                    r#Push<'i>,
                    __OptionalTrivia<'i>,
                    r#Pop<'i>,
                    __OptionalTrivia<'i>,
                    r#Push<'i>,
                    __OptionalTrivia<'i>,
                    r#PopAll<'i>,
                    __OptionalTrivia<'i>,
                >,
            >,
        >,
        #[doc = r" Matched span."]
        pub span: ::pest3_core::Span<'i>,
    }
    #[allow(non_camel_case_types)]
    impl<'i> ::pest3_core::typed::wrapper::Rule for r#Push<'i> {
        type Rule = super::Rule;
        const RULE: super::Rule = super::Rule::r#Push;
    }
    #[allow(non_camel_case_types)]
    impl<'i> r#Push<'i> {
        #[doc = "A helper function to access [`push`]."]
        #[allow(non_snake_case)]
        pub fn r#push<'s>(
            &'s self,
        ) -> &'s super::generics::r#push<
            super::generics::Sequence7<
                super::generics::Rep<r#RepLeft<'i>, ::pest3_core::typed::template::Empty>,
                ::pest3_core::typed::template::Empty,
                r#Neg<'i>,
                __OptionalTrivia<'i>,
                super::generics::RepOnce<r#ExactString<'i>, ::pest3_core::typed::template::Empty>,
                __OptionalTrivia<'i>,
                r#Push<'i>,
                __OptionalTrivia<'i>,
                r#Pop<'i>,
                __OptionalTrivia<'i>,
                r#Push<'i>,
                __OptionalTrivia<'i>,
                r#PopAll<'i>,
                __OptionalTrivia<'i>,
            >,
        > {
            let res = &*self.content;
            res
        }
    }
    #[allow(unused_imports)]
    use pest3_core::typed::SubRule as _;
    ::pest3_core::typed::full_rule_struct!(
        r#Push,
        (),
        super::Rule,
        super::Rule::r#Push,
        super::generics::r#push::<
            super::generics::Sequence7::<
                super::generics::Rep::<r#RepLeft::<'i>, ::pest3_core::typed::template::Empty>,
                ::pest3_core::typed::template::Empty,
                r#Neg::<'i>,
                __OptionalTrivia::<'i>,
                super::generics::RepOnce::<r#ExactString::<'i>, ::pest3_core::typed::template::Empty>,
                __OptionalTrivia::<'i>,
                r#Push::<'i>,
                __OptionalTrivia::<'i>,
                r#Pop::<'i>,
                __OptionalTrivia::<'i>,
                r#Push::<'i>,
                __OptionalTrivia::<'i>,
                r#PopAll::<'i>,
                __OptionalTrivia::<'i>,
            >,
        >,
        ::pest3_core::std::Box<
            super::generics::r#push::<
                super::generics::Sequence7::<
                    super::generics::Rep::<r#RepLeft::<'i>, ::pest3_core::typed::template::Empty>,
                    ::pest3_core::typed::template::Empty,
                    r#Neg::<'i>,
                    __OptionalTrivia::<'i>,
                    super::generics::RepOnce::<
                        r#ExactString::<'i>,
                        ::pest3_core::typed::template::Empty,
                    >,
                    __OptionalTrivia::<'i>,
                    r#Push::<'i>,
                    __OptionalTrivia::<'i>,
                    r#Pop::<'i>,
                    __OptionalTrivia::<'i>,
                    r#Push::<'i>,
                    __OptionalTrivia::<'i>,
                    r#PopAll::<'i>,
                    __OptionalTrivia::<'i>,
                >,
            >,
        >,
    );
    #[allow(non_camel_case_types)]
    impl<'i> ::pest3_core::typed::PairContainer<super::Rule> for r#Push<'i> {
        fn for_each_child_pair(
            &self,
            f: &mut impl ::pest3_core::std::FnMut(::pest3_core::token::Pair<super::Rule>),
        ) {
            self.content.for_self_or_for_each_child_pair(f)
        }
        fn for_self_or_for_each_child_pair(
            &self,
            f: &mut impl ::pest3_core::std::FnMut(::pest3_core::token::Pair<super::Rule>),
        ) {
            use pest3_core::typed::PairTree;
            f(self.as_pair_tree())
        }
    }
    #[allow(non_camel_case_types)]
    impl<'i> ::pest3_core::typed::PairTree<super::Rule> for r#Push<'i> {
        fn get_rule() -> super::Rule {
            #[allow(unused_imports)]
            use pest3_core::typed::SubRule as _;
            super::Rule::r#Push
        }
        fn get_span(&self) -> (::pest3_core::std::usize, ::pest3_core::std::usize) {
            (self.span.start(), self.span.end())
        }
    }
    #[doc = "Generated for rule `Pop`. Grammar: `pest::stack::pop`."]
    #[derive(Clone, Debug, Eq, PartialEq)]
    #[allow(non_camel_case_types)]
    pub struct r#Pop<'i> {
        #[doc = r" Matched structure."]
        pub content: ::pest3_core::std::Box<super::generics::r#pop<'i>>,
        #[doc = r" Matched span."]
        pub span: ::pest3_core::Span<'i>,
    }
    #[allow(non_camel_case_types)]
    impl<'i> ::pest3_core::typed::wrapper::Rule for r#Pop<'i> {
        type Rule = super::Rule;
        const RULE: super::Rule = super::Rule::r#Pop;
    }
    #[allow(non_camel_case_types)]
    impl<'i> r#Pop<'i> {
        #[doc = "A helper function to access [`pop`]."]
        #[allow(non_snake_case)]
        pub fn r#pop<'s>(&'s self) -> &'s super::generics::r#pop<'i> {
            let res = &*self.content;
            res
        }
    }
    #[allow(unused_imports)]
    use pest3_core::typed::SubRule as _;
    ::pest3_core::typed::full_rule_struct!(
        r#Pop,
        (),
        super::Rule,
        super::Rule::r#Pop,
        super::generics::r#pop::<'i>,
        ::pest3_core::std::Box<super::generics::r#pop::<'i>>,
    );
    #[allow(non_camel_case_types)]
    impl<'i> ::pest3_core::typed::PairContainer<super::Rule> for r#Pop<'i> {
        fn for_each_child_pair(
            &self,
            f: &mut impl ::pest3_core::std::FnMut(::pest3_core::token::Pair<super::Rule>),
        ) {
            self.content.for_self_or_for_each_child_pair(f)
        }
        fn for_self_or_for_each_child_pair(
            &self,
            f: &mut impl ::pest3_core::std::FnMut(::pest3_core::token::Pair<super::Rule>),
        ) {
            use pest3_core::typed::PairTree;
            f(self.as_pair_tree())
        }
    }
    #[allow(non_camel_case_types)]
    impl<'i> ::pest3_core::typed::PairTree<super::Rule> for r#Pop<'i> {
        fn get_rule() -> super::Rule {
            #[allow(unused_imports)]
            use pest3_core::typed::SubRule as _;
            super::Rule::r#Pop
        }
        fn get_span(&self) -> (::pest3_core::std::usize, ::pest3_core::std::usize) {
            (self.span.start(), self.span.end())
        }
    }
    #[doc = "Generated for rule `PopAll`. Grammar: `pest::stack::pop_all`."]
    #[derive(Clone, Debug, Eq, PartialEq)]
    #[allow(non_camel_case_types)]
    pub struct r#PopAll<'i> {
        #[doc = r" Matched structure."]
        pub content: ::pest3_core::std::Box<super::generics::r#pop_all<'i>>,
        #[doc = r" Matched span."]
        pub span: ::pest3_core::Span<'i>,
    }
    #[allow(non_camel_case_types)]
    impl<'i> ::pest3_core::typed::wrapper::Rule for r#PopAll<'i> {
        type Rule = super::Rule;
        const RULE: super::Rule = super::Rule::r#PopAll;
    }
    #[allow(non_camel_case_types)]
    impl<'i> r#PopAll<'i> {
        #[doc = "A helper function to access [`pop_all`]."]
        #[allow(non_snake_case)]
        pub fn r#pop_all<'s>(&'s self) -> &'s super::generics::r#pop_all<'i> {
            let res = &*self.content;
            res
        }
    }
    #[allow(unused_imports)]
    use pest3_core::typed::SubRule as _;
    ::pest3_core::typed::full_rule_struct!(
        r#PopAll,
        (),
        super::Rule,
        super::Rule::r#PopAll,
        super::generics::r#pop_all::<'i>,
        ::pest3_core::std::Box<super::generics::r#pop_all::<'i>>,
    );
    #[allow(non_camel_case_types)]
    impl<'i> ::pest3_core::typed::PairContainer<super::Rule> for r#PopAll<'i> {
        fn for_each_child_pair(
            &self,
            f: &mut impl ::pest3_core::std::FnMut(::pest3_core::token::Pair<super::Rule>),
        ) {
            self.content.for_self_or_for_each_child_pair(f)
        }
        fn for_self_or_for_each_child_pair(
            &self,
            f: &mut impl ::pest3_core::std::FnMut(::pest3_core::token::Pair<super::Rule>),
        ) {
            use pest3_core::typed::PairTree;
            f(self.as_pair_tree())
        }
    }
    #[allow(non_camel_case_types)]
    impl<'i> ::pest3_core::typed::PairTree<super::Rule> for r#PopAll<'i> {
        fn get_rule() -> super::Rule {
            #[allow(unused_imports)]
            use pest3_core::typed::SubRule as _;
            super::Rule::r#PopAll
        }
        fn get_span(&self) -> (::pest3_core::std::usize, ::pest3_core::std::usize) {
            (self.span.start(), self.span.end())
        }
    }
    #[doc = "Generated for rule `Peek`. Grammar: `pest::stack::peek`."]
    #[derive(Clone, Debug, Eq, PartialEq)]
    #[allow(non_camel_case_types)]
    pub struct r#Peek<'i> {
        #[doc = r" Matched structure."]
        pub content: ::pest3_core::std::Box<super::generics::r#peek<'i>>,
        #[doc = r" Matched span."]
        pub span: ::pest3_core::Span<'i>,
    }
    #[allow(non_camel_case_types)]
    impl<'i> ::pest3_core::typed::wrapper::Rule for r#Peek<'i> {
        type Rule = super::Rule;
        const RULE: super::Rule = super::Rule::r#Peek;
    }
    #[allow(non_camel_case_types)]
    impl<'i> r#Peek<'i> {
        #[doc = "A helper function to access [`peek`]."]
        #[allow(non_snake_case)]
        pub fn r#peek<'s>(&'s self) -> &'s super::generics::r#peek<'i> {
            let res = &*self.content;
            res
        }
    }
    #[allow(unused_imports)]
    use pest3_core::typed::SubRule as _;
    ::pest3_core::typed::full_rule_struct!(
        r#Peek,
        (),
        super::Rule,
        super::Rule::r#Peek,
        super::generics::r#peek::<'i>,
        ::pest3_core::std::Box<super::generics::r#peek::<'i>>,
    );
    #[allow(non_camel_case_types)]
    impl<'i> ::pest3_core::typed::PairContainer<super::Rule> for r#Peek<'i> {
        fn for_each_child_pair(
            &self,
            f: &mut impl ::pest3_core::std::FnMut(::pest3_core::token::Pair<super::Rule>),
        ) {
            self.content.for_self_or_for_each_child_pair(f)
        }
        fn for_self_or_for_each_child_pair(
            &self,
            f: &mut impl ::pest3_core::std::FnMut(::pest3_core::token::Pair<super::Rule>),
        ) {
            use pest3_core::typed::PairTree;
            f(self.as_pair_tree())
        }
    }
    #[allow(non_camel_case_types)]
    impl<'i> ::pest3_core::typed::PairTree<super::Rule> for r#Peek<'i> {
        fn get_rule() -> super::Rule {
            #[allow(unused_imports)]
            use pest3_core::typed::SubRule as _;
            super::Rule::r#Peek
        }
        fn get_span(&self) -> (::pest3_core::std::usize, ::pest3_core::std::usize) {
            (self.span.start(), self.span.end())
        }
    }
    #[doc = "Generated for rule `PeekUnlimited`. Grammar: `pest::stack::peek[..]`."]
    #[derive(Clone, Debug, Eq, PartialEq)]
    #[allow(non_camel_case_types)]
    pub struct r#PeekUnlimited<'i> {
        #[doc = r" Matched structure."]
        pub content: ::pest3_core::std::Box<super::generics::PeekSlice1<0isize>>,
        #[doc = r" Matched span."]
        pub span: ::pest3_core::Span<'i>,
    }
    #[allow(non_camel_case_types)]
    impl<'i> ::pest3_core::typed::wrapper::Rule for r#PeekUnlimited<'i> {
        type Rule = super::Rule;
        const RULE: super::Rule = super::Rule::r#PeekUnlimited;
    }
    #[allow(non_camel_case_types)]
    impl<'i> r#PeekUnlimited<'i> {
        #[doc = "A helper function to access [`peek`]."]
        #[allow(non_snake_case)]
        pub fn r#peek<'s>(&'s self) -> &'s super::generics::PeekSlice1<0isize> {
            let res = &*self.content;
            res
        }
    }
    #[allow(unused_imports)]
    use pest3_core::typed::SubRule as _;
    ::pest3_core::typed::full_rule_struct!(
        r#PeekUnlimited,
        (),
        super::Rule,
        super::Rule::r#PeekUnlimited,
        super::generics::PeekSlice1::<0isize>,
        ::pest3_core::std::Box<super::generics::PeekSlice1::<0isize>>,
    );
    #[allow(non_camel_case_types)]
    impl<'i> ::pest3_core::typed::PairContainer<super::Rule> for r#PeekUnlimited<'i> {
        fn for_each_child_pair(
            &self,
            f: &mut impl ::pest3_core::std::FnMut(::pest3_core::token::Pair<super::Rule>),
        ) {
            self.content.for_self_or_for_each_child_pair(f)
        }
        fn for_self_or_for_each_child_pair(
            &self,
            f: &mut impl ::pest3_core::std::FnMut(::pest3_core::token::Pair<super::Rule>),
        ) {
            use pest3_core::typed::PairTree;
            f(self.as_pair_tree())
        }
    }
    #[allow(non_camel_case_types)]
    impl<'i> ::pest3_core::typed::PairTree<super::Rule> for r#PeekUnlimited<'i> {
        fn get_rule() -> super::Rule {
            #[allow(unused_imports)]
            use pest3_core::typed::SubRule as _;
            super::Rule::r#PeekUnlimited
        }
        fn get_span(&self) -> (::pest3_core::std::usize, ::pest3_core::std::usize) {
            (self.span.start(), self.span.end())
        }
    }
    #[doc = "Generated for rule `PeekLeft`. Grammar: `pest::stack::peek[1..]`."]
    #[derive(Clone, Debug, Eq, PartialEq)]
    #[allow(non_camel_case_types)]
    pub struct r#PeekLeft<'i> {
        #[doc = r" Matched structure."]
        pub content: ::pest3_core::std::Box<super::generics::PeekSlice1<1isize>>,
        #[doc = r" Matched span."]
        pub span: ::pest3_core::Span<'i>,
    }
    #[allow(non_camel_case_types)]
    impl<'i> ::pest3_core::typed::wrapper::Rule for r#PeekLeft<'i> {
        type Rule = super::Rule;
        const RULE: super::Rule = super::Rule::r#PeekLeft;
    }
    #[allow(non_camel_case_types)]
    impl<'i> r#PeekLeft<'i> {
        #[doc = "A helper function to access [`peek`]."]
        #[allow(non_snake_case)]
        pub fn r#peek<'s>(&'s self) -> &'s super::generics::PeekSlice1<1isize> {
            let res = &*self.content;
            res
        }
    }
    #[allow(unused_imports)]
    use pest3_core::typed::SubRule as _;
    ::pest3_core::typed::full_rule_struct!(
        r#PeekLeft,
        (),
        super::Rule,
        super::Rule::r#PeekLeft,
        super::generics::PeekSlice1::<1isize>,
        ::pest3_core::std::Box<super::generics::PeekSlice1::<1isize>>,
    );
    #[allow(non_camel_case_types)]
    impl<'i> ::pest3_core::typed::PairContainer<super::Rule> for r#PeekLeft<'i> {
        fn for_each_child_pair(
            &self,
            f: &mut impl ::pest3_core::std::FnMut(::pest3_core::token::Pair<super::Rule>),
        ) {
            self.content.for_self_or_for_each_child_pair(f)
        }
        fn for_self_or_for_each_child_pair(
            &self,
            f: &mut impl ::pest3_core::std::FnMut(::pest3_core::token::Pair<super::Rule>),
        ) {
            use pest3_core::typed::PairTree;
            f(self.as_pair_tree())
        }
    }
    #[allow(non_camel_case_types)]
    impl<'i> ::pest3_core::typed::PairTree<super::Rule> for r#PeekLeft<'i> {
        fn get_rule() -> super::Rule {
            #[allow(unused_imports)]
            use pest3_core::typed::SubRule as _;
            super::Rule::r#PeekLeft
        }
        fn get_span(&self) -> (::pest3_core::std::usize, ::pest3_core::std::usize) {
            (self.span.start(), self.span.end())
        }
    }
    #[doc = "Generated for rule `PeekRight`. Grammar: `pest::stack::peek[..]`."]
    #[derive(Clone, Debug, Eq, PartialEq)]
    #[allow(non_camel_case_types)]
    pub struct r#PeekRight<'i> {
        #[doc = r" Matched structure."]
        pub content: ::pest3_core::std::Box<super::generics::PeekSlice1<0isize>>,
        #[doc = r" Matched span."]
        pub span: ::pest3_core::Span<'i>,
    }
    #[allow(non_camel_case_types)]
    impl<'i> ::pest3_core::typed::wrapper::Rule for r#PeekRight<'i> {
        type Rule = super::Rule;
        const RULE: super::Rule = super::Rule::r#PeekRight;
    }
    #[allow(non_camel_case_types)]
    impl<'i> r#PeekRight<'i> {
        #[doc = "A helper function to access [`peek`]."]
        #[allow(non_snake_case)]
        pub fn r#peek<'s>(&'s self) -> &'s super::generics::PeekSlice1<0isize> {
            let res = &*self.content;
            res
        }
    }
    #[allow(unused_imports)]
    use pest3_core::typed::SubRule as _;
    ::pest3_core::typed::full_rule_struct!(
        r#PeekRight,
        (),
        super::Rule,
        super::Rule::r#PeekRight,
        super::generics::PeekSlice1::<0isize>,
        ::pest3_core::std::Box<super::generics::PeekSlice1::<0isize>>,
    );
    #[allow(non_camel_case_types)]
    impl<'i> ::pest3_core::typed::PairContainer<super::Rule> for r#PeekRight<'i> {
        fn for_each_child_pair(
            &self,
            f: &mut impl ::pest3_core::std::FnMut(::pest3_core::token::Pair<super::Rule>),
        ) {
            self.content.for_self_or_for_each_child_pair(f)
        }
        fn for_self_or_for_each_child_pair(
            &self,
            f: &mut impl ::pest3_core::std::FnMut(::pest3_core::token::Pair<super::Rule>),
        ) {
            use pest3_core::typed::PairTree;
            f(self.as_pair_tree())
        }
    }
    #[allow(non_camel_case_types)]
    impl<'i> ::pest3_core::typed::PairTree<super::Rule> for r#PeekRight<'i> {
        fn get_rule() -> super::Rule {
            #[allow(unused_imports)]
            use pest3_core::typed::SubRule as _;
            super::Rule::r#PeekRight
        }
        fn get_span(&self) -> (::pest3_core::std::usize, ::pest3_core::std::usize) {
            (self.span.start(), self.span.end())
        }
    }
    #[doc = "Generated for rule `PeekLeftRight`. Grammar: `pest::stack::peek[1..2]`."]
    #[derive(Clone, Debug, Eq, PartialEq)]
    #[allow(non_camel_case_types)]
    pub struct r#PeekLeftRight<'i> {
        #[doc = r" Matched structure."]
        pub content: ::pest3_core::std::Box<super::generics::PeekSlice2<1isize, 2isize>>,
        #[doc = r" Matched span."]
        pub span: ::pest3_core::Span<'i>,
    }
    #[allow(non_camel_case_types)]
    impl<'i> ::pest3_core::typed::wrapper::Rule for r#PeekLeftRight<'i> {
        type Rule = super::Rule;
        const RULE: super::Rule = super::Rule::r#PeekLeftRight;
    }
    #[allow(non_camel_case_types)]
    impl<'i> r#PeekLeftRight<'i> {
        #[doc = "A helper function to access [`peek`]."]
        #[allow(non_snake_case)]
        pub fn r#peek<'s>(&'s self) -> &'s super::generics::PeekSlice2<1isize, 2isize> {
            let res = &*self.content;
            res
        }
    }
    #[allow(unused_imports)]
    use pest3_core::typed::SubRule as _;
    ::pest3_core::typed::full_rule_struct!(
        r#PeekLeftRight,
        (),
        super::Rule,
        super::Rule::r#PeekLeftRight,
        super::generics::PeekSlice2::<1isize, 2isize>,
        ::pest3_core::std::Box<super::generics::PeekSlice2::<1isize, 2isize>>,
    );
    #[allow(non_camel_case_types)]
    impl<'i> ::pest3_core::typed::PairContainer<super::Rule> for r#PeekLeftRight<'i> {
        fn for_each_child_pair(
            &self,
            f: &mut impl ::pest3_core::std::FnMut(::pest3_core::token::Pair<super::Rule>),
        ) {
            self.content.for_self_or_for_each_child_pair(f)
        }
        fn for_self_or_for_each_child_pair(
            &self,
            f: &mut impl ::pest3_core::std::FnMut(::pest3_core::token::Pair<super::Rule>),
        ) {
            use pest3_core::typed::PairTree;
            f(self.as_pair_tree())
        }
    }
    #[allow(non_camel_case_types)]
    impl<'i> ::pest3_core::typed::PairTree<super::Rule> for r#PeekLeftRight<'i> {
        fn get_rule() -> super::Rule {
            #[allow(unused_imports)]
            use pest3_core::typed::SubRule as _;
            super::Rule::r#PeekLeftRight
        }
        fn get_span(&self) -> (::pest3_core::std::usize, ::pest3_core::std::usize) {
            (self.span.start(), self.span.end())
        }
    }
    #[doc = "Generated for rule `Drop`. Grammar: `pest::stack::drop`."]
    #[derive(Clone, Debug, Eq, PartialEq)]
    #[allow(non_camel_case_types)]
    pub struct r#Drop<'i> {
        #[doc = r" Matched structure."]
        pub content: ::pest3_core::std::Box<super::generics::r#drop>,
        #[doc = r" Matched span."]
        pub span: ::pest3_core::Span<'i>,
    }
    #[allow(non_camel_case_types)]
    impl<'i> ::pest3_core::typed::wrapper::Rule for r#Drop<'i> {
        type Rule = super::Rule;
        const RULE: super::Rule = super::Rule::r#Drop;
    }
    #[allow(non_camel_case_types)]
    impl<'i> r#Drop<'i> {
        #[doc = "A helper function to access [`drop`]."]
        #[allow(non_snake_case)]
        pub fn r#drop<'s>(&'s self) -> &'s super::generics::r#drop {
            let res = &*self.content;
            res
        }
    }
    #[allow(unused_imports)]
    use pest3_core::typed::SubRule as _;
    ::pest3_core::typed::full_rule_struct!(
        r#Drop,
        (),
        super::Rule,
        super::Rule::r#Drop,
        super::generics::r#drop,
        ::pest3_core::std::Box<super::generics::r#drop>,
    );
    #[allow(non_camel_case_types)]
    impl<'i> ::pest3_core::typed::PairContainer<super::Rule> for r#Drop<'i> {
        fn for_each_child_pair(
            &self,
            f: &mut impl ::pest3_core::std::FnMut(::pest3_core::token::Pair<super::Rule>),
        ) {
            self.content.for_self_or_for_each_child_pair(f)
        }
        fn for_self_or_for_each_child_pair(
            &self,
            f: &mut impl ::pest3_core::std::FnMut(::pest3_core::token::Pair<super::Rule>),
        ) {
            use pest3_core::typed::PairTree;
            f(self.as_pair_tree())
        }
    }
    #[allow(non_camel_case_types)]
    impl<'i> ::pest3_core::typed::PairTree<super::Rule> for r#Drop<'i> {
        fn get_rule() -> super::Rule {
            #[allow(unused_imports)]
            use pest3_core::typed::SubRule as _;
            super::Rule::r#Drop
        }
        fn get_span(&self) -> (::pest3_core::std::usize, ::pest3_core::std::usize) {
            (self.span.start(), self.span.end())
        }
    }
    #[doc = "Generated for rule `PeekAll`. Grammar: `pest::stack::peek_all`."]
    #[derive(Clone, Debug, Eq, PartialEq)]
    #[allow(non_camel_case_types)]
    pub struct r#PeekAll<'i> {
        #[doc = r" Matched structure."]
        pub content: ::pest3_core::std::Box<super::generics::r#peek_all<'i>>,
        #[doc = r" Matched span."]
        pub span: ::pest3_core::Span<'i>,
    }
    #[allow(non_camel_case_types)]
    impl<'i> ::pest3_core::typed::wrapper::Rule for r#PeekAll<'i> {
        type Rule = super::Rule;
        const RULE: super::Rule = super::Rule::r#PeekAll;
    }
    #[allow(non_camel_case_types)]
    impl<'i> r#PeekAll<'i> {
        #[doc = "A helper function to access [`peek_all`]."]
        #[allow(non_snake_case)]
        pub fn r#peek_all<'s>(&'s self) -> &'s super::generics::r#peek_all<'i> {
            let res = &*self.content;
            res
        }
    }
    #[allow(unused_imports)]
    use pest3_core::typed::SubRule as _;
    ::pest3_core::typed::full_rule_struct!(
        r#PeekAll,
        (),
        super::Rule,
        super::Rule::r#PeekAll,
        super::generics::r#peek_all::<'i>,
        ::pest3_core::std::Box<super::generics::r#peek_all::<'i>>,
    );
    #[allow(non_camel_case_types)]
    impl<'i> ::pest3_core::typed::PairContainer<super::Rule> for r#PeekAll<'i> {
        fn for_each_child_pair(
            &self,
            f: &mut impl ::pest3_core::std::FnMut(::pest3_core::token::Pair<super::Rule>),
        ) {
            self.content.for_self_or_for_each_child_pair(f)
        }
        fn for_self_or_for_each_child_pair(
            &self,
            f: &mut impl ::pest3_core::std::FnMut(::pest3_core::token::Pair<super::Rule>),
        ) {
            use pest3_core::typed::PairTree;
            f(self.as_pair_tree())
        }
    }
    #[allow(non_camel_case_types)]
    impl<'i> ::pest3_core::typed::PairTree<super::Rule> for r#PeekAll<'i> {
        fn get_rule() -> super::Rule {
            #[allow(unused_imports)]
            use pest3_core::typed::SubRule as _;
            super::Rule::r#PeekAll
        }
        fn get_span(&self) -> (::pest3_core::std::usize, ::pest3_core::std::usize) {
            (self.span.start(), self.span.end())
        }
    }
}
mod wrapper {
    #[doc = "A wrapper for `\" \"`."]
    #[derive(Clone, Debug, Hash, PartialEq, Eq)]
    pub struct W0;
    impl ::pest3_core::typed::wrapper::String for W0 {
        const CONTENT: &'static ::core::primitive::str = " ";
    }
    #[doc = "A wrapper for `\"+\"`."]
    #[derive(Clone, Debug, Hash, PartialEq, Eq)]
    pub struct W1;
    impl ::pest3_core::typed::wrapper::String for W1 {
        const CONTENT: &'static ::core::primitive::str = "+";
    }
    #[doc = "A wrapper for `\"(\"`."]
    #[derive(Clone, Debug, Hash, PartialEq, Eq)]
    pub struct W2;
    impl ::pest3_core::typed::wrapper::String for W2 {
        const CONTENT: &'static ::core::primitive::str = "(";
    }
    #[doc = "A wrapper for `\")\"`."]
    #[derive(Clone, Debug, Hash, PartialEq, Eq)]
    pub struct W3;
    impl ::pest3_core::typed::wrapper::String for W3 {
        const CONTENT: &'static ::core::primitive::str = ")";
    }
    #[doc = "A wrapper for `\"r#\"`."]
    #[derive(Clone, Debug, Hash, PartialEq, Eq)]
    pub struct W4;
    impl ::pest3_core::typed::wrapper::String for W4 {
        const CONTENT: &'static ::core::primitive::str = "r#";
    }
    #[doc = "A wrapper for `\"1\"`."]
    #[derive(Clone, Debug, Hash, PartialEq, Eq)]
    pub struct W5;
    impl ::pest3_core::typed::wrapper::String for W5 {
        const CONTENT: &'static ::core::primitive::str = "1";
    }
    #[doc = "A wrapper for `\".\"`."]
    #[derive(Clone, Debug, Hash, PartialEq, Eq)]
    pub struct W6;
    impl ::pest3_core::typed::wrapper::String for W6 {
        const CONTENT: &'static ::core::primitive::str = ".";
    }
    #[doc = "A wrapper for `\"a\"`."]
    #[derive(Clone, Debug, Hash, PartialEq, Eq)]
    pub struct W7;
    impl ::pest3_core::typed::wrapper::String for W7 {
        const CONTENT: &'static ::core::primitive::str = "a";
    }
    #[doc = "A wrapper for `\"b\"`."]
    #[derive(Clone, Debug, Hash, PartialEq, Eq)]
    pub struct W8;
    impl ::pest3_core::typed::wrapper::String for W8 {
        const CONTENT: &'static ::core::primitive::str = "b";
    }
    #[doc = "A wrapper for `\"c\"`."]
    #[derive(Clone, Debug, Hash, PartialEq, Eq)]
    pub struct W9;
    impl ::pest3_core::typed::wrapper::String for W9 {
        const CONTENT: &'static ::core::primitive::str = "c";
    }
    #[doc = "A wrapper for `\"?\"`."]
    #[derive(Clone, Debug, Hash, PartialEq, Eq)]
    pub struct W10;
    impl ::pest3_core::typed::wrapper::String for W10 {
        const CONTENT: &'static ::core::primitive::str = "?";
    }
}
pub use pest3_core::typed::unicode;
#[doc = "Used generics."]
pub mod generics {
    pub use pest3_core::choice::Choice9;
    pub use pest3_core::sequence::Sequence2;
    pub use pest3_core::sequence::Sequence3;
    pub use pest3_core::sequence::Sequence4;
    pub use pest3_core::sequence::Sequence7;
    pub use pest3_core::typed::template::{
        CharRange, Insens, Negative, PeekSlice1, PeekSlice2, Positive, Rep, RepMax, RepMin,
        RepMinMax, RepOnce, Str, ANY as any, ASCII as ascii, ASCII_ALPHA as ascii_alpha,
        ASCII_ALPHANUMERIC as ascii_alphanumeric, ASCII_ALPHA_LOWER as ascii_alpha_lower,
        ASCII_ALPHA_UPPER as ascii_alpha_upper, ASCII_BIN_DIGIT as ascii_bin_digit,
        ASCII_DIGIT as ascii_digit, ASCII_HEX_DIGIT as ascii_hex_digit,
        ASCII_NONZERO_DIGIT as ascii_nonzero_digit, ASCII_OCT_DIGIT as ascii_oct_digit,
        DROP as drop, EOI, EOI as eoi, NEWLINE as newline, PEEK as peek, PEEK_ALL as peek_all,
        POP as pop, POP_ALL as pop_all, PUSH as push, SOI, SOI as soi,
    };
}
