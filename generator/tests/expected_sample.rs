#[doc = "This is a grammar test written by [Tomas Tauber](https://github.com/tomtau)."]
#[allow(
    dead_code,
    missing_docs,
    non_camel_case_types,
    clippy::upper_case_acronyms
)]
#[derive(Clone, Copy, Debug, Eq, Hash, Ord, PartialEq, PartialOrd)]
pub enum Rule {
    EOI,
    r#string,
    r#insensitive,
    r#range,
    r#ident,
    r#pos_pred,
    r#neg_pred,
    r#double_neg_pred,
    r#sequence,
    r#sequence_trivia,
    r#sequence_trivia_mandatory,
    r#sequence_nested,
    r#choice,
    r#choice_trivia,
    r#choice_trivia_mandatory,
    r#choice_prefix,
    r#optional,
    r#optional_trivia,
    r#repeat,
    r#repeat_trivia,
    r#repeat_trivia_mandatory,
    r#repeat_once,
    r#repeat_once_trivia,
    r#repeat_once_trivia_mandatory,
    r#repeat_min_max,
    r#repeat_min_max_trivia,
    r#repeat_min_max_trivia_mandatory,
    r#repeat_exact,
    r#repeat_exact_trivia,
    r#repeat_exact_trivia_mandatory,
    r#repeat_min,
    r#repeat_min_trivia,
    r#repeat_min_trivia_mandatory,
    r#repeat_max,
    r#repeat_max_trivia,
    r#repeat_max_trivia_mandatory,
    r#seperated,
    r#seperated_call,
    r#soi_at_start,
    r#push,
    r#pop,
    r#pop_all,
    r#drop,
    r#peek,
    r#peek_all,
    r#peek_slice,
    r#repeat_mutate_stack,
    r#repeat_mutate_stack_pop_all,
    r#will_fail,
    r#stack_resume_after_fail,
    r#peek_,
    r#peek_all_,
    r#peek_slice_23,
    r#pop_,
    r#pop_all_,
    r#pop_fail,
    r#checkpoint_restore,
    r#ascii_digits,
    r#ascii_nonzero_digits,
    r#ascii_bin_digits,
    r#ascii_oct_digits,
    r#ascii_hex_digits,
    r#ascii_alpha_lowers,
    r#ascii_alpha_uppers,
    r#ascii_alphas,
    r#ascii_alphanumerics,
    r#asciis,
    r#newline,
    r#unicode,
    r#han,
    r#hangul,
    r#hiragana,
    r#arabic,
    r#emoji,
    r#whitespace,
    r#comment,
}
impl ::pest3_core::typed::RuleType for Rule {
    const EOI: Self = Rule::EOI;
}
#[doc = "Definitions of statically typed nodes generated by pest-generator."]
pub mod rules {
    pub type __OptionalTrivia<'i> = super::generics::Rep<
        super::generics::Choice2<r#whitespace<'i>, r#comment<'i>>,
        ::pest3_core::typed::template::Empty,
    >;
    pub type __MandatoryTrivia<'i> = super::generics::Rep<
        super::generics::Choice2<r#whitespace<'i>, r#comment<'i>>,
        ::pest3_core::typed::template::Empty,
    >;
    #[doc = "Generated for rule `string`. Grammar: `\"abc\"`."]
    #[derive(Clone, Debug, Eq, PartialEq)]
    #[allow(non_camel_case_types)]
    pub struct r#string<'i> {
        #[doc = r" Matched structure."]
        pub content: ::pest3_core::std::Box<super::generics::Str<super::wrapper::W0>>,
        #[doc = r" Matched span."]
        pub span: ::pest3_core::Span<'i>,
    }
    #[allow(non_camel_case_types)]
    impl<'i> ::pest3_core::typed::wrapper::Rule for r#string<'i> {
        type Rule = super::Rule;
        const RULE: super::Rule = super::Rule::r#string;
    }
    #[allow(non_camel_case_types)]
    impl<'i> r#string<'i> {}
    #[allow(unused_imports)]
    use pest3_core::typed::SubRule as _;
    ::pest3_core::typed::full_rule_struct!(
        r#string,
        (),
        super::Rule,
        super::Rule::r#string,
        super::generics::Str::<super::wrapper::W0>,
        ::pest3_core::std::Box<super::generics::Str::<super::wrapper::W0>>,
    );
    #[allow(non_camel_case_types)]
    impl<'i> ::pest3_core::typed::PairContainer<super::Rule> for r#string<'i> {
        fn for_each_child_pair(
            &self,
            f: &mut impl ::pest3_core::std::FnMut(::pest3_core::token::Pair<super::Rule>),
        ) {
            self.content.for_self_or_for_each_child_pair(f)
        }
        fn for_self_or_for_each_child_pair(
            &self,
            f: &mut impl ::pest3_core::std::FnMut(::pest3_core::token::Pair<super::Rule>),
        ) {
            use pest3_core::typed::PairTree;
            f(self.as_pair_tree())
        }
    }
    #[allow(non_camel_case_types)]
    impl<'i> ::pest3_core::typed::PairTree<super::Rule> for r#string<'i> {
        fn get_rule() -> super::Rule {
            #[allow(unused_imports)]
            use pest3_core::typed::SubRule as _;
            super::Rule::r#string
        }
        fn get_span(&self) -> (::pest3_core::std::usize, ::pest3_core::std::usize) {
            (self.span.start(), self.span.end())
        }
    }
    #[doc = "Generated for rule `insensitive`. Grammar: `^\"abc\"`."]
    #[derive(Clone, Debug, Eq, PartialEq)]
    #[allow(non_camel_case_types)]
    pub struct r#insensitive<'i> {
        #[doc = r" Matched structure."]
        pub content: ::pest3_core::std::Box<super::generics::Insens<'i, super::wrapper::W0>>,
        #[doc = r" Matched span."]
        pub span: ::pest3_core::Span<'i>,
    }
    #[allow(non_camel_case_types)]
    impl<'i> ::pest3_core::typed::wrapper::Rule for r#insensitive<'i> {
        type Rule = super::Rule;
        const RULE: super::Rule = super::Rule::r#insensitive;
    }
    #[allow(non_camel_case_types)]
    impl<'i> r#insensitive<'i> {}
    #[allow(unused_imports)]
    use pest3_core::typed::SubRule as _;
    ::pest3_core::typed::full_rule_struct!(
        r#insensitive,
        (),
        super::Rule,
        super::Rule::r#insensitive,
        super::generics::Insens::<'i, super::wrapper::W0>,
        ::pest3_core::std::Box<super::generics::Insens::<'i, super::wrapper::W0>>,
    );
    #[allow(non_camel_case_types)]
    impl<'i> ::pest3_core::typed::PairContainer<super::Rule> for r#insensitive<'i> {
        fn for_each_child_pair(
            &self,
            f: &mut impl ::pest3_core::std::FnMut(::pest3_core::token::Pair<super::Rule>),
        ) {
            self.content.for_self_or_for_each_child_pair(f)
        }
        fn for_self_or_for_each_child_pair(
            &self,
            f: &mut impl ::pest3_core::std::FnMut(::pest3_core::token::Pair<super::Rule>),
        ) {
            use pest3_core::typed::PairTree;
            f(self.as_pair_tree())
        }
    }
    #[allow(non_camel_case_types)]
    impl<'i> ::pest3_core::typed::PairTree<super::Rule> for r#insensitive<'i> {
        fn get_rule() -> super::Rule {
            #[allow(unused_imports)]
            use pest3_core::typed::SubRule as _;
            super::Rule::r#insensitive
        }
        fn get_span(&self) -> (::pest3_core::std::usize, ::pest3_core::std::usize) {
            (self.span.start(), self.span.end())
        }
    }
    #[doc = "Generated for rule `range`. Grammar: `'0'..'9'`."]
    #[derive(Clone, Debug, Eq, PartialEq)]
    #[allow(non_camel_case_types)]
    pub struct r#range<'i> {
        #[doc = r" Matched structure."]
        pub content: ::pest3_core::std::Box<super::generics::CharRange<'0', '9'>>,
        #[doc = r" Matched span."]
        pub span: ::pest3_core::Span<'i>,
    }
    #[allow(non_camel_case_types)]
    impl<'i> ::pest3_core::typed::wrapper::Rule for r#range<'i> {
        type Rule = super::Rule;
        const RULE: super::Rule = super::Rule::r#range;
    }
    #[allow(non_camel_case_types)]
    impl<'i> r#range<'i> {}
    #[allow(unused_imports)]
    use pest3_core::typed::SubRule as _;
    ::pest3_core::typed::full_rule_struct!(
        r#range,
        (),
        super::Rule,
        super::Rule::r#range,
        super::generics::CharRange::<'0', '9'>,
        ::pest3_core::std::Box<super::generics::CharRange::<'0', '9'>>,
    );
    #[allow(non_camel_case_types)]
    impl<'i> ::pest3_core::typed::PairContainer<super::Rule> for r#range<'i> {
        fn for_each_child_pair(
            &self,
            f: &mut impl ::pest3_core::std::FnMut(::pest3_core::token::Pair<super::Rule>),
        ) {
            self.content.for_self_or_for_each_child_pair(f)
        }
        fn for_self_or_for_each_child_pair(
            &self,
            f: &mut impl ::pest3_core::std::FnMut(::pest3_core::token::Pair<super::Rule>),
        ) {
            use pest3_core::typed::PairTree;
            f(self.as_pair_tree())
        }
    }
    #[allow(non_camel_case_types)]
    impl<'i> ::pest3_core::typed::PairTree<super::Rule> for r#range<'i> {
        fn get_rule() -> super::Rule {
            #[allow(unused_imports)]
            use pest3_core::typed::SubRule as _;
            super::Rule::r#range
        }
        fn get_span(&self) -> (::pest3_core::std::usize, ::pest3_core::std::usize) {
            (self.span.start(), self.span.end())
        }
    }
    #[doc = "Generated for rule `ident`. Grammar: `string`."]
    #[derive(Clone, Debug, Eq, PartialEq)]
    #[allow(non_camel_case_types)]
    pub struct r#ident<'i> {
        #[doc = r" Matched structure."]
        pub content: ::pest3_core::std::Box<r#string<'i>>,
        #[doc = r" Matched span."]
        pub span: ::pest3_core::Span<'i>,
    }
    #[allow(non_camel_case_types)]
    impl<'i> ::pest3_core::typed::wrapper::Rule for r#ident<'i> {
        type Rule = super::Rule;
        const RULE: super::Rule = super::Rule::r#ident;
    }
    #[allow(non_camel_case_types)]
    impl<'i> r#ident<'i> {
        #[doc = "A helper function to access [`string`]."]
        #[allow(non_snake_case)]
        pub fn r#string<'s>(&'s self) -> &'s r#string<'i> {
            let res = &*self.content;
            res
        }
    }
    #[allow(unused_imports)]
    use pest3_core::typed::SubRule as _;
    ::pest3_core::typed::full_rule_struct!(
        r#ident,
        (),
        super::Rule,
        super::Rule::r#ident,
        r#string::<'i>,
        ::pest3_core::std::Box<r#string::<'i>>,
    );
    #[allow(non_camel_case_types)]
    impl<'i> ::pest3_core::typed::PairContainer<super::Rule> for r#ident<'i> {
        fn for_each_child_pair(
            &self,
            f: &mut impl ::pest3_core::std::FnMut(::pest3_core::token::Pair<super::Rule>),
        ) {
            self.content.for_self_or_for_each_child_pair(f)
        }
        fn for_self_or_for_each_child_pair(
            &self,
            f: &mut impl ::pest3_core::std::FnMut(::pest3_core::token::Pair<super::Rule>),
        ) {
            use pest3_core::typed::PairTree;
            f(self.as_pair_tree())
        }
    }
    #[allow(non_camel_case_types)]
    impl<'i> ::pest3_core::typed::PairTree<super::Rule> for r#ident<'i> {
        fn get_rule() -> super::Rule {
            #[allow(unused_imports)]
            use pest3_core::typed::SubRule as _;
            super::Rule::r#ident
        }
        fn get_span(&self) -> (::pest3_core::std::usize, ::pest3_core::std::usize) {
            (self.span.start(), self.span.end())
        }
    }
    #[doc = "Generated for rule `pos_pred`. Grammar: `&string`."]
    #[derive(Clone, Debug, Eq, PartialEq)]
    #[allow(non_camel_case_types)]
    pub struct r#pos_pred<'i> {
        #[doc = r" Matched structure."]
        pub content: ::pest3_core::std::Box<super::generics::Positive<r#string<'i>>>,
        #[doc = r" Matched span."]
        pub span: ::pest3_core::Span<'i>,
    }
    #[allow(non_camel_case_types)]
    impl<'i> ::pest3_core::typed::wrapper::Rule for r#pos_pred<'i> {
        type Rule = super::Rule;
        const RULE: super::Rule = super::Rule::r#pos_pred;
    }
    #[allow(non_camel_case_types)]
    impl<'i> r#pos_pred<'i> {
        #[doc = "A helper function to access [`string`]."]
        #[allow(non_snake_case)]
        pub fn r#string<'s>(&'s self) -> &'s r#string<'i> {
            let res = &*self.content;
            res
        }
    }
    #[allow(unused_imports)]
    use pest3_core::typed::SubRule as _;
    ::pest3_core::typed::full_rule_struct!(
        r#pos_pred,
        (),
        super::Rule,
        super::Rule::r#pos_pred,
        super::generics::Positive::<r#string::<'i>>,
        ::pest3_core::std::Box<super::generics::Positive::<r#string::<'i>>>,
    );
    #[allow(non_camel_case_types)]
    impl<'i> ::pest3_core::typed::PairContainer<super::Rule> for r#pos_pred<'i> {
        fn for_each_child_pair(
            &self,
            f: &mut impl ::pest3_core::std::FnMut(::pest3_core::token::Pair<super::Rule>),
        ) {
            self.content.for_self_or_for_each_child_pair(f)
        }
        fn for_self_or_for_each_child_pair(
            &self,
            f: &mut impl ::pest3_core::std::FnMut(::pest3_core::token::Pair<super::Rule>),
        ) {
            use pest3_core::typed::PairTree;
            f(self.as_pair_tree())
        }
    }
    #[allow(non_camel_case_types)]
    impl<'i> ::pest3_core::typed::PairTree<super::Rule> for r#pos_pred<'i> {
        fn get_rule() -> super::Rule {
            #[allow(unused_imports)]
            use pest3_core::typed::SubRule as _;
            super::Rule::r#pos_pred
        }
        fn get_span(&self) -> (::pest3_core::std::usize, ::pest3_core::std::usize) {
            (self.span.start(), self.span.end())
        }
    }
    #[doc = "Generated for rule `neg_pred`. Grammar: `!string`."]
    #[derive(Clone, Debug, Eq, PartialEq)]
    #[allow(non_camel_case_types)]
    pub struct r#neg_pred<'i> {
        #[doc = r" Matched structure."]
        pub content: ::pest3_core::std::Box<super::generics::Negative<r#string<'i>>>,
        #[doc = r" Matched span."]
        pub span: ::pest3_core::Span<'i>,
    }
    #[allow(non_camel_case_types)]
    impl<'i> ::pest3_core::typed::wrapper::Rule for r#neg_pred<'i> {
        type Rule = super::Rule;
        const RULE: super::Rule = super::Rule::r#neg_pred;
    }
    #[allow(non_camel_case_types)]
    impl<'i> r#neg_pred<'i> {}
    #[allow(unused_imports)]
    use pest3_core::typed::SubRule as _;
    ::pest3_core::typed::full_rule_struct!(
        r#neg_pred,
        (),
        super::Rule,
        super::Rule::r#neg_pred,
        super::generics::Negative::<r#string::<'i>>,
        ::pest3_core::std::Box<super::generics::Negative::<r#string::<'i>>>,
    );
    #[allow(non_camel_case_types)]
    impl<'i> ::pest3_core::typed::PairContainer<super::Rule> for r#neg_pred<'i> {
        fn for_each_child_pair(
            &self,
            f: &mut impl ::pest3_core::std::FnMut(::pest3_core::token::Pair<super::Rule>),
        ) {
            self.content.for_self_or_for_each_child_pair(f)
        }
        fn for_self_or_for_each_child_pair(
            &self,
            f: &mut impl ::pest3_core::std::FnMut(::pest3_core::token::Pair<super::Rule>),
        ) {
            use pest3_core::typed::PairTree;
            f(self.as_pair_tree())
        }
    }
    #[allow(non_camel_case_types)]
    impl<'i> ::pest3_core::typed::PairTree<super::Rule> for r#neg_pred<'i> {
        fn get_rule() -> super::Rule {
            #[allow(unused_imports)]
            use pest3_core::typed::SubRule as _;
            super::Rule::r#neg_pred
        }
        fn get_span(&self) -> (::pest3_core::std::usize, ::pest3_core::std::usize) {
            (self.span.start(), self.span.end())
        }
    }
    #[doc = "Generated for rule `double_neg_pred`. Grammar: `!!string`."]
    #[derive(Clone, Debug, Eq, PartialEq)]
    #[allow(non_camel_case_types)]
    pub struct r#double_neg_pred<'i> {
        #[doc = r" Matched structure."]
        pub content: ::pest3_core::std::Box<
            super::generics::Negative<super::generics::Negative<r#string<'i>>>,
        >,
        #[doc = r" Matched span."]
        pub span: ::pest3_core::Span<'i>,
    }
    #[allow(non_camel_case_types)]
    impl<'i> ::pest3_core::typed::wrapper::Rule for r#double_neg_pred<'i> {
        type Rule = super::Rule;
        const RULE: super::Rule = super::Rule::r#double_neg_pred;
    }
    #[allow(non_camel_case_types)]
    impl<'i> r#double_neg_pred<'i> {}
    #[allow(unused_imports)]
    use pest3_core::typed::SubRule as _;
    ::pest3_core::typed::full_rule_struct!(
        r#double_neg_pred,
        (),
        super::Rule,
        super::Rule::r#double_neg_pred,
        super::generics::Negative::<super::generics::Negative::<r#string::<'i>>>,
        ::pest3_core::std::Box<
            super::generics::Negative::<super::generics::Negative::<r#string::<'i>>>,
        >,
    );
    #[allow(non_camel_case_types)]
    impl<'i> ::pest3_core::typed::PairContainer<super::Rule> for r#double_neg_pred<'i> {
        fn for_each_child_pair(
            &self,
            f: &mut impl ::pest3_core::std::FnMut(::pest3_core::token::Pair<super::Rule>),
        ) {
            self.content.for_self_or_for_each_child_pair(f)
        }
        fn for_self_or_for_each_child_pair(
            &self,
            f: &mut impl ::pest3_core::std::FnMut(::pest3_core::token::Pair<super::Rule>),
        ) {
            use pest3_core::typed::PairTree;
            f(self.as_pair_tree())
        }
    }
    #[allow(non_camel_case_types)]
    impl<'i> ::pest3_core::typed::PairTree<super::Rule> for r#double_neg_pred<'i> {
        fn get_rule() -> super::Rule {
            #[allow(unused_imports)]
            use pest3_core::typed::SubRule as _;
            super::Rule::r#double_neg_pred
        }
        fn get_span(&self) -> (::pest3_core::std::usize, ::pest3_core::std::usize) {
            (self.span.start(), self.span.end())
        }
    }
    #[doc = "Generated for rule `sequence`. Grammar: `(string - string)`."]
    #[derive(Clone, Debug, Eq, PartialEq)]
    #[allow(non_camel_case_types)]
    pub struct r#sequence<'i> {
        #[doc = r" Matched structure."]
        pub content: ::pest3_core::std::Box<
            super::generics::Sequence2<
                r#string<'i>,
                ::pest3_core::typed::template::Empty,
                r#string<'i>,
                ::pest3_core::typed::template::Empty,
            >,
        >,
        #[doc = r" Matched span."]
        pub span: ::pest3_core::Span<'i>,
    }
    #[allow(non_camel_case_types)]
    impl<'i> ::pest3_core::typed::wrapper::Rule for r#sequence<'i> {
        type Rule = super::Rule;
        const RULE: super::Rule = super::Rule::r#sequence;
    }
    #[allow(non_camel_case_types)]
    impl<'i> r#sequence<'i> {
        #[doc = "A helper function to access [`string`]."]
        #[allow(non_snake_case)]
        pub fn r#string<'s>(&'s self) -> (&'s r#string<'i>, &'s r#string<'i>) {
            let res = &*self.content;
            {
                let res = (
                    {
                        let res = &res.field_0;
                        res
                    },
                    {
                        let res = &res.field_1;
                        res
                    },
                );
                res
            }
        }
    }
    #[allow(unused_imports)]
    use pest3_core::typed::SubRule as _;
    ::pest3_core::typed::full_rule_struct!(
        r#sequence,
        (),
        super::Rule,
        super::Rule::r#sequence,
        super::generics::Sequence2::<
            r#string::<'i>,
            ::pest3_core::typed::template::Empty,
            r#string::<'i>,
            ::pest3_core::typed::template::Empty,
        >,
        ::pest3_core::std::Box<
            super::generics::Sequence2::<
                r#string::<'i>,
                ::pest3_core::typed::template::Empty,
                r#string::<'i>,
                ::pest3_core::typed::template::Empty,
            >,
        >,
    );
    #[allow(non_camel_case_types)]
    impl<'i> ::pest3_core::typed::PairContainer<super::Rule> for r#sequence<'i> {
        fn for_each_child_pair(
            &self,
            f: &mut impl ::pest3_core::std::FnMut(::pest3_core::token::Pair<super::Rule>),
        ) {
            self.content.for_self_or_for_each_child_pair(f)
        }
        fn for_self_or_for_each_child_pair(
            &self,
            f: &mut impl ::pest3_core::std::FnMut(::pest3_core::token::Pair<super::Rule>),
        ) {
            use pest3_core::typed::PairTree;
            f(self.as_pair_tree())
        }
    }
    #[allow(non_camel_case_types)]
    impl<'i> ::pest3_core::typed::PairTree<super::Rule> for r#sequence<'i> {
        fn get_rule() -> super::Rule {
            #[allow(unused_imports)]
            use pest3_core::typed::SubRule as _;
            super::Rule::r#sequence
        }
        fn get_span(&self) -> (::pest3_core::std::usize, ::pest3_core::std::usize) {
            (self.span.start(), self.span.end())
        }
    }
    #[doc = "Generated for rule `sequence_trivia`. Grammar: `(string ~ string)`."]
    #[derive(Clone, Debug, Eq, PartialEq)]
    #[allow(non_camel_case_types)]
    pub struct r#sequence_trivia<'i> {
        #[doc = r" Matched structure."]
        pub content: ::pest3_core::std::Box<
            super::generics::Sequence2<
                r#string<'i>,
                ::pest3_core::typed::template::Empty,
                r#string<'i>,
                __OptionalTrivia<'i>,
            >,
        >,
        #[doc = r" Matched span."]
        pub span: ::pest3_core::Span<'i>,
    }
    #[allow(non_camel_case_types)]
    impl<'i> ::pest3_core::typed::wrapper::Rule for r#sequence_trivia<'i> {
        type Rule = super::Rule;
        const RULE: super::Rule = super::Rule::r#sequence_trivia;
    }
    #[allow(non_camel_case_types)]
    impl<'i> r#sequence_trivia<'i> {
        #[doc = "A helper function to access [`string`]."]
        #[allow(non_snake_case)]
        pub fn r#string<'s>(&'s self) -> (&'s r#string<'i>, &'s r#string<'i>) {
            let res = &*self.content;
            {
                let res = (
                    {
                        let res = &res.field_0;
                        res
                    },
                    {
                        let res = &res.field_1;
                        res
                    },
                );
                res
            }
        }
    }
    #[allow(unused_imports)]
    use pest3_core::typed::SubRule as _;
    ::pest3_core::typed::full_rule_struct!(
        r#sequence_trivia,
        (),
        super::Rule,
        super::Rule::r#sequence_trivia,
        super::generics::Sequence2::<
            r#string::<'i>,
            ::pest3_core::typed::template::Empty,
            r#string::<'i>,
            __OptionalTrivia::<'i>,
        >,
        ::pest3_core::std::Box<
            super::generics::Sequence2::<
                r#string::<'i>,
                ::pest3_core::typed::template::Empty,
                r#string::<'i>,
                __OptionalTrivia::<'i>,
            >,
        >,
    );
    #[allow(non_camel_case_types)]
    impl<'i> ::pest3_core::typed::PairContainer<super::Rule> for r#sequence_trivia<'i> {
        fn for_each_child_pair(
            &self,
            f: &mut impl ::pest3_core::std::FnMut(::pest3_core::token::Pair<super::Rule>),
        ) {
            self.content.for_self_or_for_each_child_pair(f)
        }
        fn for_self_or_for_each_child_pair(
            &self,
            f: &mut impl ::pest3_core::std::FnMut(::pest3_core::token::Pair<super::Rule>),
        ) {
            use pest3_core::typed::PairTree;
            f(self.as_pair_tree())
        }
    }
    #[allow(non_camel_case_types)]
    impl<'i> ::pest3_core::typed::PairTree<super::Rule> for r#sequence_trivia<'i> {
        fn get_rule() -> super::Rule {
            #[allow(unused_imports)]
            use pest3_core::typed::SubRule as _;
            super::Rule::r#sequence_trivia
        }
        fn get_span(&self) -> (::pest3_core::std::usize, ::pest3_core::std::usize) {
            (self.span.start(), self.span.end())
        }
    }
    #[doc = "Generated for rule `sequence_trivia_mandatory`. Grammar: `(string ^ string)`."]
    #[derive(Clone, Debug, Eq, PartialEq)]
    #[allow(non_camel_case_types)]
    pub struct r#sequence_trivia_mandatory<'i> {
        #[doc = r" Matched structure."]
        pub content: ::pest3_core::std::Box<
            super::generics::Sequence2<
                r#string<'i>,
                ::pest3_core::typed::template::Empty,
                r#string<'i>,
                __MandatoryTrivia<'i>,
            >,
        >,
        #[doc = r" Matched span."]
        pub span: ::pest3_core::Span<'i>,
    }
    #[allow(non_camel_case_types)]
    impl<'i> ::pest3_core::typed::wrapper::Rule for r#sequence_trivia_mandatory<'i> {
        type Rule = super::Rule;
        const RULE: super::Rule = super::Rule::r#sequence_trivia_mandatory;
    }
    #[allow(non_camel_case_types)]
    impl<'i> r#sequence_trivia_mandatory<'i> {
        #[doc = "A helper function to access [`string`]."]
        #[allow(non_snake_case)]
        pub fn r#string<'s>(&'s self) -> (&'s r#string<'i>, &'s r#string<'i>) {
            let res = &*self.content;
            {
                let res = (
                    {
                        let res = &res.field_0;
                        res
                    },
                    {
                        let res = &res.field_1;
                        res
                    },
                );
                res
            }
        }
    }
    #[allow(unused_imports)]
    use pest3_core::typed::SubRule as _;
    ::pest3_core::typed::full_rule_struct!(
        r#sequence_trivia_mandatory,
        (),
        super::Rule,
        super::Rule::r#sequence_trivia_mandatory,
        super::generics::Sequence2::<
            r#string::<'i>,
            ::pest3_core::typed::template::Empty,
            r#string::<'i>,
            __MandatoryTrivia::<'i>,
        >,
        ::pest3_core::std::Box<
            super::generics::Sequence2::<
                r#string::<'i>,
                ::pest3_core::typed::template::Empty,
                r#string::<'i>,
                __MandatoryTrivia::<'i>,
            >,
        >,
    );
    #[allow(non_camel_case_types)]
    impl<'i> ::pest3_core::typed::PairContainer<super::Rule> for r#sequence_trivia_mandatory<'i> {
        fn for_each_child_pair(
            &self,
            f: &mut impl ::pest3_core::std::FnMut(::pest3_core::token::Pair<super::Rule>),
        ) {
            self.content.for_self_or_for_each_child_pair(f)
        }
        fn for_self_or_for_each_child_pair(
            &self,
            f: &mut impl ::pest3_core::std::FnMut(::pest3_core::token::Pair<super::Rule>),
        ) {
            use pest3_core::typed::PairTree;
            f(self.as_pair_tree())
        }
    }
    #[allow(non_camel_case_types)]
    impl<'i> ::pest3_core::typed::PairTree<super::Rule> for r#sequence_trivia_mandatory<'i> {
        fn get_rule() -> super::Rule {
            #[allow(unused_imports)]
            use pest3_core::typed::SubRule as _;
            super::Rule::r#sequence_trivia_mandatory
        }
        fn get_span(&self) -> (::pest3_core::std::usize, ::pest3_core::std::usize) {
            (self.span.start(), self.span.end())
        }
    }
    #[doc = "Generated for rule `sequence_nested`. Grammar: `!(string ~ string)`."]
    #[derive(Clone, Debug, Eq, PartialEq)]
    #[allow(non_camel_case_types)]
    pub struct r#sequence_nested<'i> {
        #[doc = r" Matched structure."]
        pub content: ::pest3_core::std::Box<
            super::generics::Negative<
                super::generics::Sequence2<
                    r#string<'i>,
                    ::pest3_core::typed::template::Empty,
                    r#string<'i>,
                    __OptionalTrivia<'i>,
                >,
            >,
        >,
        #[doc = r" Matched span."]
        pub span: ::pest3_core::Span<'i>,
    }
    #[allow(non_camel_case_types)]
    impl<'i> ::pest3_core::typed::wrapper::Rule for r#sequence_nested<'i> {
        type Rule = super::Rule;
        const RULE: super::Rule = super::Rule::r#sequence_nested;
    }
    #[allow(non_camel_case_types)]
    impl<'i> r#sequence_nested<'i> {}
    #[allow(unused_imports)]
    use pest3_core::typed::SubRule as _;
    ::pest3_core::typed::full_rule_struct!(
        r#sequence_nested,
        (),
        super::Rule,
        super::Rule::r#sequence_nested,
        super::generics::Negative::<
            super::generics::Sequence2::<
                r#string::<'i>,
                ::pest3_core::typed::template::Empty,
                r#string::<'i>,
                __OptionalTrivia::<'i>,
            >,
        >,
        ::pest3_core::std::Box<
            super::generics::Negative::<
                super::generics::Sequence2::<
                    r#string::<'i>,
                    ::pest3_core::typed::template::Empty,
                    r#string::<'i>,
                    __OptionalTrivia::<'i>,
                >,
            >,
        >,
    );
    #[allow(non_camel_case_types)]
    impl<'i> ::pest3_core::typed::PairContainer<super::Rule> for r#sequence_nested<'i> {
        fn for_each_child_pair(
            &self,
            f: &mut impl ::pest3_core::std::FnMut(::pest3_core::token::Pair<super::Rule>),
        ) {
            self.content.for_self_or_for_each_child_pair(f)
        }
        fn for_self_or_for_each_child_pair(
            &self,
            f: &mut impl ::pest3_core::std::FnMut(::pest3_core::token::Pair<super::Rule>),
        ) {
            use pest3_core::typed::PairTree;
            f(self.as_pair_tree())
        }
    }
    #[allow(non_camel_case_types)]
    impl<'i> ::pest3_core::typed::PairTree<super::Rule> for r#sequence_nested<'i> {
        fn get_rule() -> super::Rule {
            #[allow(unused_imports)]
            use pest3_core::typed::SubRule as _;
            super::Rule::r#sequence_nested
        }
        fn get_span(&self) -> (::pest3_core::std::usize, ::pest3_core::std::usize) {
            (self.span.start(), self.span.end())
        }
    }
    #[doc = "Generated for rule `choice`. Grammar: `(string | range)`."]
    #[derive(Clone, Debug, Eq, PartialEq)]
    #[allow(non_camel_case_types)]
    pub struct r#choice<'i> {
        #[doc = r" Matched structure."]
        pub content: ::pest3_core::std::Box<super::generics::Choice2<r#string<'i>, r#range<'i>>>,
        #[doc = r" Matched span."]
        pub span: ::pest3_core::Span<'i>,
    }
    #[allow(non_camel_case_types)]
    impl<'i> ::pest3_core::typed::wrapper::Rule for r#choice<'i> {
        type Rule = super::Rule;
        const RULE: super::Rule = super::Rule::r#choice;
    }
    #[allow(non_camel_case_types)]
    impl<'i> r#choice<'i> {
        #[doc = "A helper function to access [`range`]."]
        #[allow(non_snake_case)]
        pub fn r#range<'s>(&'s self) -> ::pest3_core::std::Option<&'s r#range<'i>> {
            let res = &*self.content;
            {
                let res = res.choice_1().map(|res| res);
                res
            }
        }
        #[doc = "A helper function to access [`string`]."]
        #[allow(non_snake_case)]
        pub fn r#string<'s>(&'s self) -> ::pest3_core::std::Option<&'s r#string<'i>> {
            let res = &*self.content;
            {
                let res = res.choice_0().map(|res| res);
                res
            }
        }
    }
    #[allow(unused_imports)]
    use pest3_core::typed::SubRule as _;
    ::pest3_core::typed::full_rule_struct!(
        r#choice,
        (),
        super::Rule,
        super::Rule::r#choice,
        super::generics::Choice2::<r#string::<'i>, r#range::<'i>>,
        ::pest3_core::std::Box<super::generics::Choice2::<r#string::<'i>, r#range::<'i>>>,
    );
    #[allow(non_camel_case_types)]
    impl<'i> ::pest3_core::typed::PairContainer<super::Rule> for r#choice<'i> {
        fn for_each_child_pair(
            &self,
            f: &mut impl ::pest3_core::std::FnMut(::pest3_core::token::Pair<super::Rule>),
        ) {
            self.content.for_self_or_for_each_child_pair(f)
        }
        fn for_self_or_for_each_child_pair(
            &self,
            f: &mut impl ::pest3_core::std::FnMut(::pest3_core::token::Pair<super::Rule>),
        ) {
            use pest3_core::typed::PairTree;
            f(self.as_pair_tree())
        }
    }
    #[allow(non_camel_case_types)]
    impl<'i> ::pest3_core::typed::PairTree<super::Rule> for r#choice<'i> {
        fn get_rule() -> super::Rule {
            #[allow(unused_imports)]
            use pest3_core::typed::SubRule as _;
            super::Rule::r#choice
        }
        fn get_span(&self) -> (::pest3_core::std::usize, ::pest3_core::std::usize) {
            (self.span.start(), self.span.end())
        }
    }
    #[doc = "Generated for rule `choice_trivia`. Grammar: `(string | range)`."]
    #[derive(Clone, Debug, Eq, PartialEq)]
    #[allow(non_camel_case_types)]
    pub struct r#choice_trivia<'i> {
        #[doc = r" Matched structure."]
        pub content: ::pest3_core::std::Box<super::generics::Choice2<r#string<'i>, r#range<'i>>>,
        #[doc = r" Matched span."]
        pub span: ::pest3_core::Span<'i>,
    }
    #[allow(non_camel_case_types)]
    impl<'i> ::pest3_core::typed::wrapper::Rule for r#choice_trivia<'i> {
        type Rule = super::Rule;
        const RULE: super::Rule = super::Rule::r#choice_trivia;
    }
    #[allow(non_camel_case_types)]
    impl<'i> r#choice_trivia<'i> {
        #[doc = "A helper function to access [`range`]."]
        #[allow(non_snake_case)]
        pub fn r#range<'s>(&'s self) -> ::pest3_core::std::Option<&'s r#range<'i>> {
            let res = &*self.content;
            {
                let res = res.choice_1().map(|res| res);
                res
            }
        }
        #[doc = "A helper function to access [`string`]."]
        #[allow(non_snake_case)]
        pub fn r#string<'s>(&'s self) -> ::pest3_core::std::Option<&'s r#string<'i>> {
            let res = &*self.content;
            {
                let res = res.choice_0().map(|res| res);
                res
            }
        }
    }
    #[allow(unused_imports)]
    use pest3_core::typed::SubRule as _;
    ::pest3_core::typed::full_rule_struct!(
        r#choice_trivia,
        (),
        super::Rule,
        super::Rule::r#choice_trivia,
        super::generics::Choice2::<r#string::<'i>, r#range::<'i>>,
        ::pest3_core::std::Box<super::generics::Choice2::<r#string::<'i>, r#range::<'i>>>,
    );
    #[allow(non_camel_case_types)]
    impl<'i> ::pest3_core::typed::PairContainer<super::Rule> for r#choice_trivia<'i> {
        fn for_each_child_pair(
            &self,
            f: &mut impl ::pest3_core::std::FnMut(::pest3_core::token::Pair<super::Rule>),
        ) {
            self.content.for_self_or_for_each_child_pair(f)
        }
        fn for_self_or_for_each_child_pair(
            &self,
            f: &mut impl ::pest3_core::std::FnMut(::pest3_core::token::Pair<super::Rule>),
        ) {
            use pest3_core::typed::PairTree;
            f(self.as_pair_tree())
        }
    }
    #[allow(non_camel_case_types)]
    impl<'i> ::pest3_core::typed::PairTree<super::Rule> for r#choice_trivia<'i> {
        fn get_rule() -> super::Rule {
            #[allow(unused_imports)]
            use pest3_core::typed::SubRule as _;
            super::Rule::r#choice_trivia
        }
        fn get_span(&self) -> (::pest3_core::std::usize, ::pest3_core::std::usize) {
            (self.span.start(), self.span.end())
        }
    }
    #[doc = "Generated for rule `choice_trivia_mandatory`. Grammar: `(string | range)`."]
    #[derive(Clone, Debug, Eq, PartialEq)]
    #[allow(non_camel_case_types)]
    pub struct r#choice_trivia_mandatory<'i> {
        #[doc = r" Matched structure."]
        pub content: ::pest3_core::std::Box<super::generics::Choice2<r#string<'i>, r#range<'i>>>,
        #[doc = r" Matched span."]
        pub span: ::pest3_core::Span<'i>,
    }
    #[allow(non_camel_case_types)]
    impl<'i> ::pest3_core::typed::wrapper::Rule for r#choice_trivia_mandatory<'i> {
        type Rule = super::Rule;
        const RULE: super::Rule = super::Rule::r#choice_trivia_mandatory;
    }
    #[allow(non_camel_case_types)]
    impl<'i> r#choice_trivia_mandatory<'i> {
        #[doc = "A helper function to access [`range`]."]
        #[allow(non_snake_case)]
        pub fn r#range<'s>(&'s self) -> ::pest3_core::std::Option<&'s r#range<'i>> {
            let res = &*self.content;
            {
                let res = res.choice_1().map(|res| res);
                res
            }
        }
        #[doc = "A helper function to access [`string`]."]
        #[allow(non_snake_case)]
        pub fn r#string<'s>(&'s self) -> ::pest3_core::std::Option<&'s r#string<'i>> {
            let res = &*self.content;
            {
                let res = res.choice_0().map(|res| res);
                res
            }
        }
    }
    #[allow(unused_imports)]
    use pest3_core::typed::SubRule as _;
    ::pest3_core::typed::full_rule_struct!(
        r#choice_trivia_mandatory,
        (),
        super::Rule,
        super::Rule::r#choice_trivia_mandatory,
        super::generics::Choice2::<r#string::<'i>, r#range::<'i>>,
        ::pest3_core::std::Box<super::generics::Choice2::<r#string::<'i>, r#range::<'i>>>,
    );
    #[allow(non_camel_case_types)]
    impl<'i> ::pest3_core::typed::PairContainer<super::Rule> for r#choice_trivia_mandatory<'i> {
        fn for_each_child_pair(
            &self,
            f: &mut impl ::pest3_core::std::FnMut(::pest3_core::token::Pair<super::Rule>),
        ) {
            self.content.for_self_or_for_each_child_pair(f)
        }
        fn for_self_or_for_each_child_pair(
            &self,
            f: &mut impl ::pest3_core::std::FnMut(::pest3_core::token::Pair<super::Rule>),
        ) {
            use pest3_core::typed::PairTree;
            f(self.as_pair_tree())
        }
    }
    #[allow(non_camel_case_types)]
    impl<'i> ::pest3_core::typed::PairTree<super::Rule> for r#choice_trivia_mandatory<'i> {
        fn get_rule() -> super::Rule {
            #[allow(unused_imports)]
            use pest3_core::typed::SubRule as _;
            super::Rule::r#choice_trivia_mandatory
        }
        fn get_span(&self) -> (::pest3_core::std::usize, ::pest3_core::std::usize) {
            (self.span.start(), self.span.end())
        }
    }
    #[doc = "Generated for rule `choice_prefix`. Grammar: `(string | range)`."]
    #[derive(Clone, Debug, Eq, PartialEq)]
    #[allow(non_camel_case_types)]
    pub struct r#choice_prefix<'i> {
        #[doc = r" Matched structure."]
        pub content: ::pest3_core::std::Box<super::generics::Choice2<r#string<'i>, r#range<'i>>>,
        #[doc = r" Matched span."]
        pub span: ::pest3_core::Span<'i>,
    }
    #[allow(non_camel_case_types)]
    impl<'i> ::pest3_core::typed::wrapper::Rule for r#choice_prefix<'i> {
        type Rule = super::Rule;
        const RULE: super::Rule = super::Rule::r#choice_prefix;
    }
    #[allow(non_camel_case_types)]
    impl<'i> r#choice_prefix<'i> {
        #[doc = "A helper function to access [`range`]."]
        #[allow(non_snake_case)]
        pub fn r#range<'s>(&'s self) -> ::pest3_core::std::Option<&'s r#range<'i>> {
            let res = &*self.content;
            {
                let res = res.choice_1().map(|res| res);
                res
            }
        }
        #[doc = "A helper function to access [`string`]."]
        #[allow(non_snake_case)]
        pub fn r#string<'s>(&'s self) -> ::pest3_core::std::Option<&'s r#string<'i>> {
            let res = &*self.content;
            {
                let res = res.choice_0().map(|res| res);
                res
            }
        }
    }
    #[allow(unused_imports)]
    use pest3_core::typed::SubRule as _;
    ::pest3_core::typed::full_rule_struct!(
        r#choice_prefix,
        (),
        super::Rule,
        super::Rule::r#choice_prefix,
        super::generics::Choice2::<r#string::<'i>, r#range::<'i>>,
        ::pest3_core::std::Box<super::generics::Choice2::<r#string::<'i>, r#range::<'i>>>,
    );
    #[allow(non_camel_case_types)]
    impl<'i> ::pest3_core::typed::PairContainer<super::Rule> for r#choice_prefix<'i> {
        fn for_each_child_pair(
            &self,
            f: &mut impl ::pest3_core::std::FnMut(::pest3_core::token::Pair<super::Rule>),
        ) {
            self.content.for_self_or_for_each_child_pair(f)
        }
        fn for_self_or_for_each_child_pair(
            &self,
            f: &mut impl ::pest3_core::std::FnMut(::pest3_core::token::Pair<super::Rule>),
        ) {
            use pest3_core::typed::PairTree;
            f(self.as_pair_tree())
        }
    }
    #[allow(non_camel_case_types)]
    impl<'i> ::pest3_core::typed::PairTree<super::Rule> for r#choice_prefix<'i> {
        fn get_rule() -> super::Rule {
            #[allow(unused_imports)]
            use pest3_core::typed::SubRule as _;
            super::Rule::r#choice_prefix
        }
        fn get_span(&self) -> (::pest3_core::std::usize, ::pest3_core::std::usize) {
            (self.span.start(), self.span.end())
        }
    }
    #[doc = "Generated for rule `optional`. Grammar: `string?`."]
    #[derive(Clone, Debug, Eq, PartialEq)]
    #[allow(non_camel_case_types)]
    pub struct r#optional<'i> {
        #[doc = r" Matched structure."]
        pub content: ::pest3_core::std::Box<::pest3_core::std::Option<r#string<'i>>>,
        #[doc = r" Matched span."]
        pub span: ::pest3_core::Span<'i>,
    }
    #[allow(non_camel_case_types)]
    impl<'i> ::pest3_core::typed::wrapper::Rule for r#optional<'i> {
        type Rule = super::Rule;
        const RULE: super::Rule = super::Rule::r#optional;
    }
    #[allow(non_camel_case_types)]
    impl<'i> r#optional<'i> {
        #[doc = "A helper function to access [`string`]."]
        #[allow(non_snake_case)]
        pub fn r#string<'s>(&'s self) -> ::pest3_core::std::Option<&'s r#string<'i>> {
            let res = &*self.content;
            {
                let res = res.as_ref().map(|res| res);
                res
            }
        }
    }
    #[allow(unused_imports)]
    use pest3_core::typed::SubRule as _;
    ::pest3_core::typed::full_rule_struct!(
        r#optional,
        (),
        super::Rule,
        super::Rule::r#optional,
        ::pest3_core::std::Option::<r#string::<'i>>,
        ::pest3_core::std::Box<::pest3_core::std::Option::<r#string::<'i>>>,
    );
    #[allow(non_camel_case_types)]
    impl<'i> ::pest3_core::typed::PairContainer<super::Rule> for r#optional<'i> {
        fn for_each_child_pair(
            &self,
            f: &mut impl ::pest3_core::std::FnMut(::pest3_core::token::Pair<super::Rule>),
        ) {
            self.content.for_self_or_for_each_child_pair(f)
        }
        fn for_self_or_for_each_child_pair(
            &self,
            f: &mut impl ::pest3_core::std::FnMut(::pest3_core::token::Pair<super::Rule>),
        ) {
            use pest3_core::typed::PairTree;
            f(self.as_pair_tree())
        }
    }
    #[allow(non_camel_case_types)]
    impl<'i> ::pest3_core::typed::PairTree<super::Rule> for r#optional<'i> {
        fn get_rule() -> super::Rule {
            #[allow(unused_imports)]
            use pest3_core::typed::SubRule as _;
            super::Rule::r#optional
        }
        fn get_span(&self) -> (::pest3_core::std::usize, ::pest3_core::std::usize) {
            (self.span.start(), self.span.end())
        }
    }
    #[doc = "Generated for rule `optional_trivia`. Grammar: `string~?`."]
    #[derive(Clone, Debug, Eq, PartialEq)]
    #[allow(non_camel_case_types)]
    pub struct r#optional_trivia<'i> {
        #[doc = r" Matched structure."]
        pub content: ::pest3_core::std::Box<::pest3_core::std::Option<r#string<'i>>>,
        #[doc = r" Matched span."]
        pub span: ::pest3_core::Span<'i>,
    }
    #[allow(non_camel_case_types)]
    impl<'i> ::pest3_core::typed::wrapper::Rule for r#optional_trivia<'i> {
        type Rule = super::Rule;
        const RULE: super::Rule = super::Rule::r#optional_trivia;
    }
    #[allow(non_camel_case_types)]
    impl<'i> r#optional_trivia<'i> {
        #[doc = "A helper function to access [`string`]."]
        #[allow(non_snake_case)]
        pub fn r#string<'s>(&'s self) -> ::pest3_core::std::Option<&'s r#string<'i>> {
            let res = &*self.content;
            {
                let res = res.as_ref().map(|res| res);
                res
            }
        }
    }
    #[allow(unused_imports)]
    use pest3_core::typed::SubRule as _;
    ::pest3_core::typed::full_rule_struct!(
        r#optional_trivia,
        (),
        super::Rule,
        super::Rule::r#optional_trivia,
        ::pest3_core::std::Option::<r#string::<'i>>,
        ::pest3_core::std::Box<::pest3_core::std::Option::<r#string::<'i>>>,
    );
    #[allow(non_camel_case_types)]
    impl<'i> ::pest3_core::typed::PairContainer<super::Rule> for r#optional_trivia<'i> {
        fn for_each_child_pair(
            &self,
            f: &mut impl ::pest3_core::std::FnMut(::pest3_core::token::Pair<super::Rule>),
        ) {
            self.content.for_self_or_for_each_child_pair(f)
        }
        fn for_self_or_for_each_child_pair(
            &self,
            f: &mut impl ::pest3_core::std::FnMut(::pest3_core::token::Pair<super::Rule>),
        ) {
            use pest3_core::typed::PairTree;
            f(self.as_pair_tree())
        }
    }
    #[allow(non_camel_case_types)]
    impl<'i> ::pest3_core::typed::PairTree<super::Rule> for r#optional_trivia<'i> {
        fn get_rule() -> super::Rule {
            #[allow(unused_imports)]
            use pest3_core::typed::SubRule as _;
            super::Rule::r#optional_trivia
        }
        fn get_span(&self) -> (::pest3_core::std::usize, ::pest3_core::std::usize) {
            (self.span.start(), self.span.end())
        }
    }
    #[doc = "Generated for rule `repeat`. Grammar: `string*`."]
    #[derive(Clone, Debug, Eq, PartialEq)]
    #[allow(non_camel_case_types)]
    pub struct r#repeat<'i> {
        #[doc = r" Matched structure."]
        pub content: ::pest3_core::std::Box<
            super::generics::Rep<r#string<'i>, ::pest3_core::typed::template::Empty>,
        >,
        #[doc = r" Matched span."]
        pub span: ::pest3_core::Span<'i>,
    }
    #[allow(non_camel_case_types)]
    impl<'i> ::pest3_core::typed::wrapper::Rule for r#repeat<'i> {
        type Rule = super::Rule;
        const RULE: super::Rule = super::Rule::r#repeat;
    }
    #[allow(non_camel_case_types)]
    impl<'i> r#repeat<'i> {
        #[doc = "A helper function to access [`string`]."]
        #[allow(non_snake_case)]
        pub fn r#string<'s>(&'s self) -> ::pest3_core::std::Vec<&'s r#string<'i>> {
            let res = &*self.content;
            {
                let res = res
                    .content
                    .iter()
                    .map(|res| res)
                    .collect::<::pest3_core::std::Vec<_>>();
                res
            }
        }
    }
    #[allow(unused_imports)]
    use pest3_core::typed::SubRule as _;
    ::pest3_core::typed::full_rule_struct!(
        r#repeat,
        (),
        super::Rule,
        super::Rule::r#repeat,
        super::generics::Rep::<r#string::<'i>, ::pest3_core::typed::template::Empty>,
        ::pest3_core::std::Box<
            super::generics::Rep::<r#string::<'i>, ::pest3_core::typed::template::Empty>,
        >,
    );
    #[allow(non_camel_case_types)]
    impl<'i> ::pest3_core::typed::PairContainer<super::Rule> for r#repeat<'i> {
        fn for_each_child_pair(
            &self,
            f: &mut impl ::pest3_core::std::FnMut(::pest3_core::token::Pair<super::Rule>),
        ) {
            self.content.for_self_or_for_each_child_pair(f)
        }
        fn for_self_or_for_each_child_pair(
            &self,
            f: &mut impl ::pest3_core::std::FnMut(::pest3_core::token::Pair<super::Rule>),
        ) {
            use pest3_core::typed::PairTree;
            f(self.as_pair_tree())
        }
    }
    #[allow(non_camel_case_types)]
    impl<'i> ::pest3_core::typed::PairTree<super::Rule> for r#repeat<'i> {
        fn get_rule() -> super::Rule {
            #[allow(unused_imports)]
            use pest3_core::typed::SubRule as _;
            super::Rule::r#repeat
        }
        fn get_span(&self) -> (::pest3_core::std::usize, ::pest3_core::std::usize) {
            (self.span.start(), self.span.end())
        }
    }
    #[doc = "Generated for rule `repeat_trivia`. Grammar: `string~*`."]
    #[derive(Clone, Debug, Eq, PartialEq)]
    #[allow(non_camel_case_types)]
    pub struct r#repeat_trivia<'i> {
        #[doc = r" Matched structure."]
        pub content:
            ::pest3_core::std::Box<super::generics::Rep<r#string<'i>, __OptionalTrivia<'i>>>,
        #[doc = r" Matched span."]
        pub span: ::pest3_core::Span<'i>,
    }
    #[allow(non_camel_case_types)]
    impl<'i> ::pest3_core::typed::wrapper::Rule for r#repeat_trivia<'i> {
        type Rule = super::Rule;
        const RULE: super::Rule = super::Rule::r#repeat_trivia;
    }
    #[allow(non_camel_case_types)]
    impl<'i> r#repeat_trivia<'i> {
        #[doc = "A helper function to access [`string`]."]
        #[allow(non_snake_case)]
        pub fn r#string<'s>(&'s self) -> ::pest3_core::std::Vec<&'s r#string<'i>> {
            let res = &*self.content;
            {
                let res = res
                    .content
                    .iter()
                    .map(|res| res)
                    .collect::<::pest3_core::std::Vec<_>>();
                res
            }
        }
    }
    #[allow(unused_imports)]
    use pest3_core::typed::SubRule as _;
    ::pest3_core::typed::full_rule_struct!(
        r#repeat_trivia,
        (),
        super::Rule,
        super::Rule::r#repeat_trivia,
        super::generics::Rep::<r#string::<'i>, __OptionalTrivia::<'i>>,
        ::pest3_core::std::Box<super::generics::Rep::<r#string::<'i>, __OptionalTrivia::<'i>>>,
    );
    #[allow(non_camel_case_types)]
    impl<'i> ::pest3_core::typed::PairContainer<super::Rule> for r#repeat_trivia<'i> {
        fn for_each_child_pair(
            &self,
            f: &mut impl ::pest3_core::std::FnMut(::pest3_core::token::Pair<super::Rule>),
        ) {
            self.content.for_self_or_for_each_child_pair(f)
        }
        fn for_self_or_for_each_child_pair(
            &self,
            f: &mut impl ::pest3_core::std::FnMut(::pest3_core::token::Pair<super::Rule>),
        ) {
            use pest3_core::typed::PairTree;
            f(self.as_pair_tree())
        }
    }
    #[allow(non_camel_case_types)]
    impl<'i> ::pest3_core::typed::PairTree<super::Rule> for r#repeat_trivia<'i> {
        fn get_rule() -> super::Rule {
            #[allow(unused_imports)]
            use pest3_core::typed::SubRule as _;
            super::Rule::r#repeat_trivia
        }
        fn get_span(&self) -> (::pest3_core::std::usize, ::pest3_core::std::usize) {
            (self.span.start(), self.span.end())
        }
    }
    #[doc = "Generated for rule `repeat_trivia_mandatory`. Grammar: `string^*`."]
    #[derive(Clone, Debug, Eq, PartialEq)]
    #[allow(non_camel_case_types)]
    pub struct r#repeat_trivia_mandatory<'i> {
        #[doc = r" Matched structure."]
        pub content:
            ::pest3_core::std::Box<super::generics::Rep<r#string<'i>, __MandatoryTrivia<'i>>>,
        #[doc = r" Matched span."]
        pub span: ::pest3_core::Span<'i>,
    }
    #[allow(non_camel_case_types)]
    impl<'i> ::pest3_core::typed::wrapper::Rule for r#repeat_trivia_mandatory<'i> {
        type Rule = super::Rule;
        const RULE: super::Rule = super::Rule::r#repeat_trivia_mandatory;
    }
    #[allow(non_camel_case_types)]
    impl<'i> r#repeat_trivia_mandatory<'i> {
        #[doc = "A helper function to access [`string`]."]
        #[allow(non_snake_case)]
        pub fn r#string<'s>(&'s self) -> ::pest3_core::std::Vec<&'s r#string<'i>> {
            let res = &*self.content;
            {
                let res = res
                    .content
                    .iter()
                    .map(|res| res)
                    .collect::<::pest3_core::std::Vec<_>>();
                res
            }
        }
    }
    #[allow(unused_imports)]
    use pest3_core::typed::SubRule as _;
    ::pest3_core::typed::full_rule_struct!(
        r#repeat_trivia_mandatory,
        (),
        super::Rule,
        super::Rule::r#repeat_trivia_mandatory,
        super::generics::Rep::<r#string::<'i>, __MandatoryTrivia::<'i>>,
        ::pest3_core::std::Box<super::generics::Rep::<r#string::<'i>, __MandatoryTrivia::<'i>>>,
    );
    #[allow(non_camel_case_types)]
    impl<'i> ::pest3_core::typed::PairContainer<super::Rule> for r#repeat_trivia_mandatory<'i> {
        fn for_each_child_pair(
            &self,
            f: &mut impl ::pest3_core::std::FnMut(::pest3_core::token::Pair<super::Rule>),
        ) {
            self.content.for_self_or_for_each_child_pair(f)
        }
        fn for_self_or_for_each_child_pair(
            &self,
            f: &mut impl ::pest3_core::std::FnMut(::pest3_core::token::Pair<super::Rule>),
        ) {
            use pest3_core::typed::PairTree;
            f(self.as_pair_tree())
        }
    }
    #[allow(non_camel_case_types)]
    impl<'i> ::pest3_core::typed::PairTree<super::Rule> for r#repeat_trivia_mandatory<'i> {
        fn get_rule() -> super::Rule {
            #[allow(unused_imports)]
            use pest3_core::typed::SubRule as _;
            super::Rule::r#repeat_trivia_mandatory
        }
        fn get_span(&self) -> (::pest3_core::std::usize, ::pest3_core::std::usize) {
            (self.span.start(), self.span.end())
        }
    }
    #[doc = "Generated for rule `repeat_once`. Grammar: `string+`."]
    #[derive(Clone, Debug, Eq, PartialEq)]
    #[allow(non_camel_case_types)]
    pub struct r#repeat_once<'i> {
        #[doc = r" Matched structure."]
        pub content: ::pest3_core::std::Box<
            super::generics::RepOnce<r#string<'i>, ::pest3_core::typed::template::Empty>,
        >,
        #[doc = r" Matched span."]
        pub span: ::pest3_core::Span<'i>,
    }
    #[allow(non_camel_case_types)]
    impl<'i> ::pest3_core::typed::wrapper::Rule for r#repeat_once<'i> {
        type Rule = super::Rule;
        const RULE: super::Rule = super::Rule::r#repeat_once;
    }
    #[allow(non_camel_case_types)]
    impl<'i> r#repeat_once<'i> {
        #[doc = "A helper function to access [`string`]."]
        #[allow(non_snake_case)]
        pub fn r#string<'s>(&'s self) -> ::pest3_core::std::Vec<&'s r#string<'i>> {
            let res = &*self.content;
            {
                let res = res
                    .content
                    .iter()
                    .map(|res| res)
                    .collect::<::pest3_core::std::Vec<_>>();
                res
            }
        }
    }
    #[allow(unused_imports)]
    use pest3_core::typed::SubRule as _;
    ::pest3_core::typed::full_rule_struct!(
        r#repeat_once,
        (),
        super::Rule,
        super::Rule::r#repeat_once,
        super::generics::RepOnce::<r#string::<'i>, ::pest3_core::typed::template::Empty>,
        ::pest3_core::std::Box<
            super::generics::RepOnce::<r#string::<'i>, ::pest3_core::typed::template::Empty>,
        >,
    );
    #[allow(non_camel_case_types)]
    impl<'i> ::pest3_core::typed::PairContainer<super::Rule> for r#repeat_once<'i> {
        fn for_each_child_pair(
            &self,
            f: &mut impl ::pest3_core::std::FnMut(::pest3_core::token::Pair<super::Rule>),
        ) {
            self.content.for_self_or_for_each_child_pair(f)
        }
        fn for_self_or_for_each_child_pair(
            &self,
            f: &mut impl ::pest3_core::std::FnMut(::pest3_core::token::Pair<super::Rule>),
        ) {
            use pest3_core::typed::PairTree;
            f(self.as_pair_tree())
        }
    }
    #[allow(non_camel_case_types)]
    impl<'i> ::pest3_core::typed::PairTree<super::Rule> for r#repeat_once<'i> {
        fn get_rule() -> super::Rule {
            #[allow(unused_imports)]
            use pest3_core::typed::SubRule as _;
            super::Rule::r#repeat_once
        }
        fn get_span(&self) -> (::pest3_core::std::usize, ::pest3_core::std::usize) {
            (self.span.start(), self.span.end())
        }
    }
    #[doc = "Generated for rule `repeat_once_trivia`. Grammar: `string~+`."]
    #[derive(Clone, Debug, Eq, PartialEq)]
    #[allow(non_camel_case_types)]
    pub struct r#repeat_once_trivia<'i> {
        #[doc = r" Matched structure."]
        pub content:
            ::pest3_core::std::Box<super::generics::RepOnce<r#string<'i>, __OptionalTrivia<'i>>>,
        #[doc = r" Matched span."]
        pub span: ::pest3_core::Span<'i>,
    }
    #[allow(non_camel_case_types)]
    impl<'i> ::pest3_core::typed::wrapper::Rule for r#repeat_once_trivia<'i> {
        type Rule = super::Rule;
        const RULE: super::Rule = super::Rule::r#repeat_once_trivia;
    }
    #[allow(non_camel_case_types)]
    impl<'i> r#repeat_once_trivia<'i> {
        #[doc = "A helper function to access [`string`]."]
        #[allow(non_snake_case)]
        pub fn r#string<'s>(&'s self) -> ::pest3_core::std::Vec<&'s r#string<'i>> {
            let res = &*self.content;
            {
                let res = res
                    .content
                    .iter()
                    .map(|res| res)
                    .collect::<::pest3_core::std::Vec<_>>();
                res
            }
        }
    }
    #[allow(unused_imports)]
    use pest3_core::typed::SubRule as _;
    ::pest3_core::typed::full_rule_struct!(
        r#repeat_once_trivia,
        (),
        super::Rule,
        super::Rule::r#repeat_once_trivia,
        super::generics::RepOnce::<r#string::<'i>, __OptionalTrivia::<'i>>,
        ::pest3_core::std::Box<super::generics::RepOnce::<r#string::<'i>, __OptionalTrivia::<'i>>>,
    );
    #[allow(non_camel_case_types)]
    impl<'i> ::pest3_core::typed::PairContainer<super::Rule> for r#repeat_once_trivia<'i> {
        fn for_each_child_pair(
            &self,
            f: &mut impl ::pest3_core::std::FnMut(::pest3_core::token::Pair<super::Rule>),
        ) {
            self.content.for_self_or_for_each_child_pair(f)
        }
        fn for_self_or_for_each_child_pair(
            &self,
            f: &mut impl ::pest3_core::std::FnMut(::pest3_core::token::Pair<super::Rule>),
        ) {
            use pest3_core::typed::PairTree;
            f(self.as_pair_tree())
        }
    }
    #[allow(non_camel_case_types)]
    impl<'i> ::pest3_core::typed::PairTree<super::Rule> for r#repeat_once_trivia<'i> {
        fn get_rule() -> super::Rule {
            #[allow(unused_imports)]
            use pest3_core::typed::SubRule as _;
            super::Rule::r#repeat_once_trivia
        }
        fn get_span(&self) -> (::pest3_core::std::usize, ::pest3_core::std::usize) {
            (self.span.start(), self.span.end())
        }
    }
    #[doc = "Generated for rule `repeat_once_trivia_mandatory`. Grammar: `string^+`."]
    #[derive(Clone, Debug, Eq, PartialEq)]
    #[allow(non_camel_case_types)]
    pub struct r#repeat_once_trivia_mandatory<'i> {
        #[doc = r" Matched structure."]
        pub content:
            ::pest3_core::std::Box<super::generics::RepOnce<r#string<'i>, __MandatoryTrivia<'i>>>,
        #[doc = r" Matched span."]
        pub span: ::pest3_core::Span<'i>,
    }
    #[allow(non_camel_case_types)]
    impl<'i> ::pest3_core::typed::wrapper::Rule for r#repeat_once_trivia_mandatory<'i> {
        type Rule = super::Rule;
        const RULE: super::Rule = super::Rule::r#repeat_once_trivia_mandatory;
    }
    #[allow(non_camel_case_types)]
    impl<'i> r#repeat_once_trivia_mandatory<'i> {
        #[doc = "A helper function to access [`string`]."]
        #[allow(non_snake_case)]
        pub fn r#string<'s>(&'s self) -> ::pest3_core::std::Vec<&'s r#string<'i>> {
            let res = &*self.content;
            {
                let res = res
                    .content
                    .iter()
                    .map(|res| res)
                    .collect::<::pest3_core::std::Vec<_>>();
                res
            }
        }
    }
    #[allow(unused_imports)]
    use pest3_core::typed::SubRule as _;
    ::pest3_core::typed::full_rule_struct!(
        r#repeat_once_trivia_mandatory,
        (),
        super::Rule,
        super::Rule::r#repeat_once_trivia_mandatory,
        super::generics::RepOnce::<r#string::<'i>, __MandatoryTrivia::<'i>>,
        ::pest3_core::std::Box<super::generics::RepOnce::<r#string::<'i>, __MandatoryTrivia::<'i>>>,
    );
    #[allow(non_camel_case_types)]
    impl<'i> ::pest3_core::typed::PairContainer<super::Rule> for r#repeat_once_trivia_mandatory<'i> {
        fn for_each_child_pair(
            &self,
            f: &mut impl ::pest3_core::std::FnMut(::pest3_core::token::Pair<super::Rule>),
        ) {
            self.content.for_self_or_for_each_child_pair(f)
        }
        fn for_self_or_for_each_child_pair(
            &self,
            f: &mut impl ::pest3_core::std::FnMut(::pest3_core::token::Pair<super::Rule>),
        ) {
            use pest3_core::typed::PairTree;
            f(self.as_pair_tree())
        }
    }
    #[allow(non_camel_case_types)]
    impl<'i> ::pest3_core::typed::PairTree<super::Rule> for r#repeat_once_trivia_mandatory<'i> {
        fn get_rule() -> super::Rule {
            #[allow(unused_imports)]
            use pest3_core::typed::SubRule as _;
            super::Rule::r#repeat_once_trivia_mandatory
        }
        fn get_span(&self) -> (::pest3_core::std::usize, ::pest3_core::std::usize) {
            (self.span.start(), self.span.end())
        }
    }
    #[doc = "Generated for rule `repeat_min_max`. Grammar: `string[2..3]`."]
    #[derive(Clone, Debug, Eq, PartialEq)]
    #[allow(non_camel_case_types)]
    pub struct r#repeat_min_max<'i> {
        #[doc = r" Matched structure."]
        pub content: ::pest3_core::std::Box<
            super::generics::RepMinMax<
                r#string<'i>,
                ::pest3_core::typed::template::Empty,
                2usize,
                3usize,
            >,
        >,
        #[doc = r" Matched span."]
        pub span: ::pest3_core::Span<'i>,
    }
    #[allow(non_camel_case_types)]
    impl<'i> ::pest3_core::typed::wrapper::Rule for r#repeat_min_max<'i> {
        type Rule = super::Rule;
        const RULE: super::Rule = super::Rule::r#repeat_min_max;
    }
    #[allow(non_camel_case_types)]
    impl<'i> r#repeat_min_max<'i> {
        #[doc = "A helper function to access [`string`]."]
        #[allow(non_snake_case)]
        pub fn r#string<'s>(&'s self) -> ::pest3_core::std::Vec<&'s r#string<'i>> {
            let res = &*self.content;
            {
                let res = res
                    .content
                    .iter()
                    .map(|res| res)
                    .collect::<::pest3_core::std::Vec<_>>();
                res
            }
        }
    }
    #[allow(unused_imports)]
    use pest3_core::typed::SubRule as _;
    ::pest3_core::typed::full_rule_struct!(
        r#repeat_min_max,
        (),
        super::Rule,
        super::Rule::r#repeat_min_max,
        super::generics::RepMinMax::<
            r#string::<'i>,
            ::pest3_core::typed::template::Empty,
            2usize,
            3usize,
        >,
        ::pest3_core::std::Box<
            super::generics::RepMinMax::<
                r#string::<'i>,
                ::pest3_core::typed::template::Empty,
                2usize,
                3usize,
            >,
        >,
    );
    #[allow(non_camel_case_types)]
    impl<'i> ::pest3_core::typed::PairContainer<super::Rule> for r#repeat_min_max<'i> {
        fn for_each_child_pair(
            &self,
            f: &mut impl ::pest3_core::std::FnMut(::pest3_core::token::Pair<super::Rule>),
        ) {
            self.content.for_self_or_for_each_child_pair(f)
        }
        fn for_self_or_for_each_child_pair(
            &self,
            f: &mut impl ::pest3_core::std::FnMut(::pest3_core::token::Pair<super::Rule>),
        ) {
            use pest3_core::typed::PairTree;
            f(self.as_pair_tree())
        }
    }
    #[allow(non_camel_case_types)]
    impl<'i> ::pest3_core::typed::PairTree<super::Rule> for r#repeat_min_max<'i> {
        fn get_rule() -> super::Rule {
            #[allow(unused_imports)]
            use pest3_core::typed::SubRule as _;
            super::Rule::r#repeat_min_max
        }
        fn get_span(&self) -> (::pest3_core::std::usize, ::pest3_core::std::usize) {
            (self.span.start(), self.span.end())
        }
    }
    #[doc = "Generated for rule `repeat_min_max_trivia`. Grammar: `string~[2..3]`."]
    #[derive(Clone, Debug, Eq, PartialEq)]
    #[allow(non_camel_case_types)]
    pub struct r#repeat_min_max_trivia<'i> {
        #[doc = r" Matched structure."]
        pub content: ::pest3_core::std::Box<
            super::generics::RepMinMax<r#string<'i>, __OptionalTrivia<'i>, 2usize, 3usize>,
        >,
        #[doc = r" Matched span."]
        pub span: ::pest3_core::Span<'i>,
    }
    #[allow(non_camel_case_types)]
    impl<'i> ::pest3_core::typed::wrapper::Rule for r#repeat_min_max_trivia<'i> {
        type Rule = super::Rule;
        const RULE: super::Rule = super::Rule::r#repeat_min_max_trivia;
    }
    #[allow(non_camel_case_types)]
    impl<'i> r#repeat_min_max_trivia<'i> {
        #[doc = "A helper function to access [`string`]."]
        #[allow(non_snake_case)]
        pub fn r#string<'s>(&'s self) -> ::pest3_core::std::Vec<&'s r#string<'i>> {
            let res = &*self.content;
            {
                let res = res
                    .content
                    .iter()
                    .map(|res| res)
                    .collect::<::pest3_core::std::Vec<_>>();
                res
            }
        }
    }
    #[allow(unused_imports)]
    use pest3_core::typed::SubRule as _;
    ::pest3_core::typed::full_rule_struct!(
        r#repeat_min_max_trivia,
        (),
        super::Rule,
        super::Rule::r#repeat_min_max_trivia,
        super::generics::RepMinMax::<r#string::<'i>, __OptionalTrivia::<'i>, 2usize, 3usize>,
        ::pest3_core::std::Box<
            super::generics::RepMinMax::<r#string::<'i>, __OptionalTrivia::<'i>, 2usize, 3usize>,
        >,
    );
    #[allow(non_camel_case_types)]
    impl<'i> ::pest3_core::typed::PairContainer<super::Rule> for r#repeat_min_max_trivia<'i> {
        fn for_each_child_pair(
            &self,
            f: &mut impl ::pest3_core::std::FnMut(::pest3_core::token::Pair<super::Rule>),
        ) {
            self.content.for_self_or_for_each_child_pair(f)
        }
        fn for_self_or_for_each_child_pair(
            &self,
            f: &mut impl ::pest3_core::std::FnMut(::pest3_core::token::Pair<super::Rule>),
        ) {
            use pest3_core::typed::PairTree;
            f(self.as_pair_tree())
        }
    }
    #[allow(non_camel_case_types)]
    impl<'i> ::pest3_core::typed::PairTree<super::Rule> for r#repeat_min_max_trivia<'i> {
        fn get_rule() -> super::Rule {
            #[allow(unused_imports)]
            use pest3_core::typed::SubRule as _;
            super::Rule::r#repeat_min_max_trivia
        }
        fn get_span(&self) -> (::pest3_core::std::usize, ::pest3_core::std::usize) {
            (self.span.start(), self.span.end())
        }
    }
    #[doc = "Generated for rule `repeat_min_max_trivia_mandatory`. Grammar: `string^[2..3]`."]
    #[derive(Clone, Debug, Eq, PartialEq)]
    #[allow(non_camel_case_types)]
    pub struct r#repeat_min_max_trivia_mandatory<'i> {
        #[doc = r" Matched structure."]
        pub content: ::pest3_core::std::Box<
            super::generics::RepMinMax<r#string<'i>, __MandatoryTrivia<'i>, 2usize, 3usize>,
        >,
        #[doc = r" Matched span."]
        pub span: ::pest3_core::Span<'i>,
    }
    #[allow(non_camel_case_types)]
    impl<'i> ::pest3_core::typed::wrapper::Rule for r#repeat_min_max_trivia_mandatory<'i> {
        type Rule = super::Rule;
        const RULE: super::Rule = super::Rule::r#repeat_min_max_trivia_mandatory;
    }
    #[allow(non_camel_case_types)]
    impl<'i> r#repeat_min_max_trivia_mandatory<'i> {
        #[doc = "A helper function to access [`string`]."]
        #[allow(non_snake_case)]
        pub fn r#string<'s>(&'s self) -> ::pest3_core::std::Vec<&'s r#string<'i>> {
            let res = &*self.content;
            {
                let res = res
                    .content
                    .iter()
                    .map(|res| res)
                    .collect::<::pest3_core::std::Vec<_>>();
                res
            }
        }
    }
    #[allow(unused_imports)]
    use pest3_core::typed::SubRule as _;
    ::pest3_core::typed::full_rule_struct!(
        r#repeat_min_max_trivia_mandatory,
        (),
        super::Rule,
        super::Rule::r#repeat_min_max_trivia_mandatory,
        super::generics::RepMinMax::<r#string::<'i>, __MandatoryTrivia::<'i>, 2usize, 3usize>,
        ::pest3_core::std::Box<
            super::generics::RepMinMax::<r#string::<'i>, __MandatoryTrivia::<'i>, 2usize, 3usize>,
        >,
    );
    #[allow(non_camel_case_types)]
    impl<'i> ::pest3_core::typed::PairContainer<super::Rule> for r#repeat_min_max_trivia_mandatory<'i> {
        fn for_each_child_pair(
            &self,
            f: &mut impl ::pest3_core::std::FnMut(::pest3_core::token::Pair<super::Rule>),
        ) {
            self.content.for_self_or_for_each_child_pair(f)
        }
        fn for_self_or_for_each_child_pair(
            &self,
            f: &mut impl ::pest3_core::std::FnMut(::pest3_core::token::Pair<super::Rule>),
        ) {
            use pest3_core::typed::PairTree;
            f(self.as_pair_tree())
        }
    }
    #[allow(non_camel_case_types)]
    impl<'i> ::pest3_core::typed::PairTree<super::Rule> for r#repeat_min_max_trivia_mandatory<'i> {
        fn get_rule() -> super::Rule {
            #[allow(unused_imports)]
            use pest3_core::typed::SubRule as _;
            super::Rule::r#repeat_min_max_trivia_mandatory
        }
        fn get_span(&self) -> (::pest3_core::std::usize, ::pest3_core::std::usize) {
            (self.span.start(), self.span.end())
        }
    }
    #[doc = "Generated for rule `repeat_exact`. Grammar: `string[2..2]`."]
    #[derive(Clone, Debug, Eq, PartialEq)]
    #[allow(non_camel_case_types)]
    pub struct r#repeat_exact<'i> {
        #[doc = r" Matched structure."]
        pub content: ::pest3_core::std::Box<
            super::generics::RepMinMax<
                r#string<'i>,
                ::pest3_core::typed::template::Empty,
                2usize,
                2usize,
            >,
        >,
        #[doc = r" Matched span."]
        pub span: ::pest3_core::Span<'i>,
    }
    #[allow(non_camel_case_types)]
    impl<'i> ::pest3_core::typed::wrapper::Rule for r#repeat_exact<'i> {
        type Rule = super::Rule;
        const RULE: super::Rule = super::Rule::r#repeat_exact;
    }
    #[allow(non_camel_case_types)]
    impl<'i> r#repeat_exact<'i> {
        #[doc = "A helper function to access [`string`]."]
        #[allow(non_snake_case)]
        pub fn r#string<'s>(&'s self) -> ::pest3_core::std::Vec<&'s r#string<'i>> {
            let res = &*self.content;
            {
                let res = res
                    .content
                    .iter()
                    .map(|res| res)
                    .collect::<::pest3_core::std::Vec<_>>();
                res
            }
        }
    }
    #[allow(unused_imports)]
    use pest3_core::typed::SubRule as _;
    ::pest3_core::typed::full_rule_struct!(
        r#repeat_exact,
        (),
        super::Rule,
        super::Rule::r#repeat_exact,
        super::generics::RepMinMax::<
            r#string::<'i>,
            ::pest3_core::typed::template::Empty,
            2usize,
            2usize,
        >,
        ::pest3_core::std::Box<
            super::generics::RepMinMax::<
                r#string::<'i>,
                ::pest3_core::typed::template::Empty,
                2usize,
                2usize,
            >,
        >,
    );
    #[allow(non_camel_case_types)]
    impl<'i> ::pest3_core::typed::PairContainer<super::Rule> for r#repeat_exact<'i> {
        fn for_each_child_pair(
            &self,
            f: &mut impl ::pest3_core::std::FnMut(::pest3_core::token::Pair<super::Rule>),
        ) {
            self.content.for_self_or_for_each_child_pair(f)
        }
        fn for_self_or_for_each_child_pair(
            &self,
            f: &mut impl ::pest3_core::std::FnMut(::pest3_core::token::Pair<super::Rule>),
        ) {
            use pest3_core::typed::PairTree;
            f(self.as_pair_tree())
        }
    }
    #[allow(non_camel_case_types)]
    impl<'i> ::pest3_core::typed::PairTree<super::Rule> for r#repeat_exact<'i> {
        fn get_rule() -> super::Rule {
            #[allow(unused_imports)]
            use pest3_core::typed::SubRule as _;
            super::Rule::r#repeat_exact
        }
        fn get_span(&self) -> (::pest3_core::std::usize, ::pest3_core::std::usize) {
            (self.span.start(), self.span.end())
        }
    }
    #[doc = "Generated for rule `repeat_exact_trivia`. Grammar: `string~[2..2]`."]
    #[derive(Clone, Debug, Eq, PartialEq)]
    #[allow(non_camel_case_types)]
    pub struct r#repeat_exact_trivia<'i> {
        #[doc = r" Matched structure."]
        pub content: ::pest3_core::std::Box<
            super::generics::RepMinMax<r#string<'i>, __OptionalTrivia<'i>, 2usize, 2usize>,
        >,
        #[doc = r" Matched span."]
        pub span: ::pest3_core::Span<'i>,
    }
    #[allow(non_camel_case_types)]
    impl<'i> ::pest3_core::typed::wrapper::Rule for r#repeat_exact_trivia<'i> {
        type Rule = super::Rule;
        const RULE: super::Rule = super::Rule::r#repeat_exact_trivia;
    }
    #[allow(non_camel_case_types)]
    impl<'i> r#repeat_exact_trivia<'i> {
        #[doc = "A helper function to access [`string`]."]
        #[allow(non_snake_case)]
        pub fn r#string<'s>(&'s self) -> ::pest3_core::std::Vec<&'s r#string<'i>> {
            let res = &*self.content;
            {
                let res = res
                    .content
                    .iter()
                    .map(|res| res)
                    .collect::<::pest3_core::std::Vec<_>>();
                res
            }
        }
    }
    #[allow(unused_imports)]
    use pest3_core::typed::SubRule as _;
    ::pest3_core::typed::full_rule_struct!(
        r#repeat_exact_trivia,
        (),
        super::Rule,
        super::Rule::r#repeat_exact_trivia,
        super::generics::RepMinMax::<r#string::<'i>, __OptionalTrivia::<'i>, 2usize, 2usize>,
        ::pest3_core::std::Box<
            super::generics::RepMinMax::<r#string::<'i>, __OptionalTrivia::<'i>, 2usize, 2usize>,
        >,
    );
    #[allow(non_camel_case_types)]
    impl<'i> ::pest3_core::typed::PairContainer<super::Rule> for r#repeat_exact_trivia<'i> {
        fn for_each_child_pair(
            &self,
            f: &mut impl ::pest3_core::std::FnMut(::pest3_core::token::Pair<super::Rule>),
        ) {
            self.content.for_self_or_for_each_child_pair(f)
        }
        fn for_self_or_for_each_child_pair(
            &self,
            f: &mut impl ::pest3_core::std::FnMut(::pest3_core::token::Pair<super::Rule>),
        ) {
            use pest3_core::typed::PairTree;
            f(self.as_pair_tree())
        }
    }
    #[allow(non_camel_case_types)]
    impl<'i> ::pest3_core::typed::PairTree<super::Rule> for r#repeat_exact_trivia<'i> {
        fn get_rule() -> super::Rule {
            #[allow(unused_imports)]
            use pest3_core::typed::SubRule as _;
            super::Rule::r#repeat_exact_trivia
        }
        fn get_span(&self) -> (::pest3_core::std::usize, ::pest3_core::std::usize) {
            (self.span.start(), self.span.end())
        }
    }
    #[doc = "Generated for rule `repeat_exact_trivia_mandatory`. Grammar: `string^[2..2]`."]
    #[derive(Clone, Debug, Eq, PartialEq)]
    #[allow(non_camel_case_types)]
    pub struct r#repeat_exact_trivia_mandatory<'i> {
        #[doc = r" Matched structure."]
        pub content: ::pest3_core::std::Box<
            super::generics::RepMinMax<r#string<'i>, __MandatoryTrivia<'i>, 2usize, 2usize>,
        >,
        #[doc = r" Matched span."]
        pub span: ::pest3_core::Span<'i>,
    }
    #[allow(non_camel_case_types)]
    impl<'i> ::pest3_core::typed::wrapper::Rule for r#repeat_exact_trivia_mandatory<'i> {
        type Rule = super::Rule;
        const RULE: super::Rule = super::Rule::r#repeat_exact_trivia_mandatory;
    }
    #[allow(non_camel_case_types)]
    impl<'i> r#repeat_exact_trivia_mandatory<'i> {
        #[doc = "A helper function to access [`string`]."]
        #[allow(non_snake_case)]
        pub fn r#string<'s>(&'s self) -> ::pest3_core::std::Vec<&'s r#string<'i>> {
            let res = &*self.content;
            {
                let res = res
                    .content
                    .iter()
                    .map(|res| res)
                    .collect::<::pest3_core::std::Vec<_>>();
                res
            }
        }
    }
    #[allow(unused_imports)]
    use pest3_core::typed::SubRule as _;
    ::pest3_core::typed::full_rule_struct!(
        r#repeat_exact_trivia_mandatory,
        (),
        super::Rule,
        super::Rule::r#repeat_exact_trivia_mandatory,
        super::generics::RepMinMax::<r#string::<'i>, __MandatoryTrivia::<'i>, 2usize, 2usize>,
        ::pest3_core::std::Box<
            super::generics::RepMinMax::<r#string::<'i>, __MandatoryTrivia::<'i>, 2usize, 2usize>,
        >,
    );
    #[allow(non_camel_case_types)]
    impl<'i> ::pest3_core::typed::PairContainer<super::Rule> for r#repeat_exact_trivia_mandatory<'i> {
        fn for_each_child_pair(
            &self,
            f: &mut impl ::pest3_core::std::FnMut(::pest3_core::token::Pair<super::Rule>),
        ) {
            self.content.for_self_or_for_each_child_pair(f)
        }
        fn for_self_or_for_each_child_pair(
            &self,
            f: &mut impl ::pest3_core::std::FnMut(::pest3_core::token::Pair<super::Rule>),
        ) {
            use pest3_core::typed::PairTree;
            f(self.as_pair_tree())
        }
    }
    #[allow(non_camel_case_types)]
    impl<'i> ::pest3_core::typed::PairTree<super::Rule> for r#repeat_exact_trivia_mandatory<'i> {
        fn get_rule() -> super::Rule {
            #[allow(unused_imports)]
            use pest3_core::typed::SubRule as _;
            super::Rule::r#repeat_exact_trivia_mandatory
        }
        fn get_span(&self) -> (::pest3_core::std::usize, ::pest3_core::std::usize) {
            (self.span.start(), self.span.end())
        }
    }
    #[doc = "Generated for rule `repeat_min`. Grammar: `string[2..]`."]
    #[derive(Clone, Debug, Eq, PartialEq)]
    #[allow(non_camel_case_types)]
    pub struct r#repeat_min<'i> {
        #[doc = r" Matched structure."]
        pub content: ::pest3_core::std::Box<
            super::generics::RepMin<r#string<'i>, ::pest3_core::typed::template::Empty, 2usize>,
        >,
        #[doc = r" Matched span."]
        pub span: ::pest3_core::Span<'i>,
    }
    #[allow(non_camel_case_types)]
    impl<'i> ::pest3_core::typed::wrapper::Rule for r#repeat_min<'i> {
        type Rule = super::Rule;
        const RULE: super::Rule = super::Rule::r#repeat_min;
    }
    #[allow(non_camel_case_types)]
    impl<'i> r#repeat_min<'i> {
        #[doc = "A helper function to access [`string`]."]
        #[allow(non_snake_case)]
        pub fn r#string<'s>(&'s self) -> ::pest3_core::std::Vec<&'s r#string<'i>> {
            let res = &*self.content;
            {
                let res = res
                    .content
                    .iter()
                    .map(|res| res)
                    .collect::<::pest3_core::std::Vec<_>>();
                res
            }
        }
    }
    #[allow(unused_imports)]
    use pest3_core::typed::SubRule as _;
    ::pest3_core::typed::full_rule_struct!(
        r#repeat_min,
        (),
        super::Rule,
        super::Rule::r#repeat_min,
        super::generics::RepMin::<r#string::<'i>, ::pest3_core::typed::template::Empty, 2usize>,
        ::pest3_core::std::Box<
            super::generics::RepMin::<r#string::<'i>, ::pest3_core::typed::template::Empty, 2usize>,
        >,
    );
    #[allow(non_camel_case_types)]
    impl<'i> ::pest3_core::typed::PairContainer<super::Rule> for r#repeat_min<'i> {
        fn for_each_child_pair(
            &self,
            f: &mut impl ::pest3_core::std::FnMut(::pest3_core::token::Pair<super::Rule>),
        ) {
            self.content.for_self_or_for_each_child_pair(f)
        }
        fn for_self_or_for_each_child_pair(
            &self,
            f: &mut impl ::pest3_core::std::FnMut(::pest3_core::token::Pair<super::Rule>),
        ) {
            use pest3_core::typed::PairTree;
            f(self.as_pair_tree())
        }
    }
    #[allow(non_camel_case_types)]
    impl<'i> ::pest3_core::typed::PairTree<super::Rule> for r#repeat_min<'i> {
        fn get_rule() -> super::Rule {
            #[allow(unused_imports)]
            use pest3_core::typed::SubRule as _;
            super::Rule::r#repeat_min
        }
        fn get_span(&self) -> (::pest3_core::std::usize, ::pest3_core::std::usize) {
            (self.span.start(), self.span.end())
        }
    }
    #[doc = "Generated for rule `repeat_min_trivia`. Grammar: `string~[2..]`."]
    #[derive(Clone, Debug, Eq, PartialEq)]
    #[allow(non_camel_case_types)]
    pub struct r#repeat_min_trivia<'i> {
        #[doc = r" Matched structure."]
        pub content: ::pest3_core::std::Box<
            super::generics::RepMin<r#string<'i>, __OptionalTrivia<'i>, 2usize>,
        >,
        #[doc = r" Matched span."]
        pub span: ::pest3_core::Span<'i>,
    }
    #[allow(non_camel_case_types)]
    impl<'i> ::pest3_core::typed::wrapper::Rule for r#repeat_min_trivia<'i> {
        type Rule = super::Rule;
        const RULE: super::Rule = super::Rule::r#repeat_min_trivia;
    }
    #[allow(non_camel_case_types)]
    impl<'i> r#repeat_min_trivia<'i> {
        #[doc = "A helper function to access [`string`]."]
        #[allow(non_snake_case)]
        pub fn r#string<'s>(&'s self) -> ::pest3_core::std::Vec<&'s r#string<'i>> {
            let res = &*self.content;
            {
                let res = res
                    .content
                    .iter()
                    .map(|res| res)
                    .collect::<::pest3_core::std::Vec<_>>();
                res
            }
        }
    }
    #[allow(unused_imports)]
    use pest3_core::typed::SubRule as _;
    ::pest3_core::typed::full_rule_struct!(
        r#repeat_min_trivia,
        (),
        super::Rule,
        super::Rule::r#repeat_min_trivia,
        super::generics::RepMin::<r#string::<'i>, __OptionalTrivia::<'i>, 2usize>,
        ::pest3_core::std::Box<
            super::generics::RepMin::<r#string::<'i>, __OptionalTrivia::<'i>, 2usize>,
        >,
    );
    #[allow(non_camel_case_types)]
    impl<'i> ::pest3_core::typed::PairContainer<super::Rule> for r#repeat_min_trivia<'i> {
        fn for_each_child_pair(
            &self,
            f: &mut impl ::pest3_core::std::FnMut(::pest3_core::token::Pair<super::Rule>),
        ) {
            self.content.for_self_or_for_each_child_pair(f)
        }
        fn for_self_or_for_each_child_pair(
            &self,
            f: &mut impl ::pest3_core::std::FnMut(::pest3_core::token::Pair<super::Rule>),
        ) {
            use pest3_core::typed::PairTree;
            f(self.as_pair_tree())
        }
    }
    #[allow(non_camel_case_types)]
    impl<'i> ::pest3_core::typed::PairTree<super::Rule> for r#repeat_min_trivia<'i> {
        fn get_rule() -> super::Rule {
            #[allow(unused_imports)]
            use pest3_core::typed::SubRule as _;
            super::Rule::r#repeat_min_trivia
        }
        fn get_span(&self) -> (::pest3_core::std::usize, ::pest3_core::std::usize) {
            (self.span.start(), self.span.end())
        }
    }
    #[doc = "Generated for rule `repeat_min_trivia_mandatory`. Grammar: `string^[2..]`."]
    #[derive(Clone, Debug, Eq, PartialEq)]
    #[allow(non_camel_case_types)]
    pub struct r#repeat_min_trivia_mandatory<'i> {
        #[doc = r" Matched structure."]
        pub content: ::pest3_core::std::Box<
            super::generics::RepMin<r#string<'i>, __MandatoryTrivia<'i>, 2usize>,
        >,
        #[doc = r" Matched span."]
        pub span: ::pest3_core::Span<'i>,
    }
    #[allow(non_camel_case_types)]
    impl<'i> ::pest3_core::typed::wrapper::Rule for r#repeat_min_trivia_mandatory<'i> {
        type Rule = super::Rule;
        const RULE: super::Rule = super::Rule::r#repeat_min_trivia_mandatory;
    }
    #[allow(non_camel_case_types)]
    impl<'i> r#repeat_min_trivia_mandatory<'i> {
        #[doc = "A helper function to access [`string`]."]
        #[allow(non_snake_case)]
        pub fn r#string<'s>(&'s self) -> ::pest3_core::std::Vec<&'s r#string<'i>> {
            let res = &*self.content;
            {
                let res = res
                    .content
                    .iter()
                    .map(|res| res)
                    .collect::<::pest3_core::std::Vec<_>>();
                res
            }
        }
    }
    #[allow(unused_imports)]
    use pest3_core::typed::SubRule as _;
    ::pest3_core::typed::full_rule_struct!(
        r#repeat_min_trivia_mandatory,
        (),
        super::Rule,
        super::Rule::r#repeat_min_trivia_mandatory,
        super::generics::RepMin::<r#string::<'i>, __MandatoryTrivia::<'i>, 2usize>,
        ::pest3_core::std::Box<
            super::generics::RepMin::<r#string::<'i>, __MandatoryTrivia::<'i>, 2usize>,
        >,
    );
    #[allow(non_camel_case_types)]
    impl<'i> ::pest3_core::typed::PairContainer<super::Rule> for r#repeat_min_trivia_mandatory<'i> {
        fn for_each_child_pair(
            &self,
            f: &mut impl ::pest3_core::std::FnMut(::pest3_core::token::Pair<super::Rule>),
        ) {
            self.content.for_self_or_for_each_child_pair(f)
        }
        fn for_self_or_for_each_child_pair(
            &self,
            f: &mut impl ::pest3_core::std::FnMut(::pest3_core::token::Pair<super::Rule>),
        ) {
            use pest3_core::typed::PairTree;
            f(self.as_pair_tree())
        }
    }
    #[allow(non_camel_case_types)]
    impl<'i> ::pest3_core::typed::PairTree<super::Rule> for r#repeat_min_trivia_mandatory<'i> {
        fn get_rule() -> super::Rule {
            #[allow(unused_imports)]
            use pest3_core::typed::SubRule as _;
            super::Rule::r#repeat_min_trivia_mandatory
        }
        fn get_span(&self) -> (::pest3_core::std::usize, ::pest3_core::std::usize) {
            (self.span.start(), self.span.end())
        }
    }
    #[doc = "Generated for rule `repeat_max`. Grammar: `string[..2]`."]
    #[derive(Clone, Debug, Eq, PartialEq)]
    #[allow(non_camel_case_types)]
    pub struct r#repeat_max<'i> {
        #[doc = r" Matched structure."]
        pub content: ::pest3_core::std::Box<
            super::generics::RepMax<r#string<'i>, ::pest3_core::typed::template::Empty, 2usize>,
        >,
        #[doc = r" Matched span."]
        pub span: ::pest3_core::Span<'i>,
    }
    #[allow(non_camel_case_types)]
    impl<'i> ::pest3_core::typed::wrapper::Rule for r#repeat_max<'i> {
        type Rule = super::Rule;
        const RULE: super::Rule = super::Rule::r#repeat_max;
    }
    #[allow(non_camel_case_types)]
    impl<'i> r#repeat_max<'i> {
        #[doc = "A helper function to access [`string`]."]
        #[allow(non_snake_case)]
        pub fn r#string<'s>(&'s self) -> ::pest3_core::std::Vec<&'s r#string<'i>> {
            let res = &*self.content;
            {
                let res = res
                    .content
                    .iter()
                    .map(|res| res)
                    .collect::<::pest3_core::std::Vec<_>>();
                res
            }
        }
    }
    #[allow(unused_imports)]
    use pest3_core::typed::SubRule as _;
    ::pest3_core::typed::full_rule_struct!(
        r#repeat_max,
        (),
        super::Rule,
        super::Rule::r#repeat_max,
        super::generics::RepMax::<r#string::<'i>, ::pest3_core::typed::template::Empty, 2usize>,
        ::pest3_core::std::Box<
            super::generics::RepMax::<r#string::<'i>, ::pest3_core::typed::template::Empty, 2usize>,
        >,
    );
    #[allow(non_camel_case_types)]
    impl<'i> ::pest3_core::typed::PairContainer<super::Rule> for r#repeat_max<'i> {
        fn for_each_child_pair(
            &self,
            f: &mut impl ::pest3_core::std::FnMut(::pest3_core::token::Pair<super::Rule>),
        ) {
            self.content.for_self_or_for_each_child_pair(f)
        }
        fn for_self_or_for_each_child_pair(
            &self,
            f: &mut impl ::pest3_core::std::FnMut(::pest3_core::token::Pair<super::Rule>),
        ) {
            use pest3_core::typed::PairTree;
            f(self.as_pair_tree())
        }
    }
    #[allow(non_camel_case_types)]
    impl<'i> ::pest3_core::typed::PairTree<super::Rule> for r#repeat_max<'i> {
        fn get_rule() -> super::Rule {
            #[allow(unused_imports)]
            use pest3_core::typed::SubRule as _;
            super::Rule::r#repeat_max
        }
        fn get_span(&self) -> (::pest3_core::std::usize, ::pest3_core::std::usize) {
            (self.span.start(), self.span.end())
        }
    }
    #[doc = "Generated for rule `repeat_max_trivia`. Grammar: `string~[..2]`."]
    #[derive(Clone, Debug, Eq, PartialEq)]
    #[allow(non_camel_case_types)]
    pub struct r#repeat_max_trivia<'i> {
        #[doc = r" Matched structure."]
        pub content: ::pest3_core::std::Box<
            super::generics::RepMax<r#string<'i>, __OptionalTrivia<'i>, 2usize>,
        >,
        #[doc = r" Matched span."]
        pub span: ::pest3_core::Span<'i>,
    }
    #[allow(non_camel_case_types)]
    impl<'i> ::pest3_core::typed::wrapper::Rule for r#repeat_max_trivia<'i> {
        type Rule = super::Rule;
        const RULE: super::Rule = super::Rule::r#repeat_max_trivia;
    }
    #[allow(non_camel_case_types)]
    impl<'i> r#repeat_max_trivia<'i> {
        #[doc = "A helper function to access [`string`]."]
        #[allow(non_snake_case)]
        pub fn r#string<'s>(&'s self) -> ::pest3_core::std::Vec<&'s r#string<'i>> {
            let res = &*self.content;
            {
                let res = res
                    .content
                    .iter()
                    .map(|res| res)
                    .collect::<::pest3_core::std::Vec<_>>();
                res
            }
        }
    }
    #[allow(unused_imports)]
    use pest3_core::typed::SubRule as _;
    ::pest3_core::typed::full_rule_struct!(
        r#repeat_max_trivia,
        (),
        super::Rule,
        super::Rule::r#repeat_max_trivia,
        super::generics::RepMax::<r#string::<'i>, __OptionalTrivia::<'i>, 2usize>,
        ::pest3_core::std::Box<
            super::generics::RepMax::<r#string::<'i>, __OptionalTrivia::<'i>, 2usize>,
        >,
    );
    #[allow(non_camel_case_types)]
    impl<'i> ::pest3_core::typed::PairContainer<super::Rule> for r#repeat_max_trivia<'i> {
        fn for_each_child_pair(
            &self,
            f: &mut impl ::pest3_core::std::FnMut(::pest3_core::token::Pair<super::Rule>),
        ) {
            self.content.for_self_or_for_each_child_pair(f)
        }
        fn for_self_or_for_each_child_pair(
            &self,
            f: &mut impl ::pest3_core::std::FnMut(::pest3_core::token::Pair<super::Rule>),
        ) {
            use pest3_core::typed::PairTree;
            f(self.as_pair_tree())
        }
    }
    #[allow(non_camel_case_types)]
    impl<'i> ::pest3_core::typed::PairTree<super::Rule> for r#repeat_max_trivia<'i> {
        fn get_rule() -> super::Rule {
            #[allow(unused_imports)]
            use pest3_core::typed::SubRule as _;
            super::Rule::r#repeat_max_trivia
        }
        fn get_span(&self) -> (::pest3_core::std::usize, ::pest3_core::std::usize) {
            (self.span.start(), self.span.end())
        }
    }
    #[doc = "Generated for rule `repeat_max_trivia_mandatory`. Grammar: `string^[..2]`."]
    #[derive(Clone, Debug, Eq, PartialEq)]
    #[allow(non_camel_case_types)]
    pub struct r#repeat_max_trivia_mandatory<'i> {
        #[doc = r" Matched structure."]
        pub content: ::pest3_core::std::Box<
            super::generics::RepMax<r#string<'i>, __MandatoryTrivia<'i>, 2usize>,
        >,
        #[doc = r" Matched span."]
        pub span: ::pest3_core::Span<'i>,
    }
    #[allow(non_camel_case_types)]
    impl<'i> ::pest3_core::typed::wrapper::Rule for r#repeat_max_trivia_mandatory<'i> {
        type Rule = super::Rule;
        const RULE: super::Rule = super::Rule::r#repeat_max_trivia_mandatory;
    }
    #[allow(non_camel_case_types)]
    impl<'i> r#repeat_max_trivia_mandatory<'i> {
        #[doc = "A helper function to access [`string`]."]
        #[allow(non_snake_case)]
        pub fn r#string<'s>(&'s self) -> ::pest3_core::std::Vec<&'s r#string<'i>> {
            let res = &*self.content;
            {
                let res = res
                    .content
                    .iter()
                    .map(|res| res)
                    .collect::<::pest3_core::std::Vec<_>>();
                res
            }
        }
    }
    #[allow(unused_imports)]
    use pest3_core::typed::SubRule as _;
    ::pest3_core::typed::full_rule_struct!(
        r#repeat_max_trivia_mandatory,
        (),
        super::Rule,
        super::Rule::r#repeat_max_trivia_mandatory,
        super::generics::RepMax::<r#string::<'i>, __MandatoryTrivia::<'i>, 2usize>,
        ::pest3_core::std::Box<
            super::generics::RepMax::<r#string::<'i>, __MandatoryTrivia::<'i>, 2usize>,
        >,
    );
    #[allow(non_camel_case_types)]
    impl<'i> ::pest3_core::typed::PairContainer<super::Rule> for r#repeat_max_trivia_mandatory<'i> {
        fn for_each_child_pair(
            &self,
            f: &mut impl ::pest3_core::std::FnMut(::pest3_core::token::Pair<super::Rule>),
        ) {
            self.content.for_self_or_for_each_child_pair(f)
        }
        fn for_self_or_for_each_child_pair(
            &self,
            f: &mut impl ::pest3_core::std::FnMut(::pest3_core::token::Pair<super::Rule>),
        ) {
            use pest3_core::typed::PairTree;
            f(self.as_pair_tree())
        }
    }
    #[allow(non_camel_case_types)]
    impl<'i> ::pest3_core::typed::PairTree<super::Rule> for r#repeat_max_trivia_mandatory<'i> {
        fn get_rule() -> super::Rule {
            #[allow(unused_imports)]
            use pest3_core::typed::SubRule as _;
            super::Rule::r#repeat_max_trivia_mandatory
        }
        fn get_span(&self) -> (::pest3_core::std::usize, ::pest3_core::std::usize) {
            (self.span.start(), self.span.end())
        }
    }
    #[doc = "Generated for rule `seperated`. Grammar: `(e ~ (\",\" ~ e)*)`."]
    #[derive(Clone, Debug, Eq, PartialEq)]
    #[allow(non_camel_case_types)]
    pub struct r#seperated<'i, r#e> {
        #[doc = r" Matched structure."]
        pub content: ::pest3_core::std::Box<
            super::generics::Sequence2<
                r#e,
                ::pest3_core::typed::template::Empty,
                super::generics::Rep<
                    super::generics::Sequence2<
                        super::generics::Str<super::wrapper::W1>,
                        ::pest3_core::typed::template::Empty,
                        r#e,
                        __OptionalTrivia<'i>,
                    >,
                    ::pest3_core::typed::template::Empty,
                >,
                __OptionalTrivia<'i>,
            >,
        >,
        #[doc = r" Matched span."]
        pub span: ::pest3_core::Span<'i>,
    }
    #[allow(non_camel_case_types)]
    impl<'i, r#e> ::pest3_core::typed::wrapper::Rule for r#seperated<'i, r#e> {
        type Rule = super::Rule;
        const RULE: super::Rule = super::Rule::r#seperated;
    }
    #[allow(non_camel_case_types)]
    impl<'i, r#e> r#seperated<'i, r#e> {
        #[doc = "A helper function to access [`e`]."]
        #[allow(non_snake_case)]
        pub fn r#e<'s>(&'s self) -> (&'s r#e, ::pest3_core::std::Vec<&'s r#e>) {
            let res = &*self.content;
            {
                let res = (
                    {
                        let res = &res.field_0;
                        res
                    },
                    {
                        let res = &res.field_1;
                        {
                            let res = res
                                .content
                                .iter()
                                .map(|res| {
                                    let res = &res.field_1;
                                    res
                                })
                                .collect::<::pest3_core::std::Vec<_>>();
                            res
                        }
                    },
                );
                res
            }
        }
    }
    #[allow(unused_imports)]
    use pest3_core::typed::SubRule as _;
    ::pest3_core::typed::full_rule_struct!(
        r#seperated,
        (r#e),
        super::Rule,
        super::Rule::r#seperated,
        super::generics::Sequence2::<
            r#e,
            ::pest3_core::typed::template::Empty,
            super::generics::Rep::<
                super::generics::Sequence2::<
                    super::generics::Str::<super::wrapper::W1>,
                    ::pest3_core::typed::template::Empty,
                    r#e,
                    __OptionalTrivia::<'i>,
                >,
                ::pest3_core::typed::template::Empty,
            >,
            __OptionalTrivia::<'i>,
        >,
        ::pest3_core::std::Box<
            super::generics::Sequence2::<
                r#e,
                ::pest3_core::typed::template::Empty,
                super::generics::Rep::<
                    super::generics::Sequence2::<
                        super::generics::Str::<super::wrapper::W1>,
                        ::pest3_core::typed::template::Empty,
                        r#e,
                        __OptionalTrivia::<'i>,
                    >,
                    ::pest3_core::typed::template::Empty,
                >,
                __OptionalTrivia::<'i>,
            >,
        >,
    );
    #[allow(non_camel_case_types)]
    impl<'i, r#e: ::pest3_core::typed::PairContainer<super::Rule>>
        ::pest3_core::typed::PairContainer<super::Rule> for r#seperated<'i, r#e>
    {
        fn for_each_child_pair(
            &self,
            f: &mut impl ::pest3_core::std::FnMut(::pest3_core::token::Pair<super::Rule>),
        ) {
            self.content.for_self_or_for_each_child_pair(f)
        }
        fn for_self_or_for_each_child_pair(
            &self,
            f: &mut impl ::pest3_core::std::FnMut(::pest3_core::token::Pair<super::Rule>),
        ) {
            use pest3_core::typed::PairTree;
            f(self.as_pair_tree())
        }
    }
    #[allow(non_camel_case_types)]
    impl<'i, r#e: ::pest3_core::typed::PairContainer<super::Rule>>
        ::pest3_core::typed::PairTree<super::Rule> for r#seperated<'i, r#e>
    {
        fn get_rule() -> super::Rule {
            #[allow(unused_imports)]
            use pest3_core::typed::SubRule as _;
            super::Rule::r#seperated
        }
        fn get_span(&self) -> (::pest3_core::std::usize, ::pest3_core::std::usize) {
            (self.span.start(), self.span.end())
        }
    }
    #[doc = "Generated for rule `seperated_call`. Grammar: `seperated(string)`."]
    #[derive(Clone, Debug, Eq, PartialEq)]
    #[allow(non_camel_case_types)]
    pub struct r#seperated_call<'i> {
        #[doc = r" Matched structure."]
        pub content: ::pest3_core::std::Box<r#seperated<'i, r#string<'i>>>,
        #[doc = r" Matched span."]
        pub span: ::pest3_core::Span<'i>,
    }
    #[allow(non_camel_case_types)]
    impl<'i> ::pest3_core::typed::wrapper::Rule for r#seperated_call<'i> {
        type Rule = super::Rule;
        const RULE: super::Rule = super::Rule::r#seperated_call;
    }
    #[allow(non_camel_case_types)]
    impl<'i> r#seperated_call<'i> {
        #[doc = "A helper function to access [`seperated`]."]
        #[allow(non_snake_case)]
        pub fn r#seperated<'s>(&'s self) -> &'s r#seperated<'i, r#string<'i>> {
            let res = &*self.content;
            res
        }
    }
    #[allow(unused_imports)]
    use pest3_core::typed::SubRule as _;
    ::pest3_core::typed::full_rule_struct!(
        r#seperated_call,
        (),
        super::Rule,
        super::Rule::r#seperated_call,
        r#seperated::<'i, r#string::<'i>>,
        ::pest3_core::std::Box<r#seperated::<'i, r#string::<'i>>>,
    );
    #[allow(non_camel_case_types)]
    impl<'i> ::pest3_core::typed::PairContainer<super::Rule> for r#seperated_call<'i> {
        fn for_each_child_pair(
            &self,
            f: &mut impl ::pest3_core::std::FnMut(::pest3_core::token::Pair<super::Rule>),
        ) {
            self.content.for_self_or_for_each_child_pair(f)
        }
        fn for_self_or_for_each_child_pair(
            &self,
            f: &mut impl ::pest3_core::std::FnMut(::pest3_core::token::Pair<super::Rule>),
        ) {
            use pest3_core::typed::PairTree;
            f(self.as_pair_tree())
        }
    }
    #[allow(non_camel_case_types)]
    impl<'i> ::pest3_core::typed::PairTree<super::Rule> for r#seperated_call<'i> {
        fn get_rule() -> super::Rule {
            #[allow(unused_imports)]
            use pest3_core::typed::SubRule as _;
            super::Rule::r#seperated_call
        }
        fn get_span(&self) -> (::pest3_core::std::usize, ::pest3_core::std::usize) {
            (self.span.start(), self.span.end())
        }
    }
    #[doc = "Generated for rule `soi_at_start`. Grammar: `(pest::soi ~ string)`."]
    #[derive(Clone, Debug, Eq, PartialEq)]
    #[allow(non_camel_case_types)]
    pub struct r#soi_at_start<'i> {
        #[doc = r" Matched structure."]
        pub content: ::pest3_core::std::Box<
            super::generics::Sequence2<
                super::generics::r#soi,
                ::pest3_core::typed::template::Empty,
                r#string<'i>,
                __OptionalTrivia<'i>,
            >,
        >,
        #[doc = r" Matched span."]
        pub span: ::pest3_core::Span<'i>,
    }
    #[allow(non_camel_case_types)]
    impl<'i> ::pest3_core::typed::wrapper::Rule for r#soi_at_start<'i> {
        type Rule = super::Rule;
        const RULE: super::Rule = super::Rule::r#soi_at_start;
    }
    #[allow(non_camel_case_types)]
    impl<'i> r#soi_at_start<'i> {
        #[doc = "A helper function to access [`soi`]."]
        #[allow(non_snake_case)]
        pub fn r#soi<'s>(&'s self) -> &'s super::generics::r#soi {
            let res = &*self.content;
            {
                let res = &res.field_0;
                res
            }
        }
        #[doc = "A helper function to access [`string`]."]
        #[allow(non_snake_case)]
        pub fn r#string<'s>(&'s self) -> &'s r#string<'i> {
            let res = &*self.content;
            {
                let res = &res.field_1;
                res
            }
        }
    }
    #[allow(unused_imports)]
    use pest3_core::typed::SubRule as _;
    ::pest3_core::typed::full_rule_struct!(
        r#soi_at_start,
        (),
        super::Rule,
        super::Rule::r#soi_at_start,
        super::generics::Sequence2::<
            super::generics::r#soi,
            ::pest3_core::typed::template::Empty,
            r#string::<'i>,
            __OptionalTrivia::<'i>,
        >,
        ::pest3_core::std::Box<
            super::generics::Sequence2::<
                super::generics::r#soi,
                ::pest3_core::typed::template::Empty,
                r#string::<'i>,
                __OptionalTrivia::<'i>,
            >,
        >,
    );
    #[allow(non_camel_case_types)]
    impl<'i> ::pest3_core::typed::PairContainer<super::Rule> for r#soi_at_start<'i> {
        fn for_each_child_pair(
            &self,
            f: &mut impl ::pest3_core::std::FnMut(::pest3_core::token::Pair<super::Rule>),
        ) {
            self.content.for_self_or_for_each_child_pair(f)
        }
        fn for_self_or_for_each_child_pair(
            &self,
            f: &mut impl ::pest3_core::std::FnMut(::pest3_core::token::Pair<super::Rule>),
        ) {
            use pest3_core::typed::PairTree;
            f(self.as_pair_tree())
        }
    }
    #[allow(non_camel_case_types)]
    impl<'i> ::pest3_core::typed::PairTree<super::Rule> for r#soi_at_start<'i> {
        fn get_rule() -> super::Rule {
            #[allow(unused_imports)]
            use pest3_core::typed::SubRule as _;
            super::Rule::r#soi_at_start
        }
        fn get_span(&self) -> (::pest3_core::std::usize, ::pest3_core::std::usize) {
            (self.span.start(), self.span.end())
        }
    }
    #[doc = "Generated for rule `push`. Grammar: `pest::stack::push(exp)`."]
    #[derive(Clone, Debug, Eq, PartialEq)]
    #[allow(non_camel_case_types)]
    pub struct r#push<'i, r#exp> {
        #[doc = r" Matched structure."]
        pub content: ::pest3_core::std::Box<super::generics::r#push<r#exp>>,
        #[doc = r" Matched span."]
        pub span: ::pest3_core::Span<'i>,
    }
    #[allow(non_camel_case_types)]
    impl<'i, r#exp> ::pest3_core::typed::wrapper::Rule for r#push<'i, r#exp> {
        type Rule = super::Rule;
        const RULE: super::Rule = super::Rule::r#push;
    }
    #[allow(non_camel_case_types)]
    impl<'i, r#exp> r#push<'i, r#exp> {
        #[doc = "A helper function to access [`push`]."]
        #[allow(non_snake_case)]
        pub fn r#push<'s>(&'s self) -> &'s super::generics::r#push<r#exp> {
            let res = &*self.content;
            res
        }
    }
    #[allow(unused_imports)]
    use pest3_core::typed::SubRule as _;
    ::pest3_core::typed::full_rule_struct!(
        r#push,
        (r#exp),
        super::Rule,
        super::Rule::r#push,
        super::generics::r#push::<r#exp>,
        ::pest3_core::std::Box<super::generics::r#push::<r#exp>>,
    );
    #[allow(non_camel_case_types)]
    impl<'i, r#exp: ::pest3_core::typed::PairContainer<super::Rule>>
        ::pest3_core::typed::PairContainer<super::Rule> for r#push<'i, r#exp>
    {
        fn for_each_child_pair(
            &self,
            f: &mut impl ::pest3_core::std::FnMut(::pest3_core::token::Pair<super::Rule>),
        ) {
            self.content.for_self_or_for_each_child_pair(f)
        }
        fn for_self_or_for_each_child_pair(
            &self,
            f: &mut impl ::pest3_core::std::FnMut(::pest3_core::token::Pair<super::Rule>),
        ) {
            use pest3_core::typed::PairTree;
            f(self.as_pair_tree())
        }
    }
    #[allow(non_camel_case_types)]
    impl<'i, r#exp: ::pest3_core::typed::PairContainer<super::Rule>>
        ::pest3_core::typed::PairTree<super::Rule> for r#push<'i, r#exp>
    {
        fn get_rule() -> super::Rule {
            #[allow(unused_imports)]
            use pest3_core::typed::SubRule as _;
            super::Rule::r#push
        }
        fn get_span(&self) -> (::pest3_core::std::usize, ::pest3_core::std::usize) {
            (self.span.start(), self.span.end())
        }
    }
    #[doc = "Generated for rule `pop`. Grammar: `stack::pop`."]
    #[derive(Clone, Debug, Eq, PartialEq)]
    #[allow(non_camel_case_types)]
    pub struct r#pop<'i> {
        #[doc = r" Matched structure."]
        pub content: ::pest3_core::std::Box<super::generics::r#pop<'i>>,
        #[doc = r" Matched span."]
        pub span: ::pest3_core::Span<'i>,
    }
    #[allow(non_camel_case_types)]
    impl<'i> ::pest3_core::typed::wrapper::Rule for r#pop<'i> {
        type Rule = super::Rule;
        const RULE: super::Rule = super::Rule::r#pop;
    }
    #[allow(non_camel_case_types)]
    impl<'i> r#pop<'i> {
        #[doc = "A helper function to access [`pop`]."]
        #[allow(non_snake_case)]
        pub fn r#pop<'s>(&'s self) -> &'s super::generics::r#pop<'i> {
            let res = &*self.content;
            res
        }
    }
    #[allow(unused_imports)]
    use pest3_core::typed::SubRule as _;
    ::pest3_core::typed::full_rule_struct!(
        r#pop,
        (),
        super::Rule,
        super::Rule::r#pop,
        super::generics::r#pop::<'i>,
        ::pest3_core::std::Box<super::generics::r#pop::<'i>>,
    );
    #[allow(non_camel_case_types)]
    impl<'i> ::pest3_core::typed::PairContainer<super::Rule> for r#pop<'i> {
        fn for_each_child_pair(
            &self,
            _f: &mut impl ::pest3_core::std::FnMut(::pest3_core::token::Pair<super::Rule>),
        ) {
        }
        fn for_self_or_for_each_child_pair(
            &self,
            _f: &mut impl ::pest3_core::std::FnMut(::pest3_core::token::Pair<super::Rule>),
        ) {
        }
    }
    #[doc = "Generated for rule `pop_all`. Grammar: `stack::pop_all`."]
    #[derive(Clone, Debug, Eq, PartialEq)]
    #[allow(non_camel_case_types)]
    pub struct r#pop_all<'i> {
        #[doc = r" Matched structure."]
        pub content: ::pest3_core::std::Box<super::generics::r#pop_all<'i>>,
        #[doc = r" Matched span."]
        pub span: ::pest3_core::Span<'i>,
    }
    #[allow(non_camel_case_types)]
    impl<'i> ::pest3_core::typed::wrapper::Rule for r#pop_all<'i> {
        type Rule = super::Rule;
        const RULE: super::Rule = super::Rule::r#pop_all;
    }
    #[allow(non_camel_case_types)]
    impl<'i> r#pop_all<'i> {
        #[doc = "A helper function to access [`pop_all`]."]
        #[allow(non_snake_case)]
        pub fn r#pop_all<'s>(&'s self) -> &'s super::generics::r#pop_all<'i> {
            let res = &*self.content;
            res
        }
    }
    #[allow(unused_imports)]
    use pest3_core::typed::SubRule as _;
    ::pest3_core::typed::full_rule_struct!(
        r#pop_all,
        (),
        super::Rule,
        super::Rule::r#pop_all,
        super::generics::r#pop_all::<'i>,
        ::pest3_core::std::Box<super::generics::r#pop_all::<'i>>,
    );
    #[allow(non_camel_case_types)]
    impl<'i> ::pest3_core::typed::PairContainer<super::Rule> for r#pop_all<'i> {
        fn for_each_child_pair(
            &self,
            f: &mut impl ::pest3_core::std::FnMut(::pest3_core::token::Pair<super::Rule>),
        ) {
            self.content.for_self_or_for_each_child_pair(f)
        }
        fn for_self_or_for_each_child_pair(
            &self,
            f: &mut impl ::pest3_core::std::FnMut(::pest3_core::token::Pair<super::Rule>),
        ) {
            use pest3_core::typed::PairTree;
            f(self.as_pair_tree())
        }
    }
    #[allow(non_camel_case_types)]
    impl<'i> ::pest3_core::typed::PairTree<super::Rule> for r#pop_all<'i> {
        fn get_rule() -> super::Rule {
            #[allow(unused_imports)]
            use pest3_core::typed::SubRule as _;
            super::Rule::r#pop_all
        }
        fn get_span(&self) -> (::pest3_core::std::usize, ::pest3_core::std::usize) {
            (self.span.start(), self.span.end())
        }
    }
    #[doc = "Generated for rule `drop`. Grammar: `stack::drop`."]
    #[derive(Clone, Debug, Eq, PartialEq)]
    #[allow(non_camel_case_types)]
    pub struct r#drop<'i> {
        #[doc = r" Matched structure."]
        pub content: ::pest3_core::std::Box<super::generics::r#drop>,
        #[doc = r" Matched span."]
        pub span: ::pest3_core::Span<'i>,
    }
    #[allow(non_camel_case_types)]
    impl<'i> ::pest3_core::typed::wrapper::Rule for r#drop<'i> {
        type Rule = super::Rule;
        const RULE: super::Rule = super::Rule::r#drop;
    }
    #[allow(non_camel_case_types)]
    impl<'i> r#drop<'i> {
        #[doc = "A helper function to access [`drop`]."]
        #[allow(non_snake_case)]
        pub fn r#drop<'s>(&'s self) -> &'s super::generics::r#drop {
            let res = &*self.content;
            res
        }
    }
    #[allow(unused_imports)]
    use pest3_core::typed::SubRule as _;
    ::pest3_core::typed::full_rule_struct!(
        r#drop,
        (),
        super::Rule,
        super::Rule::r#drop,
        super::generics::r#drop,
        ::pest3_core::std::Box<super::generics::r#drop>,
    );
    #[allow(non_camel_case_types)]
    impl<'i> ::pest3_core::typed::PairContainer<super::Rule> for r#drop<'i> {
        fn for_each_child_pair(
            &self,
            f: &mut impl ::pest3_core::std::FnMut(::pest3_core::token::Pair<super::Rule>),
        ) {
            self.content.for_self_or_for_each_child_pair(f)
        }
        fn for_self_or_for_each_child_pair(
            &self,
            f: &mut impl ::pest3_core::std::FnMut(::pest3_core::token::Pair<super::Rule>),
        ) {
            use pest3_core::typed::PairTree;
            f(self.as_pair_tree())
        }
    }
    #[allow(non_camel_case_types)]
    impl<'i> ::pest3_core::typed::PairTree<super::Rule> for r#drop<'i> {
        fn get_rule() -> super::Rule {
            #[allow(unused_imports)]
            use pest3_core::typed::SubRule as _;
            super::Rule::r#drop
        }
        fn get_span(&self) -> (::pest3_core::std::usize, ::pest3_core::std::usize) {
            (self.span.start(), self.span.end())
        }
    }
    #[doc = "Generated for rule `peek`. Grammar: `stack::peek`."]
    #[derive(Clone, Debug, Eq, PartialEq)]
    #[allow(non_camel_case_types)]
    pub struct r#peek<'i> {
        #[doc = r" Matched structure."]
        pub content: ::pest3_core::std::Box<super::generics::r#peek<'i>>,
        #[doc = r" Matched span."]
        pub span: ::pest3_core::Span<'i>,
    }
    #[allow(non_camel_case_types)]
    impl<'i> ::pest3_core::typed::wrapper::Rule for r#peek<'i> {
        type Rule = super::Rule;
        const RULE: super::Rule = super::Rule::r#peek;
    }
    #[allow(non_camel_case_types)]
    impl<'i> r#peek<'i> {
        #[doc = "A helper function to access [`peek`]."]
        #[allow(non_snake_case)]
        pub fn r#peek<'s>(&'s self) -> &'s super::generics::r#peek<'i> {
            let res = &*self.content;
            res
        }
    }
    #[allow(unused_imports)]
    use pest3_core::typed::SubRule as _;
    ::pest3_core::typed::full_rule_struct!(
        r#peek,
        (),
        super::Rule,
        super::Rule::r#peek,
        super::generics::r#peek::<'i>,
        ::pest3_core::std::Box<super::generics::r#peek::<'i>>,
    );
    #[allow(non_camel_case_types)]
    impl<'i> ::pest3_core::typed::PairContainer<super::Rule> for r#peek<'i> {
        fn for_each_child_pair(
            &self,
            f: &mut impl ::pest3_core::std::FnMut(::pest3_core::token::Pair<super::Rule>),
        ) {
            self.content.for_self_or_for_each_child_pair(f)
        }
        fn for_self_or_for_each_child_pair(
            &self,
            f: &mut impl ::pest3_core::std::FnMut(::pest3_core::token::Pair<super::Rule>),
        ) {
            use pest3_core::typed::PairTree;
            f(self.as_pair_tree())
        }
    }
    #[allow(non_camel_case_types)]
    impl<'i> ::pest3_core::typed::PairTree<super::Rule> for r#peek<'i> {
        fn get_rule() -> super::Rule {
            #[allow(unused_imports)]
            use pest3_core::typed::SubRule as _;
            super::Rule::r#peek
        }
        fn get_span(&self) -> (::pest3_core::std::usize, ::pest3_core::std::usize) {
            (self.span.start(), self.span.end())
        }
    }
    #[doc = "Generated for rule `peek_all`. Grammar: `stack::peek_all`."]
    #[derive(Clone, Debug, Eq, PartialEq)]
    #[allow(non_camel_case_types)]
    pub struct r#peek_all<'i> {
        #[doc = r" Matched structure."]
        pub content: ::pest3_core::std::Box<super::generics::r#peek_all<'i>>,
        #[doc = r" Matched span."]
        pub span: ::pest3_core::Span<'i>,
    }
    #[allow(non_camel_case_types)]
    impl<'i> ::pest3_core::typed::wrapper::Rule for r#peek_all<'i> {
        type Rule = super::Rule;
        const RULE: super::Rule = super::Rule::r#peek_all;
    }
    #[allow(non_camel_case_types)]
    impl<'i> r#peek_all<'i> {
        #[doc = "A helper function to access [`peek_all`]."]
        #[allow(non_snake_case)]
        pub fn r#peek_all<'s>(&'s self) -> &'s super::generics::r#peek_all<'i> {
            let res = &*self.content;
            res
        }
    }
    #[allow(unused_imports)]
    use pest3_core::typed::SubRule as _;
    ::pest3_core::typed::full_rule_struct!(
        r#peek_all,
        (),
        super::Rule,
        super::Rule::r#peek_all,
        super::generics::r#peek_all::<'i>,
        ::pest3_core::std::Box<super::generics::r#peek_all::<'i>>,
    );
    #[allow(non_camel_case_types)]
    impl<'i> ::pest3_core::typed::PairContainer<super::Rule> for r#peek_all<'i> {
        fn for_each_child_pair(
            &self,
            f: &mut impl ::pest3_core::std::FnMut(::pest3_core::token::Pair<super::Rule>),
        ) {
            self.content.for_self_or_for_each_child_pair(f)
        }
        fn for_self_or_for_each_child_pair(
            &self,
            f: &mut impl ::pest3_core::std::FnMut(::pest3_core::token::Pair<super::Rule>),
        ) {
            use pest3_core::typed::PairTree;
            f(self.as_pair_tree())
        }
    }
    #[allow(non_camel_case_types)]
    impl<'i> ::pest3_core::typed::PairTree<super::Rule> for r#peek_all<'i> {
        fn get_rule() -> super::Rule {
            #[allow(unused_imports)]
            use pest3_core::typed::SubRule as _;
            super::Rule::r#peek_all
        }
        fn get_span(&self) -> (::pest3_core::std::usize, ::pest3_core::std::usize) {
            (self.span.start(), self.span.end())
        }
    }
    #[doc = "Generated for rule `peek_slice`. Grammar: `stack::peek[1..-2]`."]
    #[derive(Clone, Debug, Eq, PartialEq)]
    #[allow(non_camel_case_types)]
    pub struct r#peek_slice<'i> {
        #[doc = r" Matched structure."]
        pub content: ::pest3_core::std::Box<super::generics::PeekSlice2<1isize, -2isize>>,
        #[doc = r" Matched span."]
        pub span: ::pest3_core::Span<'i>,
    }
    #[allow(non_camel_case_types)]
    impl<'i> ::pest3_core::typed::wrapper::Rule for r#peek_slice<'i> {
        type Rule = super::Rule;
        const RULE: super::Rule = super::Rule::r#peek_slice;
    }
    #[allow(non_camel_case_types)]
    impl<'i> r#peek_slice<'i> {
        #[doc = "A helper function to access [`peek`]."]
        #[allow(non_snake_case)]
        pub fn r#peek<'s>(&'s self) -> &'s super::generics::PeekSlice2<1isize, -2isize> {
            let res = &*self.content;
            res
        }
    }
    #[allow(unused_imports)]
    use pest3_core::typed::SubRule as _;
    ::pest3_core::typed::full_rule_struct!(
        r#peek_slice,
        (),
        super::Rule,
        super::Rule::r#peek_slice,
        super::generics::PeekSlice2::<1isize, -2isize>,
        ::pest3_core::std::Box<super::generics::PeekSlice2::<1isize, -2isize>>,
    );
    #[allow(non_camel_case_types)]
    impl<'i> ::pest3_core::typed::PairContainer<super::Rule> for r#peek_slice<'i> {
        fn for_each_child_pair(
            &self,
            f: &mut impl ::pest3_core::std::FnMut(::pest3_core::token::Pair<super::Rule>),
        ) {
            self.content.for_self_or_for_each_child_pair(f)
        }
        fn for_self_or_for_each_child_pair(
            &self,
            f: &mut impl ::pest3_core::std::FnMut(::pest3_core::token::Pair<super::Rule>),
        ) {
            use pest3_core::typed::PairTree;
            f(self.as_pair_tree())
        }
    }
    #[allow(non_camel_case_types)]
    impl<'i> ::pest3_core::typed::PairTree<super::Rule> for r#peek_slice<'i> {
        fn get_rule() -> super::Rule {
            #[allow(unused_imports)]
            use pest3_core::typed::SubRule as _;
            super::Rule::r#peek_slice
        }
        fn get_span(&self) -> (::pest3_core::std::usize, ::pest3_core::std::usize) {
            (self.span.start(), self.span.end())
        }
    }
    #[doc = "Generated for rule `repeat_mutate_stack`. Grammar: `((push('a'..'c') ~ \",\")* ~ (pop ~ (pop ~ pop)))`."]
    #[derive(Clone, Debug, Eq, PartialEq)]
    #[allow(non_camel_case_types)]
    pub struct r#repeat_mutate_stack<'i> {
        #[doc = r" Matched structure."]
        pub content: ::pest3_core::std::Box<
            super::generics::Sequence4<
                super::generics::Rep<
                    super::generics::Sequence2<
                        r#push<'i, super::generics::CharRange<'a', 'c'>>,
                        ::pest3_core::typed::template::Empty,
                        super::generics::Str<super::wrapper::W1>,
                        __OptionalTrivia<'i>,
                    >,
                    ::pest3_core::typed::template::Empty,
                >,
                ::pest3_core::typed::template::Empty,
                r#pop<'i>,
                __OptionalTrivia<'i>,
                r#pop<'i>,
                __OptionalTrivia<'i>,
                r#pop<'i>,
                __OptionalTrivia<'i>,
            >,
        >,
        #[doc = r" Matched span."]
        pub span: ::pest3_core::Span<'i>,
    }
    #[allow(non_camel_case_types)]
    impl<'i> ::pest3_core::typed::wrapper::Rule for r#repeat_mutate_stack<'i> {
        type Rule = super::Rule;
        const RULE: super::Rule = super::Rule::r#repeat_mutate_stack;
    }
    #[allow(non_camel_case_types)]
    impl<'i> r#repeat_mutate_stack<'i> {
        #[doc = "A helper function to access [`pop`]."]
        #[allow(non_snake_case)]
        pub fn r#pop<'s>(&'s self) -> (&'s r#pop<'i>, &'s r#pop<'i>, &'s r#pop<'i>) {
            let res = &*self.content;
            {
                let res = (
                    {
                        let res = &res.field_1;
                        res
                    },
                    {
                        let res = &res.field_2;
                        res
                    },
                    {
                        let res = &res.field_3;
                        res
                    },
                );
                res
            }
        }
        #[doc = "A helper function to access [`push`]."]
        #[allow(non_snake_case)]
        pub fn r#push<'s>(
            &'s self,
        ) -> ::pest3_core::std::Vec<&'s r#push<'i, super::generics::CharRange<'a', 'c'>>> {
            let res = &*self.content;
            {
                let res = &res.field_0;
                {
                    let res = res
                        .content
                        .iter()
                        .map(|res| {
                            let res = &res.field_0;
                            res
                        })
                        .collect::<::pest3_core::std::Vec<_>>();
                    res
                }
            }
        }
    }
    #[allow(unused_imports)]
    use pest3_core::typed::SubRule as _;
    ::pest3_core::typed::full_rule_struct!(
        r#repeat_mutate_stack,
        (),
        super::Rule,
        super::Rule::r#repeat_mutate_stack,
        super::generics::Sequence4::<
            super::generics::Rep::<
                super::generics::Sequence2::<
                    r#push::<'i, super::generics::CharRange::<'a', 'c'>>,
                    ::pest3_core::typed::template::Empty,
                    super::generics::Str::<super::wrapper::W1>,
                    __OptionalTrivia::<'i>,
                >,
                ::pest3_core::typed::template::Empty,
            >,
            ::pest3_core::typed::template::Empty,
            r#pop::<'i>,
            __OptionalTrivia::<'i>,
            r#pop::<'i>,
            __OptionalTrivia::<'i>,
            r#pop::<'i>,
            __OptionalTrivia::<'i>,
        >,
        ::pest3_core::std::Box<
            super::generics::Sequence4::<
                super::generics::Rep::<
                    super::generics::Sequence2::<
                        r#push::<'i, super::generics::CharRange::<'a', 'c'>>,
                        ::pest3_core::typed::template::Empty,
                        super::generics::Str::<super::wrapper::W1>,
                        __OptionalTrivia::<'i>,
                    >,
                    ::pest3_core::typed::template::Empty,
                >,
                ::pest3_core::typed::template::Empty,
                r#pop::<'i>,
                __OptionalTrivia::<'i>,
                r#pop::<'i>,
                __OptionalTrivia::<'i>,
                r#pop::<'i>,
                __OptionalTrivia::<'i>,
            >,
        >,
    );
    #[allow(non_camel_case_types)]
    impl<'i> ::pest3_core::typed::PairContainer<super::Rule> for r#repeat_mutate_stack<'i> {
        fn for_each_child_pair(
            &self,
            f: &mut impl ::pest3_core::std::FnMut(::pest3_core::token::Pair<super::Rule>),
        ) {
            self.content.for_self_or_for_each_child_pair(f)
        }
        fn for_self_or_for_each_child_pair(
            &self,
            f: &mut impl ::pest3_core::std::FnMut(::pest3_core::token::Pair<super::Rule>),
        ) {
            use pest3_core::typed::PairTree;
            f(self.as_pair_tree())
        }
    }
    #[allow(non_camel_case_types)]
    impl<'i> ::pest3_core::typed::PairTree<super::Rule> for r#repeat_mutate_stack<'i> {
        fn get_rule() -> super::Rule {
            #[allow(unused_imports)]
            use pest3_core::typed::SubRule as _;
            super::Rule::r#repeat_mutate_stack
        }
        fn get_span(&self) -> (::pest3_core::std::usize, ::pest3_core::std::usize) {
            (self.span.start(), self.span.end())
        }
    }
    #[doc = "Generated for rule `repeat_mutate_stack_pop_all`. Grammar: `((push('a'..'c') ~ \",\")* ~ pop_all())`."]
    #[derive(Clone, Debug, Eq, PartialEq)]
    #[allow(non_camel_case_types)]
    pub struct r#repeat_mutate_stack_pop_all<'i> {
        #[doc = r" Matched structure."]
        pub content: ::pest3_core::std::Box<
            super::generics::Sequence2<
                super::generics::Rep<
                    super::generics::Sequence2<
                        r#push<'i, super::generics::CharRange<'a', 'c'>>,
                        ::pest3_core::typed::template::Empty,
                        super::generics::Str<super::wrapper::W1>,
                        __OptionalTrivia<'i>,
                    >,
                    ::pest3_core::typed::template::Empty,
                >,
                ::pest3_core::typed::template::Empty,
                r#pop_all<'i>,
                __OptionalTrivia<'i>,
            >,
        >,
        #[doc = r" Matched span."]
        pub span: ::pest3_core::Span<'i>,
    }
    #[allow(non_camel_case_types)]
    impl<'i> ::pest3_core::typed::wrapper::Rule for r#repeat_mutate_stack_pop_all<'i> {
        type Rule = super::Rule;
        const RULE: super::Rule = super::Rule::r#repeat_mutate_stack_pop_all;
    }
    #[allow(non_camel_case_types)]
    impl<'i> r#repeat_mutate_stack_pop_all<'i> {
        #[doc = "A helper function to access [`pop_all`]."]
        #[allow(non_snake_case)]
        pub fn r#pop_all<'s>(&'s self) -> &'s r#pop_all<'i> {
            let res = &*self.content;
            {
                let res = &res.field_1;
                res
            }
        }
        #[doc = "A helper function to access [`push`]."]
        #[allow(non_snake_case)]
        pub fn r#push<'s>(
            &'s self,
        ) -> ::pest3_core::std::Vec<&'s r#push<'i, super::generics::CharRange<'a', 'c'>>> {
            let res = &*self.content;
            {
                let res = &res.field_0;
                {
                    let res = res
                        .content
                        .iter()
                        .map(|res| {
                            let res = &res.field_0;
                            res
                        })
                        .collect::<::pest3_core::std::Vec<_>>();
                    res
                }
            }
        }
    }
    #[allow(unused_imports)]
    use pest3_core::typed::SubRule as _;
    ::pest3_core::typed::full_rule_struct!(
        r#repeat_mutate_stack_pop_all,
        (),
        super::Rule,
        super::Rule::r#repeat_mutate_stack_pop_all,
        super::generics::Sequence2::<
            super::generics::Rep::<
                super::generics::Sequence2::<
                    r#push::<'i, super::generics::CharRange::<'a', 'c'>>,
                    ::pest3_core::typed::template::Empty,
                    super::generics::Str::<super::wrapper::W1>,
                    __OptionalTrivia::<'i>,
                >,
                ::pest3_core::typed::template::Empty,
            >,
            ::pest3_core::typed::template::Empty,
            r#pop_all::<'i>,
            __OptionalTrivia::<'i>,
        >,
        ::pest3_core::std::Box<
            super::generics::Sequence2::<
                super::generics::Rep::<
                    super::generics::Sequence2::<
                        r#push::<'i, super::generics::CharRange::<'a', 'c'>>,
                        ::pest3_core::typed::template::Empty,
                        super::generics::Str::<super::wrapper::W1>,
                        __OptionalTrivia::<'i>,
                    >,
                    ::pest3_core::typed::template::Empty,
                >,
                ::pest3_core::typed::template::Empty,
                r#pop_all::<'i>,
                __OptionalTrivia::<'i>,
            >,
        >,
    );
    #[allow(non_camel_case_types)]
    impl<'i> ::pest3_core::typed::PairContainer<super::Rule> for r#repeat_mutate_stack_pop_all<'i> {
        fn for_each_child_pair(
            &self,
            f: &mut impl ::pest3_core::std::FnMut(::pest3_core::token::Pair<super::Rule>),
        ) {
            self.content.for_self_or_for_each_child_pair(f)
        }
        fn for_self_or_for_each_child_pair(
            &self,
            f: &mut impl ::pest3_core::std::FnMut(::pest3_core::token::Pair<super::Rule>),
        ) {
            use pest3_core::typed::PairTree;
            f(self.as_pair_tree())
        }
    }
    #[allow(non_camel_case_types)]
    impl<'i> ::pest3_core::typed::PairTree<super::Rule> for r#repeat_mutate_stack_pop_all<'i> {
        fn get_rule() -> super::Rule {
            #[allow(unused_imports)]
            use pest3_core::typed::SubRule as _;
            super::Rule::r#repeat_mutate_stack_pop_all
        }
        fn get_span(&self) -> (::pest3_core::std::usize, ::pest3_core::std::usize) {
            (self.span.start(), self.span.end())
        }
    }
    #[doc = "Generated for rule `will_fail`. Grammar: `(repeat_mutate_stack_pop_all ~ \"FAIL\")`."]
    #[derive(Clone, Debug, Eq, PartialEq)]
    #[allow(non_camel_case_types)]
    pub struct r#will_fail<'i> {
        #[doc = r" Matched structure."]
        pub content: ::pest3_core::std::Box<
            super::generics::Sequence2<
                r#repeat_mutate_stack_pop_all<'i>,
                ::pest3_core::typed::template::Empty,
                super::generics::Str<super::wrapper::W2>,
                __OptionalTrivia<'i>,
            >,
        >,
        #[doc = r" Matched span."]
        pub span: ::pest3_core::Span<'i>,
    }
    #[allow(non_camel_case_types)]
    impl<'i> ::pest3_core::typed::wrapper::Rule for r#will_fail<'i> {
        type Rule = super::Rule;
        const RULE: super::Rule = super::Rule::r#will_fail;
    }
    #[allow(non_camel_case_types)]
    impl<'i> r#will_fail<'i> {
        #[doc = "A helper function to access [`repeat_mutate_stack_pop_all`]."]
        #[allow(non_snake_case)]
        pub fn r#repeat_mutate_stack_pop_all<'s>(
            &'s self,
        ) -> &'s r#repeat_mutate_stack_pop_all<'i> {
            let res = &*self.content;
            {
                let res = &res.field_0;
                res
            }
        }
    }
    #[allow(unused_imports)]
    use pest3_core::typed::SubRule as _;
    ::pest3_core::typed::full_rule_struct!(
        r#will_fail,
        (),
        super::Rule,
        super::Rule::r#will_fail,
        super::generics::Sequence2::<
            r#repeat_mutate_stack_pop_all::<'i>,
            ::pest3_core::typed::template::Empty,
            super::generics::Str::<super::wrapper::W2>,
            __OptionalTrivia::<'i>,
        >,
        ::pest3_core::std::Box<
            super::generics::Sequence2::<
                r#repeat_mutate_stack_pop_all::<'i>,
                ::pest3_core::typed::template::Empty,
                super::generics::Str::<super::wrapper::W2>,
                __OptionalTrivia::<'i>,
            >,
        >,
    );
    #[allow(non_camel_case_types)]
    impl<'i> ::pest3_core::typed::PairContainer<super::Rule> for r#will_fail<'i> {
        fn for_each_child_pair(
            &self,
            f: &mut impl ::pest3_core::std::FnMut(::pest3_core::token::Pair<super::Rule>),
        ) {
            self.content.for_self_or_for_each_child_pair(f)
        }
        fn for_self_or_for_each_child_pair(
            &self,
            f: &mut impl ::pest3_core::std::FnMut(::pest3_core::token::Pair<super::Rule>),
        ) {
            use pest3_core::typed::PairTree;
            f(self.as_pair_tree())
        }
    }
    #[allow(non_camel_case_types)]
    impl<'i> ::pest3_core::typed::PairTree<super::Rule> for r#will_fail<'i> {
        fn get_rule() -> super::Rule {
            #[allow(unused_imports)]
            use pest3_core::typed::SubRule as _;
            super::Rule::r#will_fail
        }
        fn get_span(&self) -> (::pest3_core::std::usize, ::pest3_core::std::usize) {
            (self.span.start(), self.span.end())
        }
    }
    #[doc = "Generated for rule `stack_resume_after_fail`. Grammar: `(will_fail | repeat_mutate_stack_pop_all)`."]
    #[derive(Clone, Debug, Eq, PartialEq)]
    #[allow(non_camel_case_types)]
    pub struct r#stack_resume_after_fail<'i> {
        #[doc = r" Matched structure."]
        pub content: ::pest3_core::std::Box<
            super::generics::Choice2<r#will_fail<'i>, r#repeat_mutate_stack_pop_all<'i>>,
        >,
        #[doc = r" Matched span."]
        pub span: ::pest3_core::Span<'i>,
    }
    #[allow(non_camel_case_types)]
    impl<'i> ::pest3_core::typed::wrapper::Rule for r#stack_resume_after_fail<'i> {
        type Rule = super::Rule;
        const RULE: super::Rule = super::Rule::r#stack_resume_after_fail;
    }
    #[allow(non_camel_case_types)]
    impl<'i> r#stack_resume_after_fail<'i> {
        #[doc = "A helper function to access [`repeat_mutate_stack_pop_all`]."]
        #[allow(non_snake_case)]
        pub fn r#repeat_mutate_stack_pop_all<'s>(
            &'s self,
        ) -> ::pest3_core::std::Option<&'s r#repeat_mutate_stack_pop_all<'i>> {
            let res = &*self.content;
            {
                let res = res.choice_1().map(|res| res);
                res
            }
        }
        #[doc = "A helper function to access [`will_fail`]."]
        #[allow(non_snake_case)]
        pub fn r#will_fail<'s>(&'s self) -> ::pest3_core::std::Option<&'s r#will_fail<'i>> {
            let res = &*self.content;
            {
                let res = res.choice_0().map(|res| res);
                res
            }
        }
    }
    #[allow(unused_imports)]
    use pest3_core::typed::SubRule as _;
    ::pest3_core::typed::full_rule_struct!(
        r#stack_resume_after_fail,
        (),
        super::Rule,
        super::Rule::r#stack_resume_after_fail,
        super::generics::Choice2::<r#will_fail::<'i>, r#repeat_mutate_stack_pop_all::<'i>>,
        ::pest3_core::std::Box<
            super::generics::Choice2::<r#will_fail::<'i>, r#repeat_mutate_stack_pop_all::<'i>>,
        >,
    );
    #[allow(non_camel_case_types)]
    impl<'i> ::pest3_core::typed::PairContainer<super::Rule> for r#stack_resume_after_fail<'i> {
        fn for_each_child_pair(
            &self,
            f: &mut impl ::pest3_core::std::FnMut(::pest3_core::token::Pair<super::Rule>),
        ) {
            self.content.for_self_or_for_each_child_pair(f)
        }
        fn for_self_or_for_each_child_pair(
            &self,
            f: &mut impl ::pest3_core::std::FnMut(::pest3_core::token::Pair<super::Rule>),
        ) {
            use pest3_core::typed::PairTree;
            f(self.as_pair_tree())
        }
    }
    #[allow(non_camel_case_types)]
    impl<'i> ::pest3_core::typed::PairTree<super::Rule> for r#stack_resume_after_fail<'i> {
        fn get_rule() -> super::Rule {
            #[allow(unused_imports)]
            use pest3_core::typed::SubRule as _;
            super::Rule::r#stack_resume_after_fail
        }
        fn get_span(&self) -> (::pest3_core::std::usize, ::pest3_core::std::usize) {
            (self.span.start(), self.span.end())
        }
    }
    #[doc = "Generated for rule `peek_`. Grammar: `(push(range) ~ (push(range) ~ (peek() ~ peek())))`."]
    #[derive(Clone, Debug, Eq, PartialEq)]
    #[allow(non_camel_case_types)]
    pub struct r#peek_<'i> {
        #[doc = r" Matched structure."]
        pub content: ::pest3_core::std::Box<
            super::generics::Sequence4<
                r#push<'i, r#range<'i>>,
                ::pest3_core::typed::template::Empty,
                r#push<'i, r#range<'i>>,
                __OptionalTrivia<'i>,
                r#peek<'i>,
                __OptionalTrivia<'i>,
                r#peek<'i>,
                __OptionalTrivia<'i>,
            >,
        >,
        #[doc = r" Matched span."]
        pub span: ::pest3_core::Span<'i>,
    }
    #[allow(non_camel_case_types)]
    impl<'i> ::pest3_core::typed::wrapper::Rule for r#peek_<'i> {
        type Rule = super::Rule;
        const RULE: super::Rule = super::Rule::r#peek_;
    }
    #[allow(non_camel_case_types)]
    impl<'i> r#peek_<'i> {
        #[doc = "A helper function to access [`peek`]."]
        #[allow(non_snake_case)]
        pub fn r#peek<'s>(&'s self) -> (&'s r#peek<'i>, &'s r#peek<'i>) {
            let res = &*self.content;
            {
                let res = (
                    {
                        let res = &res.field_2;
                        res
                    },
                    {
                        let res = &res.field_3;
                        res
                    },
                );
                res
            }
        }
        #[doc = "A helper function to access [`push`]."]
        #[allow(non_snake_case)]
        pub fn r#push<'s>(&'s self) -> (&'s r#push<'i, r#range<'i>>, &'s r#push<'i, r#range<'i>>) {
            let res = &*self.content;
            {
                let res = (
                    {
                        let res = &res.field_0;
                        res
                    },
                    {
                        let res = &res.field_1;
                        res
                    },
                );
                res
            }
        }
    }
    #[allow(unused_imports)]
    use pest3_core::typed::SubRule as _;
    ::pest3_core::typed::full_rule_struct!(
        r#peek_,
        (),
        super::Rule,
        super::Rule::r#peek_,
        super::generics::Sequence4::<
            r#push::<'i, r#range::<'i>>,
            ::pest3_core::typed::template::Empty,
            r#push::<'i, r#range::<'i>>,
            __OptionalTrivia::<'i>,
            r#peek::<'i>,
            __OptionalTrivia::<'i>,
            r#peek::<'i>,
            __OptionalTrivia::<'i>,
        >,
        ::pest3_core::std::Box<
            super::generics::Sequence4::<
                r#push::<'i, r#range::<'i>>,
                ::pest3_core::typed::template::Empty,
                r#push::<'i, r#range::<'i>>,
                __OptionalTrivia::<'i>,
                r#peek::<'i>,
                __OptionalTrivia::<'i>,
                r#peek::<'i>,
                __OptionalTrivia::<'i>,
            >,
        >,
    );
    #[allow(non_camel_case_types)]
    impl<'i> ::pest3_core::typed::PairContainer<super::Rule> for r#peek_<'i> {
        fn for_each_child_pair(
            &self,
            f: &mut impl ::pest3_core::std::FnMut(::pest3_core::token::Pair<super::Rule>),
        ) {
            self.content.for_self_or_for_each_child_pair(f)
        }
        fn for_self_or_for_each_child_pair(
            &self,
            f: &mut impl ::pest3_core::std::FnMut(::pest3_core::token::Pair<super::Rule>),
        ) {
            use pest3_core::typed::PairTree;
            f(self.as_pair_tree())
        }
    }
    #[allow(non_camel_case_types)]
    impl<'i> ::pest3_core::typed::PairTree<super::Rule> for r#peek_<'i> {
        fn get_rule() -> super::Rule {
            #[allow(unused_imports)]
            use pest3_core::typed::SubRule as _;
            super::Rule::r#peek_
        }
        fn get_span(&self) -> (::pest3_core::std::usize, ::pest3_core::std::usize) {
            (self.span.start(), self.span.end())
        }
    }
    #[doc = "Generated for rule `peek_all_`. Grammar: `(push(range) ~ (push(range) ~ peek_all()))`."]
    #[derive(Clone, Debug, Eq, PartialEq)]
    #[allow(non_camel_case_types)]
    pub struct r#peek_all_<'i> {
        #[doc = r" Matched structure."]
        pub content: ::pest3_core::std::Box<
            super::generics::Sequence3<
                r#push<'i, r#range<'i>>,
                ::pest3_core::typed::template::Empty,
                r#push<'i, r#range<'i>>,
                __OptionalTrivia<'i>,
                r#peek_all<'i>,
                __OptionalTrivia<'i>,
            >,
        >,
        #[doc = r" Matched span."]
        pub span: ::pest3_core::Span<'i>,
    }
    #[allow(non_camel_case_types)]
    impl<'i> ::pest3_core::typed::wrapper::Rule for r#peek_all_<'i> {
        type Rule = super::Rule;
        const RULE: super::Rule = super::Rule::r#peek_all_;
    }
    #[allow(non_camel_case_types)]
    impl<'i> r#peek_all_<'i> {
        #[doc = "A helper function to access [`peek_all`]."]
        #[allow(non_snake_case)]
        pub fn r#peek_all<'s>(&'s self) -> &'s r#peek_all<'i> {
            let res = &*self.content;
            {
                let res = &res.field_2;
                res
            }
        }
        #[doc = "A helper function to access [`push`]."]
        #[allow(non_snake_case)]
        pub fn r#push<'s>(&'s self) -> (&'s r#push<'i, r#range<'i>>, &'s r#push<'i, r#range<'i>>) {
            let res = &*self.content;
            {
                let res = (
                    {
                        let res = &res.field_0;
                        res
                    },
                    {
                        let res = &res.field_1;
                        res
                    },
                );
                res
            }
        }
    }
    #[allow(unused_imports)]
    use pest3_core::typed::SubRule as _;
    ::pest3_core::typed::full_rule_struct!(
        r#peek_all_,
        (),
        super::Rule,
        super::Rule::r#peek_all_,
        super::generics::Sequence3::<
            r#push::<'i, r#range::<'i>>,
            ::pest3_core::typed::template::Empty,
            r#push::<'i, r#range::<'i>>,
            __OptionalTrivia::<'i>,
            r#peek_all::<'i>,
            __OptionalTrivia::<'i>,
        >,
        ::pest3_core::std::Box<
            super::generics::Sequence3::<
                r#push::<'i, r#range::<'i>>,
                ::pest3_core::typed::template::Empty,
                r#push::<'i, r#range::<'i>>,
                __OptionalTrivia::<'i>,
                r#peek_all::<'i>,
                __OptionalTrivia::<'i>,
            >,
        >,
    );
    #[allow(non_camel_case_types)]
    impl<'i> ::pest3_core::typed::PairContainer<super::Rule> for r#peek_all_<'i> {
        fn for_each_child_pair(
            &self,
            f: &mut impl ::pest3_core::std::FnMut(::pest3_core::token::Pair<super::Rule>),
        ) {
            self.content.for_self_or_for_each_child_pair(f)
        }
        fn for_self_or_for_each_child_pair(
            &self,
            f: &mut impl ::pest3_core::std::FnMut(::pest3_core::token::Pair<super::Rule>),
        ) {
            use pest3_core::typed::PairTree;
            f(self.as_pair_tree())
        }
    }
    #[allow(non_camel_case_types)]
    impl<'i> ::pest3_core::typed::PairTree<super::Rule> for r#peek_all_<'i> {
        fn get_rule() -> super::Rule {
            #[allow(unused_imports)]
            use pest3_core::typed::SubRule as _;
            super::Rule::r#peek_all_
        }
        fn get_span(&self) -> (::pest3_core::std::usize, ::pest3_core::std::usize) {
            (self.span.start(), self.span.end())
        }
    }
    #[doc = "Generated for rule `peek_slice_23`. Grammar: `(push(range) ~ (push(range) ~ (push(range) ~ (push(range) ~ (push(range) ~ peek_slice())))))`."]
    #[derive(Clone, Debug, Eq, PartialEq)]
    #[allow(non_camel_case_types)]
    pub struct r#peek_slice_23<'i> {
        #[doc = r" Matched structure."]
        pub content: ::pest3_core::std::Box<
            super::generics::Sequence6<
                r#push<'i, r#range<'i>>,
                ::pest3_core::typed::template::Empty,
                r#push<'i, r#range<'i>>,
                __OptionalTrivia<'i>,
                r#push<'i, r#range<'i>>,
                __OptionalTrivia<'i>,
                r#push<'i, r#range<'i>>,
                __OptionalTrivia<'i>,
                r#push<'i, r#range<'i>>,
                __OptionalTrivia<'i>,
                r#peek_slice<'i>,
                __OptionalTrivia<'i>,
            >,
        >,
        #[doc = r" Matched span."]
        pub span: ::pest3_core::Span<'i>,
    }
    #[allow(non_camel_case_types)]
    impl<'i> ::pest3_core::typed::wrapper::Rule for r#peek_slice_23<'i> {
        type Rule = super::Rule;
        const RULE: super::Rule = super::Rule::r#peek_slice_23;
    }
    #[allow(non_camel_case_types)]
    impl<'i> r#peek_slice_23<'i> {
        #[doc = "A helper function to access [`peek_slice`]."]
        #[allow(non_snake_case)]
        pub fn r#peek_slice<'s>(&'s self) -> &'s r#peek_slice<'i> {
            let res = &*self.content;
            {
                let res = &res.field_5;
                res
            }
        }
        #[doc = "A helper function to access [`push`]."]
        #[allow(non_snake_case)]
        pub fn r#push<'s>(
            &'s self,
        ) -> (
            &'s r#push<'i, r#range<'i>>,
            &'s r#push<'i, r#range<'i>>,
            &'s r#push<'i, r#range<'i>>,
            &'s r#push<'i, r#range<'i>>,
            &'s r#push<'i, r#range<'i>>,
        ) {
            let res = &*self.content;
            {
                let res = (
                    {
                        let res = &res.field_0;
                        res
                    },
                    {
                        let res = &res.field_1;
                        res
                    },
                    {
                        let res = &res.field_2;
                        res
                    },
                    {
                        let res = &res.field_3;
                        res
                    },
                    {
                        let res = &res.field_4;
                        res
                    },
                );
                res
            }
        }
    }
    #[allow(unused_imports)]
    use pest3_core::typed::SubRule as _;
    ::pest3_core::typed::full_rule_struct!(
        r#peek_slice_23,
        (),
        super::Rule,
        super::Rule::r#peek_slice_23,
        super::generics::Sequence6::<
            r#push::<'i, r#range::<'i>>,
            ::pest3_core::typed::template::Empty,
            r#push::<'i, r#range::<'i>>,
            __OptionalTrivia::<'i>,
            r#push::<'i, r#range::<'i>>,
            __OptionalTrivia::<'i>,
            r#push::<'i, r#range::<'i>>,
            __OptionalTrivia::<'i>,
            r#push::<'i, r#range::<'i>>,
            __OptionalTrivia::<'i>,
            r#peek_slice::<'i>,
            __OptionalTrivia::<'i>,
        >,
        ::pest3_core::std::Box<
            super::generics::Sequence6::<
                r#push::<'i, r#range::<'i>>,
                ::pest3_core::typed::template::Empty,
                r#push::<'i, r#range::<'i>>,
                __OptionalTrivia::<'i>,
                r#push::<'i, r#range::<'i>>,
                __OptionalTrivia::<'i>,
                r#push::<'i, r#range::<'i>>,
                __OptionalTrivia::<'i>,
                r#push::<'i, r#range::<'i>>,
                __OptionalTrivia::<'i>,
                r#peek_slice::<'i>,
                __OptionalTrivia::<'i>,
            >,
        >,
    );
    #[allow(non_camel_case_types)]
    impl<'i> ::pest3_core::typed::PairContainer<super::Rule> for r#peek_slice_23<'i> {
        fn for_each_child_pair(
            &self,
            f: &mut impl ::pest3_core::std::FnMut(::pest3_core::token::Pair<super::Rule>),
        ) {
            self.content.for_self_or_for_each_child_pair(f)
        }
        fn for_self_or_for_each_child_pair(
            &self,
            f: &mut impl ::pest3_core::std::FnMut(::pest3_core::token::Pair<super::Rule>),
        ) {
            use pest3_core::typed::PairTree;
            f(self.as_pair_tree())
        }
    }
    #[allow(non_camel_case_types)]
    impl<'i> ::pest3_core::typed::PairTree<super::Rule> for r#peek_slice_23<'i> {
        fn get_rule() -> super::Rule {
            #[allow(unused_imports)]
            use pest3_core::typed::SubRule as _;
            super::Rule::r#peek_slice_23
        }
        fn get_span(&self) -> (::pest3_core::std::usize, ::pest3_core::std::usize) {
            (self.span.start(), self.span.end())
        }
    }
    #[doc = "Generated for rule `pop_`. Grammar: `(push(range) ~ (push(range) ~ (pop ~ pop)))`."]
    #[derive(Clone, Debug, Eq, PartialEq)]
    #[allow(non_camel_case_types)]
    pub struct r#pop_<'i> {
        #[doc = r" Matched structure."]
        pub content: ::pest3_core::std::Box<
            super::generics::Sequence4<
                r#push<'i, r#range<'i>>,
                ::pest3_core::typed::template::Empty,
                r#push<'i, r#range<'i>>,
                __OptionalTrivia<'i>,
                r#pop<'i>,
                __OptionalTrivia<'i>,
                r#pop<'i>,
                __OptionalTrivia<'i>,
            >,
        >,
        #[doc = r" Matched span."]
        pub span: ::pest3_core::Span<'i>,
    }
    #[allow(non_camel_case_types)]
    impl<'i> ::pest3_core::typed::wrapper::Rule for r#pop_<'i> {
        type Rule = super::Rule;
        const RULE: super::Rule = super::Rule::r#pop_;
    }
    #[allow(non_camel_case_types)]
    impl<'i> r#pop_<'i> {
        #[doc = "A helper function to access [`pop`]."]
        #[allow(non_snake_case)]
        pub fn r#pop<'s>(&'s self) -> (&'s r#pop<'i>, &'s r#pop<'i>) {
            let res = &*self.content;
            {
                let res = (
                    {
                        let res = &res.field_2;
                        res
                    },
                    {
                        let res = &res.field_3;
                        res
                    },
                );
                res
            }
        }
        #[doc = "A helper function to access [`push`]."]
        #[allow(non_snake_case)]
        pub fn r#push<'s>(&'s self) -> (&'s r#push<'i, r#range<'i>>, &'s r#push<'i, r#range<'i>>) {
            let res = &*self.content;
            {
                let res = (
                    {
                        let res = &res.field_0;
                        res
                    },
                    {
                        let res = &res.field_1;
                        res
                    },
                );
                res
            }
        }
    }
    #[allow(unused_imports)]
    use pest3_core::typed::SubRule as _;
    ::pest3_core::typed::full_rule_struct!(
        r#pop_,
        (),
        super::Rule,
        super::Rule::r#pop_,
        super::generics::Sequence4::<
            r#push::<'i, r#range::<'i>>,
            ::pest3_core::typed::template::Empty,
            r#push::<'i, r#range::<'i>>,
            __OptionalTrivia::<'i>,
            r#pop::<'i>,
            __OptionalTrivia::<'i>,
            r#pop::<'i>,
            __OptionalTrivia::<'i>,
        >,
        ::pest3_core::std::Box<
            super::generics::Sequence4::<
                r#push::<'i, r#range::<'i>>,
                ::pest3_core::typed::template::Empty,
                r#push::<'i, r#range::<'i>>,
                __OptionalTrivia::<'i>,
                r#pop::<'i>,
                __OptionalTrivia::<'i>,
                r#pop::<'i>,
                __OptionalTrivia::<'i>,
            >,
        >,
    );
    #[allow(non_camel_case_types)]
    impl<'i> ::pest3_core::typed::PairContainer<super::Rule> for r#pop_<'i> {
        fn for_each_child_pair(
            &self,
            f: &mut impl ::pest3_core::std::FnMut(::pest3_core::token::Pair<super::Rule>),
        ) {
            self.content.for_self_or_for_each_child_pair(f)
        }
        fn for_self_or_for_each_child_pair(
            &self,
            f: &mut impl ::pest3_core::std::FnMut(::pest3_core::token::Pair<super::Rule>),
        ) {
            use pest3_core::typed::PairTree;
            f(self.as_pair_tree())
        }
    }
    #[allow(non_camel_case_types)]
    impl<'i> ::pest3_core::typed::PairTree<super::Rule> for r#pop_<'i> {
        fn get_rule() -> super::Rule {
            #[allow(unused_imports)]
            use pest3_core::typed::SubRule as _;
            super::Rule::r#pop_
        }
        fn get_span(&self) -> (::pest3_core::std::usize, ::pest3_core::std::usize) {
            (self.span.start(), self.span.end())
        }
    }
    #[doc = "Generated for rule `pop_all_`. Grammar: `(push(range) ~ (push(range) ~ pop_all()))`."]
    #[derive(Clone, Debug, Eq, PartialEq)]
    #[allow(non_camel_case_types)]
    pub struct r#pop_all_<'i> {
        #[doc = r" Matched structure."]
        pub content: ::pest3_core::std::Box<
            super::generics::Sequence3<
                r#push<'i, r#range<'i>>,
                ::pest3_core::typed::template::Empty,
                r#push<'i, r#range<'i>>,
                __OptionalTrivia<'i>,
                r#pop_all<'i>,
                __OptionalTrivia<'i>,
            >,
        >,
        #[doc = r" Matched span."]
        pub span: ::pest3_core::Span<'i>,
    }
    #[allow(non_camel_case_types)]
    impl<'i> ::pest3_core::typed::wrapper::Rule for r#pop_all_<'i> {
        type Rule = super::Rule;
        const RULE: super::Rule = super::Rule::r#pop_all_;
    }
    #[allow(non_camel_case_types)]
    impl<'i> r#pop_all_<'i> {
        #[doc = "A helper function to access [`pop_all`]."]
        #[allow(non_snake_case)]
        pub fn r#pop_all<'s>(&'s self) -> &'s r#pop_all<'i> {
            let res = &*self.content;
            {
                let res = &res.field_2;
                res
            }
        }
        #[doc = "A helper function to access [`push`]."]
        #[allow(non_snake_case)]
        pub fn r#push<'s>(&'s self) -> (&'s r#push<'i, r#range<'i>>, &'s r#push<'i, r#range<'i>>) {
            let res = &*self.content;
            {
                let res = (
                    {
                        let res = &res.field_0;
                        res
                    },
                    {
                        let res = &res.field_1;
                        res
                    },
                );
                res
            }
        }
    }
    #[allow(unused_imports)]
    use pest3_core::typed::SubRule as _;
    ::pest3_core::typed::full_rule_struct!(
        r#pop_all_,
        (),
        super::Rule,
        super::Rule::r#pop_all_,
        super::generics::Sequence3::<
            r#push::<'i, r#range::<'i>>,
            ::pest3_core::typed::template::Empty,
            r#push::<'i, r#range::<'i>>,
            __OptionalTrivia::<'i>,
            r#pop_all::<'i>,
            __OptionalTrivia::<'i>,
        >,
        ::pest3_core::std::Box<
            super::generics::Sequence3::<
                r#push::<'i, r#range::<'i>>,
                ::pest3_core::typed::template::Empty,
                r#push::<'i, r#range::<'i>>,
                __OptionalTrivia::<'i>,
                r#pop_all::<'i>,
                __OptionalTrivia::<'i>,
            >,
        >,
    );
    #[allow(non_camel_case_types)]
    impl<'i> ::pest3_core::typed::PairContainer<super::Rule> for r#pop_all_<'i> {
        fn for_each_child_pair(
            &self,
            f: &mut impl ::pest3_core::std::FnMut(::pest3_core::token::Pair<super::Rule>),
        ) {
            self.content.for_self_or_for_each_child_pair(f)
        }
        fn for_self_or_for_each_child_pair(
            &self,
            f: &mut impl ::pest3_core::std::FnMut(::pest3_core::token::Pair<super::Rule>),
        ) {
            use pest3_core::typed::PairTree;
            f(self.as_pair_tree())
        }
    }
    #[allow(non_camel_case_types)]
    impl<'i> ::pest3_core::typed::PairTree<super::Rule> for r#pop_all_<'i> {
        fn get_rule() -> super::Rule {
            #[allow(unused_imports)]
            use pest3_core::typed::SubRule as _;
            super::Rule::r#pop_all_
        }
        fn get_span(&self) -> (::pest3_core::std::usize, ::pest3_core::std::usize) {
            (self.span.start(), self.span.end())
        }
    }
    #[doc = "Generated for rule `pop_fail`. Grammar: `(push(range) ~ (!pop ~ (range ~ pop)))`."]
    #[derive(Clone, Debug, Eq, PartialEq)]
    #[allow(non_camel_case_types)]
    pub struct r#pop_fail<'i> {
        #[doc = r" Matched structure."]
        pub content: ::pest3_core::std::Box<
            super::generics::Sequence4<
                r#push<'i, r#range<'i>>,
                ::pest3_core::typed::template::Empty,
                super::generics::Negative<r#pop<'i>>,
                __OptionalTrivia<'i>,
                r#range<'i>,
                __OptionalTrivia<'i>,
                r#pop<'i>,
                __OptionalTrivia<'i>,
            >,
        >,
        #[doc = r" Matched span."]
        pub span: ::pest3_core::Span<'i>,
    }
    #[allow(non_camel_case_types)]
    impl<'i> ::pest3_core::typed::wrapper::Rule for r#pop_fail<'i> {
        type Rule = super::Rule;
        const RULE: super::Rule = super::Rule::r#pop_fail;
    }
    #[allow(non_camel_case_types)]
    impl<'i> r#pop_fail<'i> {
        #[doc = "A helper function to access [`pop`]."]
        #[allow(non_snake_case)]
        pub fn r#pop<'s>(&'s self) -> &'s r#pop<'i> {
            let res = &*self.content;
            {
                let res = &res.field_3;
                res
            }
        }
        #[doc = "A helper function to access [`push`]."]
        #[allow(non_snake_case)]
        pub fn r#push<'s>(&'s self) -> &'s r#push<'i, r#range<'i>> {
            let res = &*self.content;
            {
                let res = &res.field_0;
                res
            }
        }
        #[doc = "A helper function to access [`range`]."]
        #[allow(non_snake_case)]
        pub fn r#range<'s>(&'s self) -> &'s r#range<'i> {
            let res = &*self.content;
            {
                let res = &res.field_2;
                res
            }
        }
    }
    #[allow(unused_imports)]
    use pest3_core::typed::SubRule as _;
    ::pest3_core::typed::full_rule_struct!(
        r#pop_fail,
        (),
        super::Rule,
        super::Rule::r#pop_fail,
        super::generics::Sequence4::<
            r#push::<'i, r#range::<'i>>,
            ::pest3_core::typed::template::Empty,
            super::generics::Negative::<r#pop::<'i>>,
            __OptionalTrivia::<'i>,
            r#range::<'i>,
            __OptionalTrivia::<'i>,
            r#pop::<'i>,
            __OptionalTrivia::<'i>,
        >,
        ::pest3_core::std::Box<
            super::generics::Sequence4::<
                r#push::<'i, r#range::<'i>>,
                ::pest3_core::typed::template::Empty,
                super::generics::Negative::<r#pop::<'i>>,
                __OptionalTrivia::<'i>,
                r#range::<'i>,
                __OptionalTrivia::<'i>,
                r#pop::<'i>,
                __OptionalTrivia::<'i>,
            >,
        >,
    );
    #[allow(non_camel_case_types)]
    impl<'i> ::pest3_core::typed::PairContainer<super::Rule> for r#pop_fail<'i> {
        fn for_each_child_pair(
            &self,
            f: &mut impl ::pest3_core::std::FnMut(::pest3_core::token::Pair<super::Rule>),
        ) {
            self.content.for_self_or_for_each_child_pair(f)
        }
        fn for_self_or_for_each_child_pair(
            &self,
            f: &mut impl ::pest3_core::std::FnMut(::pest3_core::token::Pair<super::Rule>),
        ) {
            use pest3_core::typed::PairTree;
            f(self.as_pair_tree())
        }
    }
    #[allow(non_camel_case_types)]
    impl<'i> ::pest3_core::typed::PairTree<super::Rule> for r#pop_fail<'i> {
        fn get_rule() -> super::Rule {
            #[allow(unused_imports)]
            use pest3_core::typed::SubRule as _;
            super::Rule::r#pop_fail
        }
        fn get_span(&self) -> (::pest3_core::std::usize, ::pest3_core::std::usize) {
            (self.span.start(), self.span.end())
        }
    }
    #[doc = "Generated for rule `checkpoint_restore`. Grammar: `(push(\"\") ~ (((push(\"a\") ~ (\"b\" ~ pop())) | ((drop() ~ \"b\") | (pop() ~ \"a\"))) ~ pest::eoi))`."]
    #[derive(Clone, Debug, Eq, PartialEq)]
    #[allow(non_camel_case_types)]
    pub struct r#checkpoint_restore<'i> {
        #[doc = r" Matched structure."]
        pub content: ::pest3_core::std::Box<
            super::generics::Sequence3<
                r#push<'i, super::generics::Str<super::wrapper::W3>>,
                ::pest3_core::typed::template::Empty,
                super::generics::Choice3<
                    super::generics::Sequence3<
                        r#push<'i, super::generics::Str<super::wrapper::W4>>,
                        ::pest3_core::typed::template::Empty,
                        super::generics::Str<super::wrapper::W5>,
                        __OptionalTrivia<'i>,
                        r#pop<'i>,
                        __OptionalTrivia<'i>,
                    >,
                    super::generics::Sequence2<
                        r#drop<'i>,
                        ::pest3_core::typed::template::Empty,
                        super::generics::Str<super::wrapper::W5>,
                        __OptionalTrivia<'i>,
                    >,
                    super::generics::Sequence2<
                        r#pop<'i>,
                        ::pest3_core::typed::template::Empty,
                        super::generics::Str<super::wrapper::W4>,
                        __OptionalTrivia<'i>,
                    >,
                >,
                __OptionalTrivia<'i>,
                super::generics::r#eoi,
                __OptionalTrivia<'i>,
            >,
        >,
        #[doc = r" Matched span."]
        pub span: ::pest3_core::Span<'i>,
    }
    #[allow(non_camel_case_types)]
    impl<'i> ::pest3_core::typed::wrapper::Rule for r#checkpoint_restore<'i> {
        type Rule = super::Rule;
        const RULE: super::Rule = super::Rule::r#checkpoint_restore;
    }
    #[allow(non_camel_case_types)]
    impl<'i> r#checkpoint_restore<'i> {
        #[doc = "A helper function to access [`drop`]."]
        #[allow(non_snake_case)]
        pub fn r#drop<'s>(&'s self) -> ::pest3_core::std::Option<&'s r#drop<'i>> {
            let res = &*self.content;
            {
                let res = &res.field_1;
                {
                    let res = res.choice_1().map(|res| {
                        let res = &res.field_0;
                        res
                    });
                    res
                }
            }
        }
        #[doc = "A helper function to access [`eoi`]."]
        #[allow(non_snake_case)]
        pub fn r#eoi<'s>(&'s self) -> &'s super::generics::r#eoi {
            let res = &*self.content;
            {
                let res = &res.field_2;
                res
            }
        }
        #[doc = "A helper function to access [`pop`]."]
        #[allow(non_snake_case)]
        pub fn r#pop<'s>(
            &'s self,
        ) -> (
            ::pest3_core::std::Option<&'s r#pop<'i>>,
            ::pest3_core::std::Option<&'s r#pop<'i>>,
        ) {
            let res = &*self.content;
            {
                let res = &res.field_1;
                {
                    let res = (
                        {
                            let res = res.choice_0().map(|res| {
                                let res = &res.field_2;
                                res
                            });
                            res
                        },
                        {
                            let res = res.choice_2().map(|res| {
                                let res = &res.field_0;
                                res
                            });
                            res
                        },
                    );
                    res
                }
            }
        }
        #[doc = "A helper function to access [`push`]."]
        #[allow(non_snake_case)]
        pub fn r#push<'s>(
            &'s self,
        ) -> (
            &'s r#push<'i, super::generics::Str<super::wrapper::W3>>,
            ::pest3_core::std::Option<&'s r#push<'i, super::generics::Str<super::wrapper::W4>>>,
        ) {
            let res = &*self.content;
            {
                let res = (
                    {
                        let res = &res.field_0;
                        res
                    },
                    {
                        let res = &res.field_1;
                        {
                            let res = res.choice_0().map(|res| {
                                let res = &res.field_0;
                                res
                            });
                            res
                        }
                    },
                );
                res
            }
        }
    }
    #[allow(unused_imports)]
    use pest3_core::typed::SubRule as _;
    ::pest3_core::typed::full_rule_struct!(
        r#checkpoint_restore,
        (),
        super::Rule,
        super::Rule::r#checkpoint_restore,
        super::generics::Sequence3::<
            r#push::<'i, super::generics::Str::<super::wrapper::W3>>,
            ::pest3_core::typed::template::Empty,
            super::generics::Choice3::<
                super::generics::Sequence3::<
                    r#push::<'i, super::generics::Str::<super::wrapper::W4>>,
                    ::pest3_core::typed::template::Empty,
                    super::generics::Str::<super::wrapper::W5>,
                    __OptionalTrivia::<'i>,
                    r#pop::<'i>,
                    __OptionalTrivia::<'i>,
                >,
                super::generics::Sequence2::<
                    r#drop::<'i>,
                    ::pest3_core::typed::template::Empty,
                    super::generics::Str::<super::wrapper::W5>,
                    __OptionalTrivia::<'i>,
                >,
                super::generics::Sequence2::<
                    r#pop::<'i>,
                    ::pest3_core::typed::template::Empty,
                    super::generics::Str::<super::wrapper::W4>,
                    __OptionalTrivia::<'i>,
                >,
            >,
            __OptionalTrivia::<'i>,
            super::generics::r#eoi,
            __OptionalTrivia::<'i>,
        >,
        ::pest3_core::std::Box<
            super::generics::Sequence3::<
                r#push::<'i, super::generics::Str::<super::wrapper::W3>>,
                ::pest3_core::typed::template::Empty,
                super::generics::Choice3::<
                    super::generics::Sequence3::<
                        r#push::<'i, super::generics::Str::<super::wrapper::W4>>,
                        ::pest3_core::typed::template::Empty,
                        super::generics::Str::<super::wrapper::W5>,
                        __OptionalTrivia::<'i>,
                        r#pop::<'i>,
                        __OptionalTrivia::<'i>,
                    >,
                    super::generics::Sequence2::<
                        r#drop::<'i>,
                        ::pest3_core::typed::template::Empty,
                        super::generics::Str::<super::wrapper::W5>,
                        __OptionalTrivia::<'i>,
                    >,
                    super::generics::Sequence2::<
                        r#pop::<'i>,
                        ::pest3_core::typed::template::Empty,
                        super::generics::Str::<super::wrapper::W4>,
                        __OptionalTrivia::<'i>,
                    >,
                >,
                __OptionalTrivia::<'i>,
                super::generics::r#eoi,
                __OptionalTrivia::<'i>,
            >,
        >,
    );
    #[allow(non_camel_case_types)]
    impl<'i> ::pest3_core::typed::PairContainer<super::Rule> for r#checkpoint_restore<'i> {
        fn for_each_child_pair(
            &self,
            f: &mut impl ::pest3_core::std::FnMut(::pest3_core::token::Pair<super::Rule>),
        ) {
            self.content.for_self_or_for_each_child_pair(f)
        }
        fn for_self_or_for_each_child_pair(
            &self,
            f: &mut impl ::pest3_core::std::FnMut(::pest3_core::token::Pair<super::Rule>),
        ) {
            use pest3_core::typed::PairTree;
            f(self.as_pair_tree())
        }
    }
    #[allow(non_camel_case_types)]
    impl<'i> ::pest3_core::typed::PairTree<super::Rule> for r#checkpoint_restore<'i> {
        fn get_rule() -> super::Rule {
            #[allow(unused_imports)]
            use pest3_core::typed::SubRule as _;
            super::Rule::r#checkpoint_restore
        }
        fn get_span(&self) -> (::pest3_core::std::usize, ::pest3_core::std::usize) {
            (self.span.start(), self.span.end())
        }
    }
    #[doc = "Generated for rule `ascii_digits`. Grammar: `pest::ascii_digit+`."]
    #[derive(Clone, Debug, Eq, PartialEq)]
    #[allow(non_camel_case_types)]
    pub struct r#ascii_digits<'i> {
        #[doc = r" Matched structure."]
        pub content: ::pest3_core::std::Box<
            super::generics::RepOnce<
                super::generics::r#ascii_digit,
                ::pest3_core::typed::template::Empty,
            >,
        >,
        #[doc = r" Matched span."]
        pub span: ::pest3_core::Span<'i>,
    }
    #[allow(non_camel_case_types)]
    impl<'i> ::pest3_core::typed::wrapper::Rule for r#ascii_digits<'i> {
        type Rule = super::Rule;
        const RULE: super::Rule = super::Rule::r#ascii_digits;
    }
    #[allow(non_camel_case_types)]
    impl<'i> r#ascii_digits<'i> {
        #[doc = "A helper function to access [`ascii_digit`]."]
        #[allow(non_snake_case)]
        pub fn r#ascii_digit<'s>(
            &'s self,
        ) -> ::pest3_core::std::Vec<&'s super::generics::r#ascii_digit> {
            let res = &*self.content;
            {
                let res = res
                    .content
                    .iter()
                    .map(|res| res)
                    .collect::<::pest3_core::std::Vec<_>>();
                res
            }
        }
    }
    #[allow(unused_imports)]
    use pest3_core::typed::SubRule as _;
    ::pest3_core::typed::full_rule_struct!(
        r#ascii_digits,
        (),
        super::Rule,
        super::Rule::r#ascii_digits,
        super::generics::RepOnce::<
            super::generics::r#ascii_digit,
            ::pest3_core::typed::template::Empty,
        >,
        ::pest3_core::std::Box<
            super::generics::RepOnce::<
                super::generics::r#ascii_digit,
                ::pest3_core::typed::template::Empty,
            >,
        >,
    );
    #[allow(non_camel_case_types)]
    impl<'i> ::pest3_core::typed::PairContainer<super::Rule> for r#ascii_digits<'i> {
        fn for_each_child_pair(
            &self,
            f: &mut impl ::pest3_core::std::FnMut(::pest3_core::token::Pair<super::Rule>),
        ) {
            self.content.for_self_or_for_each_child_pair(f)
        }
        fn for_self_or_for_each_child_pair(
            &self,
            f: &mut impl ::pest3_core::std::FnMut(::pest3_core::token::Pair<super::Rule>),
        ) {
            use pest3_core::typed::PairTree;
            f(self.as_pair_tree())
        }
    }
    #[allow(non_camel_case_types)]
    impl<'i> ::pest3_core::typed::PairTree<super::Rule> for r#ascii_digits<'i> {
        fn get_rule() -> super::Rule {
            #[allow(unused_imports)]
            use pest3_core::typed::SubRule as _;
            super::Rule::r#ascii_digits
        }
        fn get_span(&self) -> (::pest3_core::std::usize, ::pest3_core::std::usize) {
            (self.span.start(), self.span.end())
        }
    }
    #[doc = "Generated for rule `ascii_nonzero_digits`. Grammar: `pest::ascii_nonzero_digit+`."]
    #[derive(Clone, Debug, Eq, PartialEq)]
    #[allow(non_camel_case_types)]
    pub struct r#ascii_nonzero_digits<'i> {
        #[doc = r" Matched structure."]
        pub content: ::pest3_core::std::Box<
            super::generics::RepOnce<
                super::generics::r#ascii_nonzero_digit,
                ::pest3_core::typed::template::Empty,
            >,
        >,
        #[doc = r" Matched span."]
        pub span: ::pest3_core::Span<'i>,
    }
    #[allow(non_camel_case_types)]
    impl<'i> ::pest3_core::typed::wrapper::Rule for r#ascii_nonzero_digits<'i> {
        type Rule = super::Rule;
        const RULE: super::Rule = super::Rule::r#ascii_nonzero_digits;
    }
    #[allow(non_camel_case_types)]
    impl<'i> r#ascii_nonzero_digits<'i> {
        #[doc = "A helper function to access [`ascii_nonzero_digit`]."]
        #[allow(non_snake_case)]
        pub fn r#ascii_nonzero_digit<'s>(
            &'s self,
        ) -> ::pest3_core::std::Vec<&'s super::generics::r#ascii_nonzero_digit> {
            let res = &*self.content;
            {
                let res = res
                    .content
                    .iter()
                    .map(|res| res)
                    .collect::<::pest3_core::std::Vec<_>>();
                res
            }
        }
    }
    #[allow(unused_imports)]
    use pest3_core::typed::SubRule as _;
    ::pest3_core::typed::full_rule_struct!(
        r#ascii_nonzero_digits,
        (),
        super::Rule,
        super::Rule::r#ascii_nonzero_digits,
        super::generics::RepOnce::<
            super::generics::r#ascii_nonzero_digit,
            ::pest3_core::typed::template::Empty,
        >,
        ::pest3_core::std::Box<
            super::generics::RepOnce::<
                super::generics::r#ascii_nonzero_digit,
                ::pest3_core::typed::template::Empty,
            >,
        >,
    );
    #[allow(non_camel_case_types)]
    impl<'i> ::pest3_core::typed::PairContainer<super::Rule> for r#ascii_nonzero_digits<'i> {
        fn for_each_child_pair(
            &self,
            f: &mut impl ::pest3_core::std::FnMut(::pest3_core::token::Pair<super::Rule>),
        ) {
            self.content.for_self_or_for_each_child_pair(f)
        }
        fn for_self_or_for_each_child_pair(
            &self,
            f: &mut impl ::pest3_core::std::FnMut(::pest3_core::token::Pair<super::Rule>),
        ) {
            use pest3_core::typed::PairTree;
            f(self.as_pair_tree())
        }
    }
    #[allow(non_camel_case_types)]
    impl<'i> ::pest3_core::typed::PairTree<super::Rule> for r#ascii_nonzero_digits<'i> {
        fn get_rule() -> super::Rule {
            #[allow(unused_imports)]
            use pest3_core::typed::SubRule as _;
            super::Rule::r#ascii_nonzero_digits
        }
        fn get_span(&self) -> (::pest3_core::std::usize, ::pest3_core::std::usize) {
            (self.span.start(), self.span.end())
        }
    }
    #[doc = "Generated for rule `ascii_bin_digits`. Grammar: `pest::ascii_bin_digit+`."]
    #[derive(Clone, Debug, Eq, PartialEq)]
    #[allow(non_camel_case_types)]
    pub struct r#ascii_bin_digits<'i> {
        #[doc = r" Matched structure."]
        pub content: ::pest3_core::std::Box<
            super::generics::RepOnce<
                super::generics::r#ascii_bin_digit,
                ::pest3_core::typed::template::Empty,
            >,
        >,
        #[doc = r" Matched span."]
        pub span: ::pest3_core::Span<'i>,
    }
    #[allow(non_camel_case_types)]
    impl<'i> ::pest3_core::typed::wrapper::Rule for r#ascii_bin_digits<'i> {
        type Rule = super::Rule;
        const RULE: super::Rule = super::Rule::r#ascii_bin_digits;
    }
    #[allow(non_camel_case_types)]
    impl<'i> r#ascii_bin_digits<'i> {
        #[doc = "A helper function to access [`ascii_bin_digit`]."]
        #[allow(non_snake_case)]
        pub fn r#ascii_bin_digit<'s>(
            &'s self,
        ) -> ::pest3_core::std::Vec<&'s super::generics::r#ascii_bin_digit> {
            let res = &*self.content;
            {
                let res = res
                    .content
                    .iter()
                    .map(|res| res)
                    .collect::<::pest3_core::std::Vec<_>>();
                res
            }
        }
    }
    #[allow(unused_imports)]
    use pest3_core::typed::SubRule as _;
    ::pest3_core::typed::full_rule_struct!(
        r#ascii_bin_digits,
        (),
        super::Rule,
        super::Rule::r#ascii_bin_digits,
        super::generics::RepOnce::<
            super::generics::r#ascii_bin_digit,
            ::pest3_core::typed::template::Empty,
        >,
        ::pest3_core::std::Box<
            super::generics::RepOnce::<
                super::generics::r#ascii_bin_digit,
                ::pest3_core::typed::template::Empty,
            >,
        >,
    );
    #[allow(non_camel_case_types)]
    impl<'i> ::pest3_core::typed::PairContainer<super::Rule> for r#ascii_bin_digits<'i> {
        fn for_each_child_pair(
            &self,
            f: &mut impl ::pest3_core::std::FnMut(::pest3_core::token::Pair<super::Rule>),
        ) {
            self.content.for_self_or_for_each_child_pair(f)
        }
        fn for_self_or_for_each_child_pair(
            &self,
            f: &mut impl ::pest3_core::std::FnMut(::pest3_core::token::Pair<super::Rule>),
        ) {
            use pest3_core::typed::PairTree;
            f(self.as_pair_tree())
        }
    }
    #[allow(non_camel_case_types)]
    impl<'i> ::pest3_core::typed::PairTree<super::Rule> for r#ascii_bin_digits<'i> {
        fn get_rule() -> super::Rule {
            #[allow(unused_imports)]
            use pest3_core::typed::SubRule as _;
            super::Rule::r#ascii_bin_digits
        }
        fn get_span(&self) -> (::pest3_core::std::usize, ::pest3_core::std::usize) {
            (self.span.start(), self.span.end())
        }
    }
    #[doc = "Generated for rule `ascii_oct_digits`. Grammar: `pest::ascii_oct_digit+`."]
    #[derive(Clone, Debug, Eq, PartialEq)]
    #[allow(non_camel_case_types)]
    pub struct r#ascii_oct_digits<'i> {
        #[doc = r" Matched structure."]
        pub content: ::pest3_core::std::Box<
            super::generics::RepOnce<
                super::generics::r#ascii_oct_digit,
                ::pest3_core::typed::template::Empty,
            >,
        >,
        #[doc = r" Matched span."]
        pub span: ::pest3_core::Span<'i>,
    }
    #[allow(non_camel_case_types)]
    impl<'i> ::pest3_core::typed::wrapper::Rule for r#ascii_oct_digits<'i> {
        type Rule = super::Rule;
        const RULE: super::Rule = super::Rule::r#ascii_oct_digits;
    }
    #[allow(non_camel_case_types)]
    impl<'i> r#ascii_oct_digits<'i> {
        #[doc = "A helper function to access [`ascii_oct_digit`]."]
        #[allow(non_snake_case)]
        pub fn r#ascii_oct_digit<'s>(
            &'s self,
        ) -> ::pest3_core::std::Vec<&'s super::generics::r#ascii_oct_digit> {
            let res = &*self.content;
            {
                let res = res
                    .content
                    .iter()
                    .map(|res| res)
                    .collect::<::pest3_core::std::Vec<_>>();
                res
            }
        }
    }
    #[allow(unused_imports)]
    use pest3_core::typed::SubRule as _;
    ::pest3_core::typed::full_rule_struct!(
        r#ascii_oct_digits,
        (),
        super::Rule,
        super::Rule::r#ascii_oct_digits,
        super::generics::RepOnce::<
            super::generics::r#ascii_oct_digit,
            ::pest3_core::typed::template::Empty,
        >,
        ::pest3_core::std::Box<
            super::generics::RepOnce::<
                super::generics::r#ascii_oct_digit,
                ::pest3_core::typed::template::Empty,
            >,
        >,
    );
    #[allow(non_camel_case_types)]
    impl<'i> ::pest3_core::typed::PairContainer<super::Rule> for r#ascii_oct_digits<'i> {
        fn for_each_child_pair(
            &self,
            f: &mut impl ::pest3_core::std::FnMut(::pest3_core::token::Pair<super::Rule>),
        ) {
            self.content.for_self_or_for_each_child_pair(f)
        }
        fn for_self_or_for_each_child_pair(
            &self,
            f: &mut impl ::pest3_core::std::FnMut(::pest3_core::token::Pair<super::Rule>),
        ) {
            use pest3_core::typed::PairTree;
            f(self.as_pair_tree())
        }
    }
    #[allow(non_camel_case_types)]
    impl<'i> ::pest3_core::typed::PairTree<super::Rule> for r#ascii_oct_digits<'i> {
        fn get_rule() -> super::Rule {
            #[allow(unused_imports)]
            use pest3_core::typed::SubRule as _;
            super::Rule::r#ascii_oct_digits
        }
        fn get_span(&self) -> (::pest3_core::std::usize, ::pest3_core::std::usize) {
            (self.span.start(), self.span.end())
        }
    }
    #[doc = "Generated for rule `ascii_hex_digits`. Grammar: `pest::ascii_hex_digit+`."]
    #[derive(Clone, Debug, Eq, PartialEq)]
    #[allow(non_camel_case_types)]
    pub struct r#ascii_hex_digits<'i> {
        #[doc = r" Matched structure."]
        pub content: ::pest3_core::std::Box<
            super::generics::RepOnce<
                super::generics::r#ascii_hex_digit,
                ::pest3_core::typed::template::Empty,
            >,
        >,
        #[doc = r" Matched span."]
        pub span: ::pest3_core::Span<'i>,
    }
    #[allow(non_camel_case_types)]
    impl<'i> ::pest3_core::typed::wrapper::Rule for r#ascii_hex_digits<'i> {
        type Rule = super::Rule;
        const RULE: super::Rule = super::Rule::r#ascii_hex_digits;
    }
    #[allow(non_camel_case_types)]
    impl<'i> r#ascii_hex_digits<'i> {
        #[doc = "A helper function to access [`ascii_hex_digit`]."]
        #[allow(non_snake_case)]
        pub fn r#ascii_hex_digit<'s>(
            &'s self,
        ) -> ::pest3_core::std::Vec<&'s super::generics::r#ascii_hex_digit> {
            let res = &*self.content;
            {
                let res = res
                    .content
                    .iter()
                    .map(|res| res)
                    .collect::<::pest3_core::std::Vec<_>>();
                res
            }
        }
    }
    #[allow(unused_imports)]
    use pest3_core::typed::SubRule as _;
    ::pest3_core::typed::full_rule_struct!(
        r#ascii_hex_digits,
        (),
        super::Rule,
        super::Rule::r#ascii_hex_digits,
        super::generics::RepOnce::<
            super::generics::r#ascii_hex_digit,
            ::pest3_core::typed::template::Empty,
        >,
        ::pest3_core::std::Box<
            super::generics::RepOnce::<
                super::generics::r#ascii_hex_digit,
                ::pest3_core::typed::template::Empty,
            >,
        >,
    );
    #[allow(non_camel_case_types)]
    impl<'i> ::pest3_core::typed::PairContainer<super::Rule> for r#ascii_hex_digits<'i> {
        fn for_each_child_pair(
            &self,
            f: &mut impl ::pest3_core::std::FnMut(::pest3_core::token::Pair<super::Rule>),
        ) {
            self.content.for_self_or_for_each_child_pair(f)
        }
        fn for_self_or_for_each_child_pair(
            &self,
            f: &mut impl ::pest3_core::std::FnMut(::pest3_core::token::Pair<super::Rule>),
        ) {
            use pest3_core::typed::PairTree;
            f(self.as_pair_tree())
        }
    }
    #[allow(non_camel_case_types)]
    impl<'i> ::pest3_core::typed::PairTree<super::Rule> for r#ascii_hex_digits<'i> {
        fn get_rule() -> super::Rule {
            #[allow(unused_imports)]
            use pest3_core::typed::SubRule as _;
            super::Rule::r#ascii_hex_digits
        }
        fn get_span(&self) -> (::pest3_core::std::usize, ::pest3_core::std::usize) {
            (self.span.start(), self.span.end())
        }
    }
    #[doc = "Generated for rule `ascii_alpha_lowers`. Grammar: `pest::ascii_alpha_lower+`."]
    #[derive(Clone, Debug, Eq, PartialEq)]
    #[allow(non_camel_case_types)]
    pub struct r#ascii_alpha_lowers<'i> {
        #[doc = r" Matched structure."]
        pub content: ::pest3_core::std::Box<
            super::generics::RepOnce<
                super::generics::r#ascii_alpha_lower,
                ::pest3_core::typed::template::Empty,
            >,
        >,
        #[doc = r" Matched span."]
        pub span: ::pest3_core::Span<'i>,
    }
    #[allow(non_camel_case_types)]
    impl<'i> ::pest3_core::typed::wrapper::Rule for r#ascii_alpha_lowers<'i> {
        type Rule = super::Rule;
        const RULE: super::Rule = super::Rule::r#ascii_alpha_lowers;
    }
    #[allow(non_camel_case_types)]
    impl<'i> r#ascii_alpha_lowers<'i> {
        #[doc = "A helper function to access [`ascii_alpha_lower`]."]
        #[allow(non_snake_case)]
        pub fn r#ascii_alpha_lower<'s>(
            &'s self,
        ) -> ::pest3_core::std::Vec<&'s super::generics::r#ascii_alpha_lower> {
            let res = &*self.content;
            {
                let res = res
                    .content
                    .iter()
                    .map(|res| res)
                    .collect::<::pest3_core::std::Vec<_>>();
                res
            }
        }
    }
    #[allow(unused_imports)]
    use pest3_core::typed::SubRule as _;
    ::pest3_core::typed::full_rule_struct!(
        r#ascii_alpha_lowers,
        (),
        super::Rule,
        super::Rule::r#ascii_alpha_lowers,
        super::generics::RepOnce::<
            super::generics::r#ascii_alpha_lower,
            ::pest3_core::typed::template::Empty,
        >,
        ::pest3_core::std::Box<
            super::generics::RepOnce::<
                super::generics::r#ascii_alpha_lower,
                ::pest3_core::typed::template::Empty,
            >,
        >,
    );
    #[allow(non_camel_case_types)]
    impl<'i> ::pest3_core::typed::PairContainer<super::Rule> for r#ascii_alpha_lowers<'i> {
        fn for_each_child_pair(
            &self,
            f: &mut impl ::pest3_core::std::FnMut(::pest3_core::token::Pair<super::Rule>),
        ) {
            self.content.for_self_or_for_each_child_pair(f)
        }
        fn for_self_or_for_each_child_pair(
            &self,
            f: &mut impl ::pest3_core::std::FnMut(::pest3_core::token::Pair<super::Rule>),
        ) {
            use pest3_core::typed::PairTree;
            f(self.as_pair_tree())
        }
    }
    #[allow(non_camel_case_types)]
    impl<'i> ::pest3_core::typed::PairTree<super::Rule> for r#ascii_alpha_lowers<'i> {
        fn get_rule() -> super::Rule {
            #[allow(unused_imports)]
            use pest3_core::typed::SubRule as _;
            super::Rule::r#ascii_alpha_lowers
        }
        fn get_span(&self) -> (::pest3_core::std::usize, ::pest3_core::std::usize) {
            (self.span.start(), self.span.end())
        }
    }
    #[doc = "Generated for rule `ascii_alpha_uppers`. Grammar: `pest::ascii_alpha_upper+`."]
    #[derive(Clone, Debug, Eq, PartialEq)]
    #[allow(non_camel_case_types)]
    pub struct r#ascii_alpha_uppers<'i> {
        #[doc = r" Matched structure."]
        pub content: ::pest3_core::std::Box<
            super::generics::RepOnce<
                super::generics::r#ascii_alpha_upper,
                ::pest3_core::typed::template::Empty,
            >,
        >,
        #[doc = r" Matched span."]
        pub span: ::pest3_core::Span<'i>,
    }
    #[allow(non_camel_case_types)]
    impl<'i> ::pest3_core::typed::wrapper::Rule for r#ascii_alpha_uppers<'i> {
        type Rule = super::Rule;
        const RULE: super::Rule = super::Rule::r#ascii_alpha_uppers;
    }
    #[allow(non_camel_case_types)]
    impl<'i> r#ascii_alpha_uppers<'i> {
        #[doc = "A helper function to access [`ascii_alpha_upper`]."]
        #[allow(non_snake_case)]
        pub fn r#ascii_alpha_upper<'s>(
            &'s self,
        ) -> ::pest3_core::std::Vec<&'s super::generics::r#ascii_alpha_upper> {
            let res = &*self.content;
            {
                let res = res
                    .content
                    .iter()
                    .map(|res| res)
                    .collect::<::pest3_core::std::Vec<_>>();
                res
            }
        }
    }
    #[allow(unused_imports)]
    use pest3_core::typed::SubRule as _;
    ::pest3_core::typed::full_rule_struct!(
        r#ascii_alpha_uppers,
        (),
        super::Rule,
        super::Rule::r#ascii_alpha_uppers,
        super::generics::RepOnce::<
            super::generics::r#ascii_alpha_upper,
            ::pest3_core::typed::template::Empty,
        >,
        ::pest3_core::std::Box<
            super::generics::RepOnce::<
                super::generics::r#ascii_alpha_upper,
                ::pest3_core::typed::template::Empty,
            >,
        >,
    );
    #[allow(non_camel_case_types)]
    impl<'i> ::pest3_core::typed::PairContainer<super::Rule> for r#ascii_alpha_uppers<'i> {
        fn for_each_child_pair(
            &self,
            f: &mut impl ::pest3_core::std::FnMut(::pest3_core::token::Pair<super::Rule>),
        ) {
            self.content.for_self_or_for_each_child_pair(f)
        }
        fn for_self_or_for_each_child_pair(
            &self,
            f: &mut impl ::pest3_core::std::FnMut(::pest3_core::token::Pair<super::Rule>),
        ) {
            use pest3_core::typed::PairTree;
            f(self.as_pair_tree())
        }
    }
    #[allow(non_camel_case_types)]
    impl<'i> ::pest3_core::typed::PairTree<super::Rule> for r#ascii_alpha_uppers<'i> {
        fn get_rule() -> super::Rule {
            #[allow(unused_imports)]
            use pest3_core::typed::SubRule as _;
            super::Rule::r#ascii_alpha_uppers
        }
        fn get_span(&self) -> (::pest3_core::std::usize, ::pest3_core::std::usize) {
            (self.span.start(), self.span.end())
        }
    }
    #[doc = "Generated for rule `ascii_alphas`. Grammar: `pest::ascii_alpha+`."]
    #[derive(Clone, Debug, Eq, PartialEq)]
    #[allow(non_camel_case_types)]
    pub struct r#ascii_alphas<'i> {
        #[doc = r" Matched structure."]
        pub content: ::pest3_core::std::Box<
            super::generics::RepOnce<
                super::generics::r#ascii_alpha,
                ::pest3_core::typed::template::Empty,
            >,
        >,
        #[doc = r" Matched span."]
        pub span: ::pest3_core::Span<'i>,
    }
    #[allow(non_camel_case_types)]
    impl<'i> ::pest3_core::typed::wrapper::Rule for r#ascii_alphas<'i> {
        type Rule = super::Rule;
        const RULE: super::Rule = super::Rule::r#ascii_alphas;
    }
    #[allow(non_camel_case_types)]
    impl<'i> r#ascii_alphas<'i> {
        #[doc = "A helper function to access [`ascii_alpha`]."]
        #[allow(non_snake_case)]
        pub fn r#ascii_alpha<'s>(
            &'s self,
        ) -> ::pest3_core::std::Vec<&'s super::generics::r#ascii_alpha> {
            let res = &*self.content;
            {
                let res = res
                    .content
                    .iter()
                    .map(|res| res)
                    .collect::<::pest3_core::std::Vec<_>>();
                res
            }
        }
    }
    #[allow(unused_imports)]
    use pest3_core::typed::SubRule as _;
    ::pest3_core::typed::full_rule_struct!(
        r#ascii_alphas,
        (),
        super::Rule,
        super::Rule::r#ascii_alphas,
        super::generics::RepOnce::<
            super::generics::r#ascii_alpha,
            ::pest3_core::typed::template::Empty,
        >,
        ::pest3_core::std::Box<
            super::generics::RepOnce::<
                super::generics::r#ascii_alpha,
                ::pest3_core::typed::template::Empty,
            >,
        >,
    );
    #[allow(non_camel_case_types)]
    impl<'i> ::pest3_core::typed::PairContainer<super::Rule> for r#ascii_alphas<'i> {
        fn for_each_child_pair(
            &self,
            f: &mut impl ::pest3_core::std::FnMut(::pest3_core::token::Pair<super::Rule>),
        ) {
            self.content.for_self_or_for_each_child_pair(f)
        }
        fn for_self_or_for_each_child_pair(
            &self,
            f: &mut impl ::pest3_core::std::FnMut(::pest3_core::token::Pair<super::Rule>),
        ) {
            use pest3_core::typed::PairTree;
            f(self.as_pair_tree())
        }
    }
    #[allow(non_camel_case_types)]
    impl<'i> ::pest3_core::typed::PairTree<super::Rule> for r#ascii_alphas<'i> {
        fn get_rule() -> super::Rule {
            #[allow(unused_imports)]
            use pest3_core::typed::SubRule as _;
            super::Rule::r#ascii_alphas
        }
        fn get_span(&self) -> (::pest3_core::std::usize, ::pest3_core::std::usize) {
            (self.span.start(), self.span.end())
        }
    }
    #[doc = "Generated for rule `ascii_alphanumerics`. Grammar: `pest::ascii_alphanumeric+`."]
    #[derive(Clone, Debug, Eq, PartialEq)]
    #[allow(non_camel_case_types)]
    pub struct r#ascii_alphanumerics<'i> {
        #[doc = r" Matched structure."]
        pub content: ::pest3_core::std::Box<
            super::generics::RepOnce<
                super::generics::r#ascii_alphanumeric,
                ::pest3_core::typed::template::Empty,
            >,
        >,
        #[doc = r" Matched span."]
        pub span: ::pest3_core::Span<'i>,
    }
    #[allow(non_camel_case_types)]
    impl<'i> ::pest3_core::typed::wrapper::Rule for r#ascii_alphanumerics<'i> {
        type Rule = super::Rule;
        const RULE: super::Rule = super::Rule::r#ascii_alphanumerics;
    }
    #[allow(non_camel_case_types)]
    impl<'i> r#ascii_alphanumerics<'i> {
        #[doc = "A helper function to access [`ascii_alphanumeric`]."]
        #[allow(non_snake_case)]
        pub fn r#ascii_alphanumeric<'s>(
            &'s self,
        ) -> ::pest3_core::std::Vec<&'s super::generics::r#ascii_alphanumeric> {
            let res = &*self.content;
            {
                let res = res
                    .content
                    .iter()
                    .map(|res| res)
                    .collect::<::pest3_core::std::Vec<_>>();
                res
            }
        }
    }
    #[allow(unused_imports)]
    use pest3_core::typed::SubRule as _;
    ::pest3_core::typed::full_rule_struct!(
        r#ascii_alphanumerics,
        (),
        super::Rule,
        super::Rule::r#ascii_alphanumerics,
        super::generics::RepOnce::<
            super::generics::r#ascii_alphanumeric,
            ::pest3_core::typed::template::Empty,
        >,
        ::pest3_core::std::Box<
            super::generics::RepOnce::<
                super::generics::r#ascii_alphanumeric,
                ::pest3_core::typed::template::Empty,
            >,
        >,
    );
    #[allow(non_camel_case_types)]
    impl<'i> ::pest3_core::typed::PairContainer<super::Rule> for r#ascii_alphanumerics<'i> {
        fn for_each_child_pair(
            &self,
            f: &mut impl ::pest3_core::std::FnMut(::pest3_core::token::Pair<super::Rule>),
        ) {
            self.content.for_self_or_for_each_child_pair(f)
        }
        fn for_self_or_for_each_child_pair(
            &self,
            f: &mut impl ::pest3_core::std::FnMut(::pest3_core::token::Pair<super::Rule>),
        ) {
            use pest3_core::typed::PairTree;
            f(self.as_pair_tree())
        }
    }
    #[allow(non_camel_case_types)]
    impl<'i> ::pest3_core::typed::PairTree<super::Rule> for r#ascii_alphanumerics<'i> {
        fn get_rule() -> super::Rule {
            #[allow(unused_imports)]
            use pest3_core::typed::SubRule as _;
            super::Rule::r#ascii_alphanumerics
        }
        fn get_span(&self) -> (::pest3_core::std::usize, ::pest3_core::std::usize) {
            (self.span.start(), self.span.end())
        }
    }
    #[doc = "Generated for rule `asciis`. Grammar: `pest::ascii+`."]
    #[derive(Clone, Debug, Eq, PartialEq)]
    #[allow(non_camel_case_types)]
    pub struct r#asciis<'i> {
        #[doc = r" Matched structure."]
        pub content: ::pest3_core::std::Box<
            super::generics::RepOnce<
                super::generics::r#ascii,
                ::pest3_core::typed::template::Empty,
            >,
        >,
        #[doc = r" Matched span."]
        pub span: ::pest3_core::Span<'i>,
    }
    #[allow(non_camel_case_types)]
    impl<'i> ::pest3_core::typed::wrapper::Rule for r#asciis<'i> {
        type Rule = super::Rule;
        const RULE: super::Rule = super::Rule::r#asciis;
    }
    #[allow(non_camel_case_types)]
    impl<'i> r#asciis<'i> {
        #[doc = "A helper function to access [`ascii`]."]
        #[allow(non_snake_case)]
        pub fn r#ascii<'s>(&'s self) -> ::pest3_core::std::Vec<&'s super::generics::r#ascii> {
            let res = &*self.content;
            {
                let res = res
                    .content
                    .iter()
                    .map(|res| res)
                    .collect::<::pest3_core::std::Vec<_>>();
                res
            }
        }
    }
    #[allow(unused_imports)]
    use pest3_core::typed::SubRule as _;
    ::pest3_core::typed::full_rule_struct!(
        r#asciis,
        (),
        super::Rule,
        super::Rule::r#asciis,
        super::generics::RepOnce::<super::generics::r#ascii, ::pest3_core::typed::template::Empty>,
        ::pest3_core::std::Box<
            super::generics::RepOnce::<
                super::generics::r#ascii,
                ::pest3_core::typed::template::Empty,
            >,
        >,
    );
    #[allow(non_camel_case_types)]
    impl<'i> ::pest3_core::typed::PairContainer<super::Rule> for r#asciis<'i> {
        fn for_each_child_pair(
            &self,
            f: &mut impl ::pest3_core::std::FnMut(::pest3_core::token::Pair<super::Rule>),
        ) {
            self.content.for_self_or_for_each_child_pair(f)
        }
        fn for_self_or_for_each_child_pair(
            &self,
            f: &mut impl ::pest3_core::std::FnMut(::pest3_core::token::Pair<super::Rule>),
        ) {
            use pest3_core::typed::PairTree;
            f(self.as_pair_tree())
        }
    }
    #[allow(non_camel_case_types)]
    impl<'i> ::pest3_core::typed::PairTree<super::Rule> for r#asciis<'i> {
        fn get_rule() -> super::Rule {
            #[allow(unused_imports)]
            use pest3_core::typed::SubRule as _;
            super::Rule::r#asciis
        }
        fn get_span(&self) -> (::pest3_core::std::usize, ::pest3_core::std::usize) {
            (self.span.start(), self.span.end())
        }
    }
    #[doc = "Generated for rule `newline`. Grammar: `pest::newline+`."]
    #[derive(Clone, Debug, Eq, PartialEq)]
    #[allow(non_camel_case_types)]
    pub struct r#newline<'i> {
        #[doc = r" Matched structure."]
        pub content: ::pest3_core::std::Box<
            super::generics::RepOnce<
                super::generics::r#newline,
                ::pest3_core::typed::template::Empty,
            >,
        >,
        #[doc = r" Matched span."]
        pub span: ::pest3_core::Span<'i>,
    }
    #[allow(non_camel_case_types)]
    impl<'i> ::pest3_core::typed::wrapper::Rule for r#newline<'i> {
        type Rule = super::Rule;
        const RULE: super::Rule = super::Rule::r#newline;
    }
    #[allow(non_camel_case_types)]
    impl<'i> r#newline<'i> {
        #[doc = "A helper function to access [`newline`]."]
        #[allow(non_snake_case)]
        pub fn r#newline<'s>(&'s self) -> ::pest3_core::std::Vec<&'s super::generics::r#newline> {
            let res = &*self.content;
            {
                let res = res
                    .content
                    .iter()
                    .map(|res| res)
                    .collect::<::pest3_core::std::Vec<_>>();
                res
            }
        }
    }
    #[allow(unused_imports)]
    use pest3_core::typed::SubRule as _;
    ::pest3_core::typed::full_rule_struct!(
        r#newline,
        (),
        super::Rule,
        super::Rule::r#newline,
        super::generics::RepOnce::<super::generics::r#newline, ::pest3_core::typed::template::Empty>,
        ::pest3_core::std::Box<
            super::generics::RepOnce::<
                super::generics::r#newline,
                ::pest3_core::typed::template::Empty,
            >,
        >,
    );
    #[allow(non_camel_case_types)]
    impl<'i> ::pest3_core::typed::PairContainer<super::Rule> for r#newline<'i> {
        fn for_each_child_pair(
            &self,
            f: &mut impl ::pest3_core::std::FnMut(::pest3_core::token::Pair<super::Rule>),
        ) {
            self.content.for_self_or_for_each_child_pair(f)
        }
        fn for_self_or_for_each_child_pair(
            &self,
            f: &mut impl ::pest3_core::std::FnMut(::pest3_core::token::Pair<super::Rule>),
        ) {
            use pest3_core::typed::PairTree;
            f(self.as_pair_tree())
        }
    }
    #[allow(non_camel_case_types)]
    impl<'i> ::pest3_core::typed::PairTree<super::Rule> for r#newline<'i> {
        fn get_rule() -> super::Rule {
            #[allow(unused_imports)]
            use pest3_core::typed::SubRule as _;
            super::Rule::r#newline
        }
        fn get_span(&self) -> (::pest3_core::std::usize, ::pest3_core::std::usize) {
            (self.span.start(), self.span.end())
        }
    }
    #[doc = "Generated for rule `unicode`. Grammar: `(pest::unicode::xid_start ~ pest::unicode::xid_continue*)`."]
    #[derive(Clone, Debug, Eq, PartialEq)]
    #[allow(non_camel_case_types)]
    pub struct r#unicode<'i> {
        #[doc = r" Matched structure."]
        pub content: ::pest3_core::std::Box<
            super::generics::Sequence2<
                super::unicode::XID_START,
                ::pest3_core::typed::template::Empty,
                super::generics::Rep<
                    super::unicode::XID_CONTINUE,
                    ::pest3_core::typed::template::Empty,
                >,
                __OptionalTrivia<'i>,
            >,
        >,
        #[doc = r" Matched span."]
        pub span: ::pest3_core::Span<'i>,
    }
    #[allow(non_camel_case_types)]
    impl<'i> ::pest3_core::typed::wrapper::Rule for r#unicode<'i> {
        type Rule = super::Rule;
        const RULE: super::Rule = super::Rule::r#unicode;
    }
    #[allow(non_camel_case_types)]
    impl<'i> r#unicode<'i> {
        #[doc = "A helper function to access [`xid_continue`]."]
        #[allow(non_snake_case)]
        pub fn r#xid_continue<'s>(
            &'s self,
        ) -> ::pest3_core::std::Vec<&'s super::unicode::XID_CONTINUE> {
            let res = &*self.content;
            {
                let res = &res.field_1;
                {
                    let res = res
                        .content
                        .iter()
                        .map(|res| res)
                        .collect::<::pest3_core::std::Vec<_>>();
                    res
                }
            }
        }
        #[doc = "A helper function to access [`xid_start`]."]
        #[allow(non_snake_case)]
        pub fn r#xid_start<'s>(&'s self) -> &'s super::unicode::XID_START {
            let res = &*self.content;
            {
                let res = &res.field_0;
                res
            }
        }
    }
    #[allow(unused_imports)]
    use pest3_core::typed::SubRule as _;
    ::pest3_core::typed::full_rule_struct!(
        r#unicode,
        (),
        super::Rule,
        super::Rule::r#unicode,
        super::generics::Sequence2::<
            super::unicode::XID_START,
            ::pest3_core::typed::template::Empty,
            super::generics::Rep::<
                super::unicode::XID_CONTINUE,
                ::pest3_core::typed::template::Empty,
            >,
            __OptionalTrivia::<'i>,
        >,
        ::pest3_core::std::Box<
            super::generics::Sequence2::<
                super::unicode::XID_START,
                ::pest3_core::typed::template::Empty,
                super::generics::Rep::<
                    super::unicode::XID_CONTINUE,
                    ::pest3_core::typed::template::Empty,
                >,
                __OptionalTrivia::<'i>,
            >,
        >,
    );
    #[allow(non_camel_case_types)]
    impl<'i> ::pest3_core::typed::PairContainer<super::Rule> for r#unicode<'i> {
        fn for_each_child_pair(
            &self,
            f: &mut impl ::pest3_core::std::FnMut(::pest3_core::token::Pair<super::Rule>),
        ) {
            self.content.for_self_or_for_each_child_pair(f)
        }
        fn for_self_or_for_each_child_pair(
            &self,
            f: &mut impl ::pest3_core::std::FnMut(::pest3_core::token::Pair<super::Rule>),
        ) {
            use pest3_core::typed::PairTree;
            f(self.as_pair_tree())
        }
    }
    #[allow(non_camel_case_types)]
    impl<'i> ::pest3_core::typed::PairTree<super::Rule> for r#unicode<'i> {
        fn get_rule() -> super::Rule {
            #[allow(unused_imports)]
            use pest3_core::typed::SubRule as _;
            super::Rule::r#unicode
        }
        fn get_span(&self) -> (::pest3_core::std::usize, ::pest3_core::std::usize) {
            (self.span.start(), self.span.end())
        }
    }
    #[doc = "Generated for rule `han`. Grammar: `pest::unicode::han+`."]
    #[derive(Clone, Debug, Eq, PartialEq)]
    #[allow(non_camel_case_types)]
    pub struct r#han<'i> {
        #[doc = r" Matched structure."]
        pub content: ::pest3_core::std::Box<
            super::generics::RepOnce<super::unicode::HAN, ::pest3_core::typed::template::Empty>,
        >,
        #[doc = r" Matched span."]
        pub span: ::pest3_core::Span<'i>,
    }
    #[allow(non_camel_case_types)]
    impl<'i> ::pest3_core::typed::wrapper::Rule for r#han<'i> {
        type Rule = super::Rule;
        const RULE: super::Rule = super::Rule::r#han;
    }
    #[allow(non_camel_case_types)]
    impl<'i> r#han<'i> {
        #[doc = "A helper function to access [`han`]."]
        #[allow(non_snake_case)]
        pub fn r#han<'s>(&'s self) -> ::pest3_core::std::Vec<&'s super::unicode::HAN> {
            let res = &*self.content;
            {
                let res = res
                    .content
                    .iter()
                    .map(|res| res)
                    .collect::<::pest3_core::std::Vec<_>>();
                res
            }
        }
    }
    #[allow(unused_imports)]
    use pest3_core::typed::SubRule as _;
    ::pest3_core::typed::full_rule_struct!(
        r#han,
        (),
        super::Rule,
        super::Rule::r#han,
        super::generics::RepOnce::<super::unicode::HAN, ::pest3_core::typed::template::Empty>,
        ::pest3_core::std::Box<
            super::generics::RepOnce::<super::unicode::HAN, ::pest3_core::typed::template::Empty>,
        >,
    );
    #[allow(non_camel_case_types)]
    impl<'i> ::pest3_core::typed::PairContainer<super::Rule> for r#han<'i> {
        fn for_each_child_pair(
            &self,
            f: &mut impl ::pest3_core::std::FnMut(::pest3_core::token::Pair<super::Rule>),
        ) {
            self.content.for_self_or_for_each_child_pair(f)
        }
        fn for_self_or_for_each_child_pair(
            &self,
            f: &mut impl ::pest3_core::std::FnMut(::pest3_core::token::Pair<super::Rule>),
        ) {
            use pest3_core::typed::PairTree;
            f(self.as_pair_tree())
        }
    }
    #[allow(non_camel_case_types)]
    impl<'i> ::pest3_core::typed::PairTree<super::Rule> for r#han<'i> {
        fn get_rule() -> super::Rule {
            #[allow(unused_imports)]
            use pest3_core::typed::SubRule as _;
            super::Rule::r#han
        }
        fn get_span(&self) -> (::pest3_core::std::usize, ::pest3_core::std::usize) {
            (self.span.start(), self.span.end())
        }
    }
    #[doc = "Generated for rule `hangul`. Grammar: `pest::unicode::hangul+`."]
    #[derive(Clone, Debug, Eq, PartialEq)]
    #[allow(non_camel_case_types)]
    pub struct r#hangul<'i> {
        #[doc = r" Matched structure."]
        pub content: ::pest3_core::std::Box<
            super::generics::RepOnce<super::unicode::HANGUL, ::pest3_core::typed::template::Empty>,
        >,
        #[doc = r" Matched span."]
        pub span: ::pest3_core::Span<'i>,
    }
    #[allow(non_camel_case_types)]
    impl<'i> ::pest3_core::typed::wrapper::Rule for r#hangul<'i> {
        type Rule = super::Rule;
        const RULE: super::Rule = super::Rule::r#hangul;
    }
    #[allow(non_camel_case_types)]
    impl<'i> r#hangul<'i> {
        #[doc = "A helper function to access [`hangul`]."]
        #[allow(non_snake_case)]
        pub fn r#hangul<'s>(&'s self) -> ::pest3_core::std::Vec<&'s super::unicode::HANGUL> {
            let res = &*self.content;
            {
                let res = res
                    .content
                    .iter()
                    .map(|res| res)
                    .collect::<::pest3_core::std::Vec<_>>();
                res
            }
        }
    }
    #[allow(unused_imports)]
    use pest3_core::typed::SubRule as _;
    ::pest3_core::typed::full_rule_struct!(
        r#hangul,
        (),
        super::Rule,
        super::Rule::r#hangul,
        super::generics::RepOnce::<super::unicode::HANGUL, ::pest3_core::typed::template::Empty>,
        ::pest3_core::std::Box<
            super::generics::RepOnce::<super::unicode::HANGUL, ::pest3_core::typed::template::Empty>,
        >,
    );
    #[allow(non_camel_case_types)]
    impl<'i> ::pest3_core::typed::PairContainer<super::Rule> for r#hangul<'i> {
        fn for_each_child_pair(
            &self,
            f: &mut impl ::pest3_core::std::FnMut(::pest3_core::token::Pair<super::Rule>),
        ) {
            self.content.for_self_or_for_each_child_pair(f)
        }
        fn for_self_or_for_each_child_pair(
            &self,
            f: &mut impl ::pest3_core::std::FnMut(::pest3_core::token::Pair<super::Rule>),
        ) {
            use pest3_core::typed::PairTree;
            f(self.as_pair_tree())
        }
    }
    #[allow(non_camel_case_types)]
    impl<'i> ::pest3_core::typed::PairTree<super::Rule> for r#hangul<'i> {
        fn get_rule() -> super::Rule {
            #[allow(unused_imports)]
            use pest3_core::typed::SubRule as _;
            super::Rule::r#hangul
        }
        fn get_span(&self) -> (::pest3_core::std::usize, ::pest3_core::std::usize) {
            (self.span.start(), self.span.end())
        }
    }
    #[doc = "Generated for rule `hiragana`. Grammar: `pest::unicode::hiragana+`."]
    #[derive(Clone, Debug, Eq, PartialEq)]
    #[allow(non_camel_case_types)]
    pub struct r#hiragana<'i> {
        #[doc = r" Matched structure."]
        pub content: ::pest3_core::std::Box<
            super::generics::RepOnce<
                super::unicode::HIRAGANA,
                ::pest3_core::typed::template::Empty,
            >,
        >,
        #[doc = r" Matched span."]
        pub span: ::pest3_core::Span<'i>,
    }
    #[allow(non_camel_case_types)]
    impl<'i> ::pest3_core::typed::wrapper::Rule for r#hiragana<'i> {
        type Rule = super::Rule;
        const RULE: super::Rule = super::Rule::r#hiragana;
    }
    #[allow(non_camel_case_types)]
    impl<'i> r#hiragana<'i> {
        #[doc = "A helper function to access [`hiragana`]."]
        #[allow(non_snake_case)]
        pub fn r#hiragana<'s>(&'s self) -> ::pest3_core::std::Vec<&'s super::unicode::HIRAGANA> {
            let res = &*self.content;
            {
                let res = res
                    .content
                    .iter()
                    .map(|res| res)
                    .collect::<::pest3_core::std::Vec<_>>();
                res
            }
        }
    }
    #[allow(unused_imports)]
    use pest3_core::typed::SubRule as _;
    ::pest3_core::typed::full_rule_struct!(
        r#hiragana,
        (),
        super::Rule,
        super::Rule::r#hiragana,
        super::generics::RepOnce::<super::unicode::HIRAGANA, ::pest3_core::typed::template::Empty>,
        ::pest3_core::std::Box<
            super::generics::RepOnce::<
                super::unicode::HIRAGANA,
                ::pest3_core::typed::template::Empty,
            >,
        >,
    );
    #[allow(non_camel_case_types)]
    impl<'i> ::pest3_core::typed::PairContainer<super::Rule> for r#hiragana<'i> {
        fn for_each_child_pair(
            &self,
            f: &mut impl ::pest3_core::std::FnMut(::pest3_core::token::Pair<super::Rule>),
        ) {
            self.content.for_self_or_for_each_child_pair(f)
        }
        fn for_self_or_for_each_child_pair(
            &self,
            f: &mut impl ::pest3_core::std::FnMut(::pest3_core::token::Pair<super::Rule>),
        ) {
            use pest3_core::typed::PairTree;
            f(self.as_pair_tree())
        }
    }
    #[allow(non_camel_case_types)]
    impl<'i> ::pest3_core::typed::PairTree<super::Rule> for r#hiragana<'i> {
        fn get_rule() -> super::Rule {
            #[allow(unused_imports)]
            use pest3_core::typed::SubRule as _;
            super::Rule::r#hiragana
        }
        fn get_span(&self) -> (::pest3_core::std::usize, ::pest3_core::std::usize) {
            (self.span.start(), self.span.end())
        }
    }
    #[doc = "Generated for rule `arabic`. Grammar: `pest::unicode::arabic+`."]
    #[derive(Clone, Debug, Eq, PartialEq)]
    #[allow(non_camel_case_types)]
    pub struct r#arabic<'i> {
        #[doc = r" Matched structure."]
        pub content: ::pest3_core::std::Box<
            super::generics::RepOnce<super::unicode::ARABIC, ::pest3_core::typed::template::Empty>,
        >,
        #[doc = r" Matched span."]
        pub span: ::pest3_core::Span<'i>,
    }
    #[allow(non_camel_case_types)]
    impl<'i> ::pest3_core::typed::wrapper::Rule for r#arabic<'i> {
        type Rule = super::Rule;
        const RULE: super::Rule = super::Rule::r#arabic;
    }
    #[allow(non_camel_case_types)]
    impl<'i> r#arabic<'i> {
        #[doc = "A helper function to access [`arabic`]."]
        #[allow(non_snake_case)]
        pub fn r#arabic<'s>(&'s self) -> ::pest3_core::std::Vec<&'s super::unicode::ARABIC> {
            let res = &*self.content;
            {
                let res = res
                    .content
                    .iter()
                    .map(|res| res)
                    .collect::<::pest3_core::std::Vec<_>>();
                res
            }
        }
    }
    #[allow(unused_imports)]
    use pest3_core::typed::SubRule as _;
    ::pest3_core::typed::full_rule_struct!(
        r#arabic,
        (),
        super::Rule,
        super::Rule::r#arabic,
        super::generics::RepOnce::<super::unicode::ARABIC, ::pest3_core::typed::template::Empty>,
        ::pest3_core::std::Box<
            super::generics::RepOnce::<super::unicode::ARABIC, ::pest3_core::typed::template::Empty>,
        >,
    );
    #[allow(non_camel_case_types)]
    impl<'i> ::pest3_core::typed::PairContainer<super::Rule> for r#arabic<'i> {
        fn for_each_child_pair(
            &self,
            f: &mut impl ::pest3_core::std::FnMut(::pest3_core::token::Pair<super::Rule>),
        ) {
            self.content.for_self_or_for_each_child_pair(f)
        }
        fn for_self_or_for_each_child_pair(
            &self,
            f: &mut impl ::pest3_core::std::FnMut(::pest3_core::token::Pair<super::Rule>),
        ) {
            use pest3_core::typed::PairTree;
            f(self.as_pair_tree())
        }
    }
    #[allow(non_camel_case_types)]
    impl<'i> ::pest3_core::typed::PairTree<super::Rule> for r#arabic<'i> {
        fn get_rule() -> super::Rule {
            #[allow(unused_imports)]
            use pest3_core::typed::SubRule as _;
            super::Rule::r#arabic
        }
        fn get_span(&self) -> (::pest3_core::std::usize, ::pest3_core::std::usize) {
            (self.span.start(), self.span.end())
        }
    }
    #[doc = "Generated for rule `emoji`. Grammar: `pest::unicode::emoji+`."]
    #[derive(Clone, Debug, Eq, PartialEq)]
    #[allow(non_camel_case_types)]
    pub struct r#emoji<'i> {
        #[doc = r" Matched structure."]
        pub content: ::pest3_core::std::Box<
            super::generics::RepOnce<super::unicode::EMOJI, ::pest3_core::typed::template::Empty>,
        >,
        #[doc = r" Matched span."]
        pub span: ::pest3_core::Span<'i>,
    }
    #[allow(non_camel_case_types)]
    impl<'i> ::pest3_core::typed::wrapper::Rule for r#emoji<'i> {
        type Rule = super::Rule;
        const RULE: super::Rule = super::Rule::r#emoji;
    }
    #[allow(non_camel_case_types)]
    impl<'i> r#emoji<'i> {
        #[doc = "A helper function to access [`emoji`]."]
        #[allow(non_snake_case)]
        pub fn r#emoji<'s>(&'s self) -> ::pest3_core::std::Vec<&'s super::unicode::EMOJI> {
            let res = &*self.content;
            {
                let res = res
                    .content
                    .iter()
                    .map(|res| res)
                    .collect::<::pest3_core::std::Vec<_>>();
                res
            }
        }
    }
    #[allow(unused_imports)]
    use pest3_core::typed::SubRule as _;
    ::pest3_core::typed::full_rule_struct!(
        r#emoji,
        (),
        super::Rule,
        super::Rule::r#emoji,
        super::generics::RepOnce::<super::unicode::EMOJI, ::pest3_core::typed::template::Empty>,
        ::pest3_core::std::Box<
            super::generics::RepOnce::<super::unicode::EMOJI, ::pest3_core::typed::template::Empty>,
        >,
    );
    #[allow(non_camel_case_types)]
    impl<'i> ::pest3_core::typed::PairContainer<super::Rule> for r#emoji<'i> {
        fn for_each_child_pair(
            &self,
            f: &mut impl ::pest3_core::std::FnMut(::pest3_core::token::Pair<super::Rule>),
        ) {
            self.content.for_self_or_for_each_child_pair(f)
        }
        fn for_self_or_for_each_child_pair(
            &self,
            f: &mut impl ::pest3_core::std::FnMut(::pest3_core::token::Pair<super::Rule>),
        ) {
            use pest3_core::typed::PairTree;
            f(self.as_pair_tree())
        }
    }
    #[allow(non_camel_case_types)]
    impl<'i> ::pest3_core::typed::PairTree<super::Rule> for r#emoji<'i> {
        fn get_rule() -> super::Rule {
            #[allow(unused_imports)]
            use pest3_core::typed::SubRule as _;
            super::Rule::r#emoji
        }
        fn get_span(&self) -> (::pest3_core::std::usize, ::pest3_core::std::usize) {
            (self.span.start(), self.span.end())
        }
    }
    #[doc = "Generated for rule `whitespace`. Grammar: `\" \"`."]
    #[derive(Clone, Debug, Eq, PartialEq)]
    #[allow(non_camel_case_types)]
    pub struct r#whitespace<'i> {
        #[doc = r" Matched structure."]
        pub content: ::pest3_core::std::Box<super::generics::Str<super::wrapper::W6>>,
        #[doc = r" Matched span."]
        pub span: ::pest3_core::Span<'i>,
    }
    #[allow(non_camel_case_types)]
    impl<'i> ::pest3_core::typed::wrapper::Rule for r#whitespace<'i> {
        type Rule = super::Rule;
        const RULE: super::Rule = super::Rule::r#whitespace;
    }
    #[allow(non_camel_case_types)]
    impl<'i> r#whitespace<'i> {}
    #[allow(unused_imports)]
    use pest3_core::typed::SubRule as _;
    ::pest3_core::typed::full_rule_struct!(
        r#whitespace,
        (),
        super::Rule,
        super::Rule::r#whitespace,
        super::generics::Str::<super::wrapper::W6>,
        ::pest3_core::std::Box<super::generics::Str::<super::wrapper::W6>>,
    );
    #[allow(non_camel_case_types)]
    impl<'i> ::pest3_core::typed::PairContainer<super::Rule> for r#whitespace<'i> {
        fn for_each_child_pair(
            &self,
            f: &mut impl ::pest3_core::std::FnMut(::pest3_core::token::Pair<super::Rule>),
        ) {
            self.content.for_self_or_for_each_child_pair(f)
        }
        fn for_self_or_for_each_child_pair(
            &self,
            f: &mut impl ::pest3_core::std::FnMut(::pest3_core::token::Pair<super::Rule>),
        ) {
            use pest3_core::typed::PairTree;
            f(self.as_pair_tree())
        }
    }
    #[allow(non_camel_case_types)]
    impl<'i> ::pest3_core::typed::PairTree<super::Rule> for r#whitespace<'i> {
        fn get_rule() -> super::Rule {
            #[allow(unused_imports)]
            use pest3_core::typed::SubRule as _;
            super::Rule::r#whitespace
        }
        fn get_span(&self) -> (::pest3_core::std::usize, ::pest3_core::std::usize) {
            (self.span.start(), self.span.end())
        }
    }
    #[doc = "Generated for rule `comment`. Grammar: `\"$\"+`."]
    #[derive(Clone, Debug, Eq, PartialEq)]
    #[allow(non_camel_case_types)]
    pub struct r#comment<'i> {
        #[doc = r" Matched structure."]
        pub content: ::pest3_core::std::Box<
            super::generics::RepOnce<
                super::generics::Str<super::wrapper::W7>,
                ::pest3_core::typed::template::Empty,
            >,
        >,
        #[doc = r" Matched span."]
        pub span: ::pest3_core::Span<'i>,
    }
    #[allow(non_camel_case_types)]
    impl<'i> ::pest3_core::typed::wrapper::Rule for r#comment<'i> {
        type Rule = super::Rule;
        const RULE: super::Rule = super::Rule::r#comment;
    }
    #[allow(non_camel_case_types)]
    impl<'i> r#comment<'i> {}
    #[allow(unused_imports)]
    use pest3_core::typed::SubRule as _;
    ::pest3_core::typed::full_rule_struct!(
        r#comment,
        (),
        super::Rule,
        super::Rule::r#comment,
        super::generics::RepOnce::<
            super::generics::Str::<super::wrapper::W7>,
            ::pest3_core::typed::template::Empty,
        >,
        ::pest3_core::std::Box<
            super::generics::RepOnce::<
                super::generics::Str::<super::wrapper::W7>,
                ::pest3_core::typed::template::Empty,
            >,
        >,
    );
    #[allow(non_camel_case_types)]
    impl<'i> ::pest3_core::typed::PairContainer<super::Rule> for r#comment<'i> {
        fn for_each_child_pair(
            &self,
            f: &mut impl ::pest3_core::std::FnMut(::pest3_core::token::Pair<super::Rule>),
        ) {
            self.content.for_self_or_for_each_child_pair(f)
        }
        fn for_self_or_for_each_child_pair(
            &self,
            f: &mut impl ::pest3_core::std::FnMut(::pest3_core::token::Pair<super::Rule>),
        ) {
            use pest3_core::typed::PairTree;
            f(self.as_pair_tree())
        }
    }
    #[allow(non_camel_case_types)]
    impl<'i> ::pest3_core::typed::PairTree<super::Rule> for r#comment<'i> {
        fn get_rule() -> super::Rule {
            #[allow(unused_imports)]
            use pest3_core::typed::SubRule as _;
            super::Rule::r#comment
        }
        fn get_span(&self) -> (::pest3_core::std::usize, ::pest3_core::std::usize) {
            (self.span.start(), self.span.end())
        }
    }
}
mod wrapper {
    #[doc = "A wrapper for `\"abc\"`."]
    #[derive(Clone, Debug, Hash, PartialEq, Eq)]
    pub struct W0;
    impl ::pest3_core::typed::wrapper::String for W0 {
        const CONTENT: &'static ::core::primitive::str = "abc";
    }
    #[doc = "A wrapper for `\",\"`."]
    #[derive(Clone, Debug, Hash, PartialEq, Eq)]
    pub struct W1;
    impl ::pest3_core::typed::wrapper::String for W1 {
        const CONTENT: &'static ::core::primitive::str = ",";
    }
    #[doc = "A wrapper for `\"FAIL\"`."]
    #[derive(Clone, Debug, Hash, PartialEq, Eq)]
    pub struct W2;
    impl ::pest3_core::typed::wrapper::String for W2 {
        const CONTENT: &'static ::core::primitive::str = "FAIL";
    }
    #[doc = "A wrapper for `\"\"`."]
    #[derive(Clone, Debug, Hash, PartialEq, Eq)]
    pub struct W3;
    impl ::pest3_core::typed::wrapper::String for W3 {
        const CONTENT: &'static ::core::primitive::str = "";
    }
    #[doc = "A wrapper for `\"a\"`."]
    #[derive(Clone, Debug, Hash, PartialEq, Eq)]
    pub struct W4;
    impl ::pest3_core::typed::wrapper::String for W4 {
        const CONTENT: &'static ::core::primitive::str = "a";
    }
    #[doc = "A wrapper for `\"b\"`."]
    #[derive(Clone, Debug, Hash, PartialEq, Eq)]
    pub struct W5;
    impl ::pest3_core::typed::wrapper::String for W5 {
        const CONTENT: &'static ::core::primitive::str = "b";
    }
    #[doc = "A wrapper for `\" \"`."]
    #[derive(Clone, Debug, Hash, PartialEq, Eq)]
    pub struct W6;
    impl ::pest3_core::typed::wrapper::String for W6 {
        const CONTENT: &'static ::core::primitive::str = " ";
    }
    #[doc = "A wrapper for `\"$\"`."]
    #[derive(Clone, Debug, Hash, PartialEq, Eq)]
    pub struct W7;
    impl ::pest3_core::typed::wrapper::String for W7 {
        const CONTENT: &'static ::core::primitive::str = "$";
    }
}
pub use pest3_core::typed::unicode;
#[doc = "Used generics."]
pub mod generics {
    pub use pest3_core::choice::Choice2;
    pub use pest3_core::choice::Choice3;
    pub use pest3_core::sequence::Sequence2;
    pub use pest3_core::sequence::Sequence3;
    pub use pest3_core::sequence::Sequence4;
    pub use pest3_core::sequence::Sequence6;
    pub use pest3_core::typed::template::{
        CharRange, Insens, Negative, PeekSlice1, PeekSlice2, Positive, Rep, RepMax, RepMin,
        RepMinMax, RepOnce, Str, ANY as any, ASCII as ascii, ASCII_ALPHA as ascii_alpha,
        ASCII_ALPHANUMERIC as ascii_alphanumeric, ASCII_ALPHA_LOWER as ascii_alpha_lower,
        ASCII_ALPHA_UPPER as ascii_alpha_upper, ASCII_BIN_DIGIT as ascii_bin_digit,
        ASCII_DIGIT as ascii_digit, ASCII_HEX_DIGIT as ascii_hex_digit,
        ASCII_NONZERO_DIGIT as ascii_nonzero_digit, ASCII_OCT_DIGIT as ascii_oct_digit,
        DROP as drop, EOI, EOI as eoi, NEWLINE as newline, PEEK as peek, PEEK_ALL as peek_all,
        POP as pop, POP_ALL as pop_all, PUSH as push, SOI, SOI as soi,
    };
}
